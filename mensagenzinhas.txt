valor de abordagens arquitetônicas arraigadas profundamente no conhecimento do domínio e de
usabilidade do software.
Este livro não é sobre isso ou, pelo menos, não de modo direto. Mas ele passa uma
mensagem mais sutil cuja essência não deve ser subestimada. Ele se encaixa à máxima atual
das pessoas que realmente se preocupam com o código, como Peter Sommerlad, Kevlin Henney
e Giovanni. "O código é o projeto" e "Código simples" são seus mantras. Enquanto devamos
tentar nos lembrar de que a interface é o programa, e que suas estruturas dizem bastante sobre a
estrutura de nosso programa, é crucial adotar a humilde postura de que o projeto vive no código.
E enquanto o retrabalho na metáfora da manufatura leva ao custo, o no projeto leva ao valor.
Devemos ver nosso código como a bela articulação dos nobres esforços do projeto - projeto
como um processo, e não uma meta estática. É no código que ocorrem as medidas estruturais
de acoplamento e coesão. Se você vir a descrição de Larry Constantine sobre esses dois fatores,
ele os conceitua em termos de código - e não em conceitos de alto nível como se pode encontrar
em UML. Richard Gabriel nos informa em seu artigo Abstraction Descant que a abstração é
maligna. O código é antimaligno, e talvez o código limpo seja divino.
notar que a sabedoria Voltando à minha pequena embalagem de Ga-Jol, acho importante
dinamarquesa nos aconselha a não só prestar atenção a pequenas coisas, mas também a ser
honesto em pequenas coisas. Isso significa ser honesto com o código e tanto com nossos colegas
e, acima de tudo, com nós mesmos sobre o estado de nosso código. Fizemos o Melhor para "deixar
o local mais limpo do que como o encontramos"? Refatoramos nosso código antes de verificálo? Essas não são preocupações externas, mas preocupações que estão no centro dos valores
do Agile. Que a refatoração seja parte do conceito de "Pronto", é uma prática recomendada no
Scrum. Nema arquitetura e nem o código limpo exigem perfeição, apenas honestidade e que
façamos o melhor de nós. Errar é humano; perdoar é divino. No Scrum, tornamos as coisas
visíveis. Arejamos nossa roupa suja. Somos honestos sobre o estado de nosso código porque
o código nunca é perfeito. Tornamo-nos mais completamente humanos, mais merecedores do
divino e mais próximos da magnitude dos detalhes.
Em nossa profissão, precisamos desesperadamente de toda ajuda que conseguirmos. Se o piso
de uma loja reduz os acidentes e suas ferramentas bem organizadas aumentam a produtividade,
então sou totalmente a favor. E relação a este livro, ele é a melhor aplicação pragmática dos
princípios de Lean ao software que já vi. Eu não esperava nada mais deste pequeno grupo prático
de indivíduos que se esforçaram juntos por anos não só para se aperfeiçoarem, mas também
para presentear com seus conhecimentos o mercado com obras como esta em suas mãos agora.
Isso deixa o mundo um pouco melhor do que quando o encontrei antes de Uncle Bob me enviar
o manuscrito. Após ter finalizado estes exercícios com conhecimentos tão sublimes, agora vou
limpar minha mesa.
James O. Coplien
Mørdrup, Dinamarca
Introdução
The ONLy VALid MeASureMeNT
OF Code QUALiTY: WTFS/MiNUTе
WTF WTF
WTF IS
THIS SHIT
code
Review
code
Review
WTF
dude,
WTF
Good code. BAd code.
WTF
Reproduzido com a gentil autorização de Thom Holwerda.
http://www.osnews.com/story/19266/WTFs_m
(c) 2008 Focus Shift
Que porta representa seu código? Que porta representa sua equipe ou sua companhia?
Por que estamos naquela sala? É apenas uma revisão normal de código ou encontramos uma série
de problemas terríveis logo após iniciarmos a apresentação? Estamos depurando em pânico, lendo
meticulosamente um código que pensávamos que funcionava? Os clientes estão indo embora aos
bandos e estamos com os gerentes em nossos pescoços? Como podemos garantir que cheguemos
atrás da porta certa quando o caminho fica difícil? A resposta é: habilidade profissional.
Há duas vertentes para se obter habilidade profissional: conhecimento e trabalho. Você deve
adquirir o conhecimento dos princípios, padrões, práticas e heurísticas que um profissional
habilidoso sabe, e também esmiuçar esse conhecimento com seus dedos, olhos e corpo por meio
do trabalho árduo e da prática.
Posso lhe ensinar a mecânica para se andar de bicicleta. Na verdade, a matemática clássica
é relativamente direta. Gravidade, atrito, momento angular, centro de massa, e assim por diante,
podem ser demonstrados com menos de uma página cheia de equações. Dada essas fórmulas,
eu poderia provar para você que é prático andar de bicicleta e lhe dar todo o conhecimento
necessário para que você consiga. E mesmo assim você cairá na primeira vez que tentar.
Programar não é diferente. Poderíamos pôr no papel todos os princípios necessários para um
código limpo e, então, confiar que você fará as tarefas (isto é, deixar você cair quando subir na bicicleta), mas que tipo de professores e de estudantes isso faria de nós?
Não. Essa não é a forma que este livro seguirá.
Aprender a criar códigos limpos é uma tarefa árdua e requer mais do que o simples
conhecimento dos princípios e padrões. Você deve suar a camisa; praticar sozinho e ver que
cometeu erros; assistir a outros praticarem e errarem; vê-los tropeçar e refazer seus passos; Vêlos agonizar para tomar decisões e o preço que pagarão por as terem tomado da maneira errada.
Esteja preparado para trabalhar duro enquanto ler este livro. Esse não é um livro fácil e
simples que você pode ler num avião e terminar antes de aterrissar. Este livro lhe fará trabalhar,
e trabalhar duro. Que tipo de trabalho você fará? Você lerá códigos aqui, muitos códigos.
E você deverá descobrir o que está correto e errado nos códigos. Você terá de seguir o
raciocínio conforme dividirmos módulos e os unirmos novamente. Isso levará tempo e esforço,
mas achamos que valerá a pena.
Dividimos este livro em três partes. Na primeira há diversos capítulos que descrevem os
princípios, padrões e práticas para criar um código limpo. Há um tanto de códigos nessa parte, e
será desafiador lê-los. Eles lhe prepararão para a seção seguinte. Se você deixar o livro de lado
após essa primeira parte. Bem, boa sorte!
Na segunda parte entra o trabalho pesado que consiste em diversos estudos de caso de
complexidade cada vez maior. Cada um é um exercício para limpar um código - resolver alguns
problemas dele. O detalhamento nesta seção é intenso. Você terá de ir e voltar por entre as folhas
de textos e códigos, e analisar e entender o código com o qual estamos trabalhando e captar nosso
raciocínio para cada alteração que fizermos. Reserve um tempo para essa parte, pois deverá levar
dias.
A terceira parte é a compensação. É um único capítulo com uma lista de heurísticas e "odores"
reunidos durante a criação dos estudos de caso. Conforme progredirmos e limparmos os códigos
nos estudos de caso, documentaremos cada motivo para nossas ações como uma heurística ou um
"odor". Tentaremos entender nossas próprias reações em relação ao código quando estivermos
lendo ou alterando-o, e trabalharemos duro para captar por que nos sentimos de tal forma e por
que fizemos isso ou aquilo. O resultado será um conhecimento base que descreve a forma como
pensamos quando criamos, lemos e limpamos um código.
Este conhecimento base possui um valor limitado se você não ler com atenção ao longo dos
casos de estudo na segunda parte deste livro. Neles, anotamos cuidadosamente cada alteração
que fizemos com referências posteriores às heurísticas. Tais referências aparecem em colchetes,
assim: [H22]. Isso lhe permite ver o contexto no qual são aplicadas e escritas aquelas heurísticas!
Essas, em si, não são tão valiosas, mas, sim, a relação entre elas e as diferentes decisões que
tomamos ao limpar o código nos casos de estudo.
A fim de lhe ajudar ainda mais com essas relações, colocamos no final do livro uma referência
cruzada que mostra o número da página para cada referência. Você pode usá-la com um guia
rápido de consulta para saber onde uma determinada heurística foi aplicada.
Mesmo se você ler a primeira e a terceira seções e pular para os casos de estudo, ainda
assim terá lido um livro que satisfaz sobre a criação de um bom software. Mas se não tiver
pressa e explorar os casos de estudo, seguindo cada pequeno passo e cada minuto de decisão, se
colocando em nosso lugar e se forçando a seguir a mesma linha de raciocínio que usamos, então
você adquiriu um entendimento muito mais rico de todos aqueles princípios, padrões, práticas
e heurísticas. Todo esse conhecimento ficará em cada fibra de seu corpo. Ele se tornará parte de
você da mesma forma que ao aprender a andar de bicicleta, ela se torna uma parte de sua vontade
de pedalá-la.
Agradecimentos
Ilustrações
Meus agradecimentos a minhas duas artistas, Jeniffer Kohnke e Angela Brooks. Jennifer é a
responsável pelas maravilhosas e criativas figuras no início de cada capítulo e também pelos
retratos de Kent Beck, Ward Cunningham, Bjarne Stroustrup, Ron Jeffries, Grady Booch, Dave
Thomas, Michael Feathers e de mim mesmo.
Angela é a responsável pelas figuras engenhosas que enfeitam os capítulos.Ao longo dos anos.
ela criou bastantes imagens para mim, incluindo muitas das que estão no livro Agile Software
Develpment: Principles, Patterns, and Practices. Angela também é minha primogênita e de quem
me sinto muito orgulhoso.
Sobre a capа
A imagem da capa se é a M104 - a Galáxia Sombrero -, que fica na constelação de Virgem
e está a pouco menos de 30 milhões de anos-luz de nós. Em seu centro há um buraco negro
supermassivo cujo peso equivale um bilhão de vezes a massa do sol.
A imagem lhe faz lembrar da explosão da lua Praxis, de Klingon? Eu me recordo vividamente
a cena de Jornada nas Estrelas VI que mostrava um anel equatorial de destroços voando devido à
explosão. Desde essa cena, o anel equatorial se tornou um componente comum às explosões em
filmes de ficção científica. Ele até foi adicionado à explosão de Alderaan nas últimas versões do
filme Jornada nas Estrelas.
O que causou a formação desse anel em torno de M104? Por que ele possui um bojo tão
amplo e um núcleo tão minúsculo e brilhoso? Parece-me como se o buraco negro central perdeu
sua graça e lançou um buraco de 30.000 anos-luz no meio da galáxia, devastando quaisquer
civilizações que estivessem no caminho daquele distúrbio cósmico.
Buracos negros supermassivos engolem estrelas inteiras no almoço, convertendo uma
considerável fração de sua massa em energia. E = MC2 já
é bastante potência, mas quando M é uma massa estelar:
Cuidado! Quantas estrelas caíram impetuosamente
naquelas presas antes de o monstro ficar saciado?
O tamanho do vão central poderia ser uma dica?
A imagem de M104 da capa é uma combinação da
famosa fotografia de luz visível do Hubble (foto superior)
com a recente imagem infravermelha do observatório
espacial Spitzer (foto inferior). E essa segunda imagem
que nos mostra claramente a natureza do anel da galáxia.
Na luz visível, vemos apenas a extremidade frontal do anel
como uma silhueta. O bojo central ofusca o resto do anel.
Mas no infravermelho, as partículas "quentes"- isto
é, altamente radioativas - no anel brilham através do bojo
central. A combinação de ambas as imagens nos mostra
uma visão que não havíamos visto antes e indica que, há
muito tempo atrás, lá havia um inferno enfurecido de atividades.
Cover image: Spitzer Space Telescope
KOHJKE
0
3
1
Código Limpo
Há duas razões pelas quais você está lendo este livro: você é programador e deseja se tornar um
ainda melhor. Ótimo. Precisamos de programadores melhores.
2 Capítulo 1: Código Limpo
Este livro fala sobre programação e está repleto de códigos que examinaremos a partir
de diferentes perspectivas: de baixo para cima, de cima para baixo e de dentro para fora. Ao
terminarmos, teremos um amplo conhecimento sobre códigos e seremos capazes de distinguir
entre um código bom e um código ruim. Saberemos como escrever um bom código e como
tornar um ruim em um bom.
Código
Podem dizer que um livro sobre códigos é, de certa forma, algo ultrapassado, que a
programação deixou de ser uma preocupação e que devemos nos preocupar com modelos
e requisitos. Outros até mesmo alegam que o fim do código, ou seja, da programação, está
próximo; que logo todo código será gerado, e não mais escrito. E que não precisarão mais de
programadores, pois as pessoas criarão programas a partir de especificações.
Bobagens! Nunca nos livraremos dos códigos, pois eles representam os detalhes dos
requisitos. Em certo nível, não há como ignorar ou abstrair esses detalhes; eles precisam
ser especificados. E especificar requisitos detalhadamente de modo que uma máquina possa
executá-los é programar e tal especificação é o código.
Espero que o nível de de nossas linguagens continue a aumentar e que o número de
linguagens específicas a um domínio continue crescendo. Isso será bom, mas não acabará com
a programação. De fato, todas as especificações escritas nessas linguagens de níveis mais altos
e específicas a um domínio serão códigos! Eles precisarão ser minuciosos, exatos e bastante
formais e detalhados para que uma máquina possa entendê-los e executá-los.
As pessoas que pensam que o código um dia desaparecerá são como matemáticos que
esperam algum dia descobrir uma matemática que não precise ser formal. Elas esperam que
um dia descubramos uma forma de criar máquinas que possam fazer o que desejamos em vez
do que mandamos. Tais máquinas terão de ser capazes de nos entender tão bem de modo que
possam traduzir exigências vagamente especificadas em programas executáveis perfeitos para
satisfazer nossas necessidades.
Isso jamais acontecerá. Nem mesmo os seres humanos, com toda sua intuição e criatividade,
têm sido capazes de criar sistemas bem-sucedidos a partir das carências confusas de seus
clientes. Na verdade, se a matéria sobre especificação de requisitos não nos ensinou nada, é
porque os requisitos bem especificados são tão formais quanto os códigos e podem agir como
testes executáveis de tais códigos!
Lembre-se de que o código é a linguagem na qual expressamos nossos requisitos. Podemos
criar linguagens que sejam mais próximas a eles. Podemos criar ferramentas que nos ajudem
a analisar a sintaxe e unir tais requisitos em estruturas formais. Mas jamais eliminaremos a
precisão necessária - portanto, sempre haverá um código.
Código Ruim 3
Código ruim
Recentemente li o prefácio do livro Implementation
Patterns de Kent Beck, no qual ele diz "... este livro
baseia-se numa premissa frágil de que um bom código
importa...". Uma premissa frágil? Não concordo! Acho
que essa premissa é uma das mais robustas, apoiadas
e plenas do que todas as outras em nossa área (e sei
que Kent sabe disso). Estamos cientes de que um bom
código importa, pois tivemos de lidar com a falta dele
por muito tempo.
Lembro que no final da década de 1980 uma empresa
criou um aplicativo extraordinário que se tornou muito
popular e muitos profissionais o compraram e usaram.
Mas, então, o intervalo entre os lançamentos das novas
distribuições começou a aumentar. Os bugs não eram
consertados na distribuição seguinte. E o tempo de
carregamento do aplicativo e o número de travamentos
aumentaram. Lembro-me do dia em que, frustrado,
fechei o programa e nunca mais o usei. A empresa saiu
do mercado logo depois.
Duas décadas depois encontrei um dos funcionários de tal empresa na época e o perguntei o
que havia acontecido, e o que eu temia fora confirmado. Eles tiveram de apressar o lançamento
do produto e, devido a isso, o código ficou uma zona. Então, conforme foram adicionando mais
e mais recursos, o código piorava cada vez mais até que simplesmente não era mais possível
gerenciá-lo. Foi o código ruim que acabou com a empresa.
Alguma vez um código ruim já lhe atrasou consideravelmente? Se você for um programador,
independente de sua experiência, então já se deparou várias vezes com esse obstáculo. Aliás, é
como se caminhássemos penosamente por um lamaçal de arbustos emaranhados com armadilhas
ocultas.Isso é o que fazemos num código ruim. Pelejamos para encontrar nosso caminho,
esperando avistar alguma dica, alguma indicação do que está acontecendo; mas tudo o que
vemos é um código cada vez mais sem sentido.
É claro que um código ruim já lhe atrasou. Mas, então, por que você o escreveu dessa forma?
Estava tentando ser rápido? Estava com pressa? Provavelmente. Talvez você pensou que não
tivesse tempo para fazer um bom trabalho; que seu chefe ficaria com raiva se você demorasse
um pouco mais para limpar seu código. Talvez você estava apenas cansado de trabalhar neste
programa e queria terminá-lo logo. Ou verificou a lista de coisas que havia prometido fazer e
percebeu que precisava finalizar este módulo de uma vez, de modo que pudesse passar para o
próximo. Todos já fizemos isso, já vimos a bagunça que fizemos e, então, optamos por arrumálas outro dia. Todos já nos sentimos aliviados ao vermos nosso programa confuso funcionar e
decidimos que uma bagunça que funciona é melhor do que nada. Todos nós já dissemos que
revisaríamos e limparíamos o código depois. É claro que naquela época não conhecíamos a lei
de LeBlanc: Nunca é tarde.
1. [Beck07]
4
O Custo de Ter um Código Confuso
Capítulo 1: Código Limpo
Se você é programador a mais de dois ou três anos, provavelmente o código confuso de outra
pessoa já fez com que você trabalhasse mais lentamente e provavelmente seu próprio código já
lhe trouxe problemas.
do
O nível de retardo pode ser significativo. Ao longo de um ou dois anos, as equipes que
trabalharam rapidamente no início de um projeto podem perceber mais tarde que estão indo a
passos de tartaruga. Cada alteração feita no código causa uma falha em outras duas ou três partes
mesmo código. Mudança alguma é trivial. Cada adição ou modificação ao sistema exige
que restaurações, amarrações e remendos sejam "entendidas" de modo que outras possam ser
incluídas. Com o tempo, a bagunça se torna tão grande e profunda que não dá para arrumá-la.
Não há absolutamente solução alguma.
Conforme a confusão aumenta, a produtividade da equipe diminui, assintoticamente
aproximando-se de zero. Com a redução da produtividade, a gerência faz a única coisa que ela
pode; adiciona mais membros ao projeto na esperança de aumentar a produtividade. Mas esses
novos membros não conhecem o projeto do sistema, não sabem a diferença entre uma mudança
que altera o propósito do projeto e aquela que o atrapalha. Ademais, eles, e todo o resto da
equipe, estão sobre tremenda pressão para aumentar a produtividade. Com isso todos criam mais
e mais confusões, levando a produtividade mais perto ainda de zero (veja a Figura 1.1). Productivity
100
80
60
40
20
이
Time
Figura 1.1
Produtividade v. tempо
O Custo de Ter um Código Confuso 5
O Grande Replanejamento
No final, a equipe se rebela. Todos informam à gerência que não conseguem mais trabalhar neste
irritante código-fonte e exigem um replanejamento do projeto. Apesar de a gerência não querer
gastar recursos em uma nova remodelação, ela não pode negar que a produtividade está péssima.
No final das contas, ela acaba cedendo às exigências dos desenvolvedores e autoriza o grande
replanejamento desejado.
É, então, formada uma nova equipe especializada. Por ser um projeto inteiramente novo,
todos querem fazer parte dessa equipe. Eles desejam começar do zero e criar algo belo de verdade.
Mas apenas os melhores e mais brilhantes são selecionados e os outros deverão continuar na
manutenção do sistema atual.
Agora ambos os times estão numa corrida. A nova equipe precisa construir um novo sistema
que faça o mesmo que o antigo, além de ter de se manter atualizada em relação às mudanças
feitas constantemente no sistema antigo. Este, a gerência não substituirá até que o novo possa
fazer tudo também.
Essa corrida pode durar um bom tempo. Já vi umas levarem 10 anos. E, quando ela termina,
os membros originais da nova equipe já foram embora há muito tempo, e os atuais exigem o
replanejamento de um novo sistema, pois está tudo uma zona novamente.
Se você já vivenciou pelo menos um pouco dessa situação, então sabe que dedicar
tempo para limpar seu código não é apenas eficaz em termos de custo, mas uma questão de
sobrevivência profissional.
Atitude
Você já teve de trabalhar penosamente por uma confusão tão grave que levou semanas o que
deveria ter levado horas? Você já presenciou o que deveria ser uma alteração única e direta, mas
que em vez disso foi feita em diversos módulos distintos? Todos esses sintomas são bastante
comuns.
Por que isso ocorre em um código? Por que um código bom se decompõe tão rápido em
um ruim? Temos diversas explicações para isso. Reclamamos que os requisitos mudaram de
tal forma que estragaram o projeto original. Criticamos os prazos por serem curtos demais para
fazermos as coisas certas. Resmungamos sobre gerentes tolos e clientes intolerantes e tipos de
marketing inúteis e técnicos de telefone. Mas o padrão, querido Dilbert", não está em nossas
estrelas, mas sim em nós mesmos. Somos profissionais.
Isso pode ser algo dificil de engolir. Mas como poderia essa zona ser nossa culpa? E os
requisitos? E o prazo? E os tolos gerentes e tipos de marketing inúteis? Eles não carregam
alguma parcela da culpa?
Não. Os gerentes e marketeiros buscam em nós as informações que precisam para fazer promessas
e firmarem compromissos; e mesmo quando não nons procuram, não devemos dar uma de tímidos ao
dizer-lhes nossa opinião. Os usuários esperam que validemos as maneiras pelas quais os requisitos se
encaixarão no sistema. Os gerentes esperam que os ajudemos a cumprir o prazo. Nossa cumplicidade
no planejamento do projeto é tamanha que compartilhamos de uma grande parcela da responsabilidade
em caso de falhas; especialmente se estas forem em relação a um código ruim.
6 Capítulo 1: Código Limpo
"Mas, espere!", você diz. "E se eu não fizer o que meu gerente quer, serei demitido". É
provável que não.
A maioria dos gerentes quer a verdade, mesmo que demonstrem o contrário. A maioria deles
quer um código bom, mesmo estourando o prazo. Eles podem proteger com paixão o prazo e os
requisitos, mas essa é a função deles.A sua é proteger o código com essa mesma paixão.
Para finalizar essa questão, e se você fosse médico e um paciente exigisse que você parasse
com toda aquela lavação das mãos na preparação para a cirurgia só porque isso leva muito tempo?2
É óbvio que o chefe neste caso é o paciente; mas, mesmo assim, o médico deverá totalmente se
recusar obedecê-lo. Por quê? Porque o médico sabe mais do que o paciente sobre os riscos de
doenças e infecções. Não seria profissional (sem mencionar criminoso) que o médico obedecesse
ao paciente neste cenário. Da mesma forma que não é profissional que programadores cedam à
vontade dos gerentes que não entendem os riscos de se gerar códigos confusos.
O Principal Dilema
Os programadores se deparam com um dilema de valores básicos. Todos os desenvolvedores
com alguns anos a mais de experiência sabem que bagunças antigas reduzem o rendimento.
Mesmo assim todos eles se sentem pressionados a cometer essas bagunças para cumprir os
prazos. Resumindo, eles não se esforçam para.
Os profissionais sérios sabem que a segunda parte do dilema está errada. Você não cumprirá
o prazo se fizer bagunça no código. De fato, tal desorganização reduzirá instantaneamente sua
velocidade de trabalho, e você perderá o prazo. A única maneira de isso não acontecer - a única
maneira de ir mais rápido - é sempre manter o código limpo.
A Arte do Código Limpo?
Digamos que você acredite que um código confuso seja um obstáculo relevante. Digamos que
você aceite que a única forma de trabalhar mais rápido é manter seu código limpo. Então, você
deve se perguntar: "Como escrever um código limpo?" Não vale de nada tentar escrever um
código limpo se você não souber o que isso significa.
As más notícias são que escrever um código limpo é como pintar um quadro. A maioria de
nós sabe quando a figura foi bem ou mal pintada. Mas ser capaz de distinguir uma boa arte de
uma ruim não significa que você saiba pintar. Assim como saber distinguir um código limpo de
um ruim não quer dizer que saibamos escrever um código limpo.
Escrever um código limpo exige o uso disciplinado de uma miríade de pequenas técnicas
aplicadas por meio de uma sensibilidade meticulosamente adquirida sobre "limpeza". А
"sensibilidade ao código" é o segredo. Alguns de nós já nascemos com ela. Outros precisam se
esforçar para adquiri-la. Ela não só nos permite perceber se o código é bom ou ruim, como também
nos mostra a estratégia e disciplina de como transformar um código ruim em um limpo.
Um programador sem "sensibilidade ao código" pode visualizar um módulo confuso e
reconhecer a bagunça, mas não saberá o que fazer a respeito dela. Já um com essa sensibilidade
olhará um módulo confuso e verá alternativas. A "sensibilidade ao código" ajudará a esse
Em 1847.quando Ignaz Semmelweis sugeriu pela primeira vez a lavagem das mãos, ela foi rejeitada, baseando-se no fato de que os médicos cram ocupados
O Custo de Ter um Código Confuso
programador a escolher a melhor alternativa e o orientará na criação de uma sequência de
comportamentos para proteger as alterações feitas aqui e ali.
Em suma, um programador que escreve um código limpo é um artista que pode pegar
uma tela em branco e submetê-la a uma série de transformações até que se torne um sistema
graciosamente programado.
que é um Código Limpo?
Provavelmente existem tantas definições como existem programadores. Portanto, perguntei a
alguns programadores bem conhecidos e com muita experiência o que achavam.
Bjarne Stroustrup, criador do C++
e autor do livro A linguagem de
programação C++
Gosto do meu código elegante e eficiente. A lógica
deve ser direta para dificultar o encobrimento de bugs.
as dependências minimas para facilitar a manutenção,
o tratamento de erro completo de acordo com uma
estratégia clara e o desempenho próximo do mais
eficiente de modo a não incitar as pessoas a tornarem o
código confuso com otimizações sorrateiras. O código
limpo faz bem apenas uma coisa.
Bjarne usa a palavra "elegante" - uma
palavra e tanto! O dicionário possui as seguintes
definições: que se caracteriza pela naturalidade
de harmonia, leveza, simplicidade; naturalidade
no modo se dispor; requintado, fino, estiloso.
Observe a ênfase dada à palavra "naturalidade".
Aparentemente, Bjarne acha que um código limpo proporciona uma leitura natural; e lê-lo deve
ser belo como ouvir uma música num rádio ou visualizar um carro de design magnífico.
Bjarne também menciona duas vezes "eficiência". Talvez isso não devesse nos surpreender
vindo do criador do C++, mas acho que ele quis dizer mais do que um simples desejo por
agilidade. A repetição de ciclos não é elegante, não é belo. E repare que Bjarne usa a palavra
"incitar" para descrever a consequência de tal deselegância. A verdade aqui é que um código
ruim incita o crescimento do caos num código. Quando outras pessoas alteram um código ruim,
elas tendem a piorá-lo.
Pragmáticos, Dave Thomas e Andy Hunt expressam isso de outra forma. Eles usam a metáfora
das janelas quebradas.3 Uma construção com janelas quebradas parece que ninguém cuida dela.
Dessa forma, outras pessoas deixam de se preocupar com ela também. Elas permitem que as
outras janelas se quebrem também. No final das contas, as próprias pessoas as quebram. Elas
estragam a fachada com pichações e deixam acumular lixo. Uma única janela inicia o processo
de degradação.
3. http/www.pragmaticprogrammer.com/booksellers/2004-12.html
8 Capítulo 1: Código Limpo
Bjarne também menciona que o tratamento de erro deva ser completo. Isso significa prestar
atenção nos detalhes. Um tratamento de erro reduzido é apenas uma das maneiras pela qual
os programadores deixam de notar os detalhes. Perdas de memória e condições de corrida são
outras. Nomenclaturas inconsistentes são ainda outras. A conclusão é que um código limpo
requer bastante atenção aos detalhes.
a
Bjarne conclui com a asseveração de que um código limpo faz bem apenas uma coisa. Não é
por acaso que há inúmeros princípios de desenvolvimento de software que podem ser resumidos
essa simples afirmação. Vários escritores já tentaram passar essa ideia. Um código ruim
tenta fazer coisas demais, ele está cheio de propósitos obscuros e ambíguos. O código limpo é
centralizado. Cada função, cada classe, cada módulo expõe uma única tarefa que nunca sofre
interferência de outros detalhes ou fica rodeada por eles.
Grady Booch, autor do livro Object
Oriented Analysis and Design with
Applications
Um código limpo é simples e direto. Ele é tão bem legivel
quanto uma prosa bem escrita. Ele jamais torna confuso o
objetivo do desenvolvedor, em vez disso, ele está repleto de
abstrações claras e linhas de controle objetivas.
Grady fala de alguns dos mesmos pontos que Bjarne,
voltando-se mais para questão da legibilidade. Eu,
particularmente, gosto desse ponto de vista de que ler um
código limpo deve ser como ler uma prosa bem escrita.
Pense num livro muito bom que você já leu. Lembre-se de como as palavras eram substituídas
por imagens! Era como assistir a um filme, não era? Melhor ainda, você via os personagens,
ouvia os sons, envolvia-se nas emoções e no humor.
Ler um código limpo jamais será como ler O senhor dos anéis. Mesmo assim, a analogia
com a literatura não é ruim. Como um bom romance, um código limpo deve expor claramente
as questões do problema a ser solucionado. Ele deve desenvolvê-las até um clímax e, então, dar
ao leitor aquele "Ahá! Mas é claro!", como as questões e os suspenses que são solucionados na
revelação de uma solução óbvia.
Acho que o uso que Grady faz da frase "abstrações claras" é um paradoxo fascinante!
Apesar de tudo, a palavra "clara" é praticamente um sinônimo para "explicito". Meu dicionário
MacBook tem a seguinte definição para "claro(a)": direto, decisivo, sem devaneios ou detalhes
desnecessários. Apesar desta justaposição de significados, as palavras carregam uma mensagem
poderosa. Nosso código deve ser decisivo, sem especulações. Ele deve conter apenas o necessário.
Nossos leitores devem assumir que fomos decisivos.
O Custo de Ter um Código Confuso 9
O "grande" Dave Thomas, fundador da
OTI, o pai da estratégia Eclipse
Além de seu criador, um desenvolvedor pode ler e melhorar
um côdigo limpo. Ele tem testes de unidade e de aceitação,
nomes significativos; ele oferece apenas uma maneira, e não
várias, de se fazer uma tarefa; possui poucas dependências,
as quais são explicitamente declaradas e oferecem um
API mínimo e claro. O código deve ser inteligivel já que
dependendo da linguagem, nem toda informação necessária
pode expressa no código em si.
Dave compartilha do mesmo desejo de Grady pela
legibilidade, mas com uma diferença relevante. Dave
afirma que um código limpo facilita para que outras
pessoas o melhorem. Pode parecer óbvio, mas não se deve
enfatizar muito isso. Há, afinal de contas, uma diferença
entre um código fácil de ler e um fácil de alterar.
KOHNKE
Dave associa limpeza a testes! Dez anos atrás, isso levantaria um ar de desconfiança. Mas o
estudo do Desenvolvimento Dirigido a Testes teve grande impacto em nossa indústria e se tornou
uma de nossos campos de estudo mais essenciais. Dave está certo. Um código, sem testes, não
está limpo. Não importa o quão elegante, legível ou acessível esteja que, se ele não possuir testes,
ele não é limpo.
Dave usa a palavra mínima duas vezes. Aparentemente ele dá preferência a um código
pequeno. De fato, esse tem sido uma citação comum na literatura computacional. Quando menor,
melhor. Dave também diz que o código deve ser inteligivel - referência esta à programação
inteligivel (do livro Literate Programming) de Donald Knuth. A conclusão é que o código deve
ser escrito de uma forma que seja inteligível aos seres humanos.
Michael Feathers, autor de Working
Effectively with Legacy Code
Eu poderia listar todas as qualidades que vejo em um código
limpo, mas há uma predominante que leva a todas as outras.
Um código limpo sempre parece que foi escrito por alguém
que se importava. Não há nada de óbvio no que se pode fazer
para torná-lo melhor. Tudo foi pensado pelo autor do código,
e se tentar pensar em algumas melhoras, você voltará ao
inicio, ou seja, apreciando o código deixado para você por
alguém que se importa bastante com essa tarefa.
One word: care. É esse o assunto deste livro. Talvez
um subtítulo apropriado seria Como se importar
com o código.
Michael bate na testa: um código limpo é um código
que foi cuidado por alguém. Alguém que calmamente
KOHNKE
4. [Knuth92].
10 Capítulo 1: Código Limpo
o manteve simples e organizado; alguém que prestoua atenção necessária aos detalhes; alguém
que se importou.
Ron Jeffries, autor de Extreme
Programming Installed and Extreme
Programming Adventures in C#
Ron iniciou sua carreira de programador em Fortran, no
Strategic Air Command, e criou códigos em quase todas
as linguagens e máquinas. Vale a pena considerar suas
palavras:
Nestes anos recentes, comecei, e quase finalizei, com as regras
de Beck sobre código simples. Em ordem de prioridade, são:
•Efetue todos os testes;
• Sem duplicação de código:
• Expressa todas as ideias do projeto que estão no sistema;
• Minimiza o número de entidades, como classes, métodos.
funções e outras do tipo.
Dessas quatro, foco-me mais na de duplicação. Quando a mesma coisa éfeita repetidas vezes, é sinal de que
uma ideia em sua cabeça não está bem representada no código. Tento descobrir o que é e, então, expressar
aquela ideia com mais clareza.
Expressividade para mim são nomes significativos e costume mudar o nome das coisas várias vezes antes de
finalizar. Com ferramentas de programação modernas, como a Eclipse, renomear é bastante fácil, e por isso
não me incomodo em fazer isso. Entretanto, a expressividade vai além de nomes. Também verifico se um método
ou objeto faz mais de uma tarefa. Se for um objeto, provavelmente ele precisará ser dividido em dois ou mais. Se
for um método, sempre uso a refatoração do Método de Extração nele, resultando em um método que expressa
mais claramente sua função e em outros métodos que dizem como ela é feita.
Duplicação e expressividade me levam ao que considero um código limpo, e melhorar um código ruim com
apenas esses dois conceitos na mente pode fazer uma grande diferença. Há. porém, uma outra coisa da qual
estou ciente quando programo, que é um pouco mais dificil de explicar.
Após anos de trabalho, parece-me que todos os programadores pensam tudo igual. Um exemplo é "encontrar
coisas numa coleção". Tenhamos uma base de dados com registros de funcionários ou uma tabela hash de
chaves e valores ou um vetor de itens de algum tipo, geralmente procuramos um item especifico naquela
coleção. Quando percebo isso, costumo implementar essa função em um método ou classe mais abstrato-o
que me proporciona algumas vantagens interessantes
Posso implementar a funcionalidade agora com algo mais simples, digamos uma tabela hash, mas como agora
todas as referências àquela busca estão na minha classe ou método abstrato, posso alterar a implementação
sempre que desejar. Posso ainda prosseguir rapidamente enquanto preservo a capacidade de alteração
jutura.
Além disso, a de coleções geralmente chama minha atenção para o que realmente está acontecendo, e impede
que eu implemente funcionalidades arbitrárias em coleções quando tudo que eu preciso são simples maneiras de
encontrar o que desejo. Redução de duplicação de código, alta expressividade e criação no inicio de abstrações
simples. É isso que torna para mim um código limро.
Aqui, em alguns breves parágrafos, Ron resumiu o conteúdo deste livro. Sem duplicação, uma
tarefa, expressividade, pequenas abstrações. Tudo foi mencionado.
O Custo de Ter um Código Confuso 11
Ward Cunningham, criador do conceito
de "WikiWiki", criador do Fit, co-criador
da Programação Extrema (eXtreme
Programming). Incentivador dos Padrões
de Projeto. Líder da Smalltalk e da OО.
Pai de todos aqueles que se importam
com o código.
Você sabe que estácriando um código limpo quando cada rotina
que você leia se mostra como o que você esperava. Você pode
chamar de código belo quando ele também faz parecer que a
linguagem foi feita para o probleта.
Declarações como essa são características de Ward. Você a
KOHNKE
é lê, coloca na sua cabeça e segue para a próxima. Parece tão racional, tão óbvio que raramente
memorizada como algo profundo. Você acha que basicamente já pensava assim. Mas observemos
mais atentamente.
"... o que você esperava". Qual foi a última vez que você viu um módulo como você o
esperava que fosse? Não é mais comum eles serem complexos, complicados, emaranhados?
Interpretá-lo erroneamente não é a regra? Você não está acostumadoa se descontrolar ao tentar
entender o raciocínio que gerou todo o sistema e associá-lo ao módulo que estás lendo? Quando
foi a última vez que você leu um código para o qual você assentiu com a cabeça da mesma forma
que fez com a declaração de Ward?
Este espera que ao ler um código limpo nada lhe surpreenda. De fato, não será nem preciso
muito esforço. Você irá lê-lo e será basicamente o que você já esperava. O código é óbvio,
simples e convincente. Cada módulo prepara o terreno para o seguinte. Cada um lhe diz como o
próximo estará escrito. Os programas que são tão limpos e claros assim foram tão bem escritos
que você nem perceberá. O programador o faz parecer super simples, como o é todo projeto
extraordinário.
E a noção de beleza do Ward? Todos já reclamamos do fato de nossas linguagens não tiverem
sido desenvolvidas para os nossos problemas. Mas a declaração de Ward coloca novamente
o peso sobre nós. Ele diz que um código belo faz parecer que a linguagem foi feita para
problema! Portanto, é nossa responsabilidade fazer a linguagem parecer simples! Há brigas
por causa das linguagens em todo lugar, cuidado! Não é a linguagem que faz os programas
parecerem simples, é o programador!
이
12 Capítulo 1: Código Limpo
Escolas de Pensamento
E eu (Tio Bob)? O que é um código limpo para mim? É
isso o que este livro lhe dirá em detalhes, o que eu e meus
compatriotas consideramos um código limpo. Diremo-lhe o
que consideramos como nomes limpos de variáveis, funções
limpas, classes limpas etc. Apresentaremos nossos conceitos
como verdades absolutas, e não nos desculparemos por nossa
austeridade. Para nós, a essa altura de nossa carreira, tais
conceitos são absolutos. São nossa escola de pensamento
acerca do que seja um código limpo.
Nem todos os mestres de artes marciais concordam KOHNRE
com qual seria a melhor arte marcial de todas ou a melhor
técnica dentro de uma arte marcial específica. Geralmente,
eles criam suas próprias escolas de pensamento e recrutam
alunos para serem ensinados. Dessa forma, temos o Jiu
Jitsu dos Gracie, criado e ensinado pela família Gracie, no Brasil; o Jiu Jitsu de Hakkoryu,
criado e ensinado por Okuyama Ryuho, em Tóquio; e o Jeet Kune Do, criado e ensinado por
Bruce Lee, nos EUA.
Ο
Os estudantes se dedicam à doutrina ensinada por aquela determinada arte, e aprendem
que seus mestres ensinam, geralmente ignorando os ensinamentos de outros mestres. Depois,
conforme os estudantes progridem, costuma-se mudar o mestre de modo que possam expandir
seus conhecimentos e práticas. Alguns, no final, continuam a fim de refinar suas habilidades,
descobrem novas técnicas e criam suas próprias escolas.
Nenhuma dessas escolas está 100% certa. Mesmo assim dentro de uma determinada escola
agimos como os ensinamentos e técnicas fossem os certos. Apesar de tudo, há uma forma correta
de praticar o Jiu Jitsu de Hakkoryu, ou Jeet Kune Do. Mas essa retidão dentro de uma escola não
invalida as técnicas de outra.
e
Considere este livro como uma descrição da Escola de Código Limpo da Object Mentor. As
técnicas e ensinamentos são a maneira pela qual praticamos nossa arte. Estamos dispostos a alegar
que se você seguir esses ensinamentos, desfrutará dos beneficios que também aproveitamos
aprenderá a escrever códigos limpos e profissionais. Mas não pense você que nós estamos 100%
"certos". Provavelmente há outras escolas e mestres que têm tanto para oferecer quanto nós. O
correto seria que você aprendesse com elas também.
De fato, muitas das recomendações neste livro são contraditórias. Provavelmente você não
concordará com todas e poderá até mesmo discordar intensivamente com algumas. Tudo bem.
Não podemos querer ter a palavra final. Por outro lado, pensamos bastante e por muito tempo
sobre as recomendações neste livro. As aprendemos ao longo de décadas de experiência e
repetidos testes e erros. Portanto, concorde você ou não, seria uma pena se você não conseguisse
enxergar nosso ponto de vista.
Somos Autores 13
Somos Autores
O campo @author de um Javadoc nos diz quem somos. Nós somos autores, e todo autor tem
leitores, com os quais uma boa comunicação é de responsabilidade dos autores. Na próxima vez
em que você escrever uma linha de código, lembre-se de que você é um autor, escrevendo para
leitores que julgarão seus esforços.
Você talvez se pergunte: o quanto realmente se lê de um código? A maioria do trabalho não
é escrevê-lo?
Você já reproduziu uma sessão de edição? Nas décadas de 1980 e 1990, tínhamos editores,
como o Emacs, que mantinham um registro de cada tecla pressionada. Você podia trabalhar
por horas e, então, reproduzir toda a sua sessão de edição como um filme passando em alta
velocidade. Quando fiz isso, os resultados foram fascinantes.
A grande maioria da reprodução era rolamento de tela e navegação para outros módulos!
Bob entra no modulo.
Ele descia até a função que precisava ser alterada.
Ele para e pondera suas opções.
Oh, ele sobe para o início do módulo a fim de verificar a inicialização da variável.
Agora ele desce novamente e começa a digitar.
Opa, ele está apagando o que digitou!
Ele digita novamente.
Ele apaga novamente.
Ele digita a metade de algo e apaga! a
Ele desce até outra função que chama a que ele está modificando para ver como ela é
chamada.
Ele sobe novamente e digita o mesmo código que acabara de digitar.
Ele para.
Ele apaga novamente!
Ele abre uma outrajanela e analisa uma subclasse. A função é anulada?
Bem, você entendeu! Na verdade, a taxa de tempo gasto na leitura v. na escrita é de 10x1.
Constantemente lemos um código antigo quando estamos criando um novo.
Devido à tamanha diferença, desejamos que a leitura do código seja fácil, mesmo se sua
criação for árdua. É claro que não há como escrever um código sem lê-lo, portanto torná-lo de
fácil leitura realmente facilita a escrita.
Não há como escapar desta lógica. Você não pode escrever um código se não quiser ler as
outras partes dele. O código que você tenta escrever hoje será de dificil ou fácil leitura dependendo
da facilidade de leitura da outra parte do código. Se quiser ser rápido, se quiser acabar logo, se
quiser que seu código seja de fácil escrita, torne-o de fácil leitura.
14 Capítulo 1: Código Limpo
A Regra de Escoteiro
Não basta escrever um código bom. Ele precisa ser mantido sempre limpo. Todos já vimos
códigos estragarem e degradarem com o tempo. Portanto, precisamos assumir um papel ativo na
prevenção da degradação.
A Boy Scouts of America (maior organização de jovens escoteiros dos EUA) tem uma regra
simples que podemos aplicar à nossa profissão.
Deixe a área do acampamento mais limpa do que como você a encontrou.s
Se todos deixássemos nosso código mais limpo do que quando o começamos, ele simplesmente
não degradaria. A limpeza não precisa ser algo grande. Troque o nome de uma variável por um
melhor, divida uma função que esteja um pouco grande demais, elimine um pouco de repetição
de código, reduza uma instrução if aninhada.
Consegue se imaginar trabalhando num projeto no qual o código simplesmente melhorou com
o tempo? Você acredita que qualquer alternativa seja profissional? Na verdade, o aperfeiçoamento
contínuo não é inerente ao profissionalismo?
Prequela e Princípios
Em muitas maneiras este livro é uma "prequela" de outro que escrevi em 2002, chamado Agile
Software Development: Principles. Patterns, and Practices (PPP). Ele fala sobre os princípios
do projeto orientado a objeto e muitas das práticas utilizadas por desenvolvedores profissionais.
Se você ainda não leu o PPP, talvez ache que é a continuação deste livro. Se já o leu, então
perceberá que ele é bastante parecido a esse em relação aos códigos.
Neste livro há referências esporádicas a diversos princípios de projeto, dentre os quais estão:
Princípio da Responsabilidade Unica (SRP, sigla em inglês), Princípio de Aberto-Fechado (OCP,
sigla em inglês), Princípio da Inversão da Independência (DIP, sigla em inglês), dentre outros.
Esses princípios são descritos detalhadamente no PPP.
Conclusão
Livros sobre arte não prometem lhe tornar um artista. Tudo o que podem fazer é lhe oferecer
algumas das ferramentas, técnicas e linhas de pensamento que outros artistas usaram. Portanto,
este livro não pode prometer lhe tornar um bom programador. Ou lhe dar a "sensibilidade ao
código". Tudo o que ele pode fazer é lhe mostrar a linha de pensamento de bons programadores
e os truques, técnicas e ferramentas que eles usam.
Assim como um livro sobre arte, este está cheio de detalhes. Há muitos códigos. Você verá
códigos bons e ruins; código ruim sendo transformado em bom; listas de heurísticas, orientações
e técnicas; e também exemplo após exemplo. Depois disso, é por sua conta.
Lembre-se daquela piada sobre o violinista que se perdeu no caminho para a apresentação em
xperimente e deixe este mundo um
Bibliografia 15
um concerto? Ele aborda um senhor na esquina e lhe pergunta como chegar ao Carnegie Hall. O
senhor observa o violinista com seu violino debaixo dos braços e diz "Pratique, filho. Pratique!".
Bibliografia
[Beck07]: Implementation Patterns, Kent Beck, Addison-Wesley, 2007.
[Knuth92]: Literate Programming, Donald E. Knuth, Center for the Study of Language and
Information, Leland Stanford Junior University, 1992.
BABY
MES
2
Nomes Significativos
por Tim Ottinger
Introdução
Há nomes por todos os lados em um software. Nomeamos nossas variáveis, funções, parâmetros,
classes e pacotes, assim como os arquivos-fonte e os diretórios que os possui. Nomeamos também
nossos arquivos jar e war e ear. E nomeamos, nomeamos e nomeamos. Como fazemos muito isso, é
melhor que o façamos bem. A seguir estão algumas regras simples para a criação de bons nomes.
18 Capítulo 2: Nomes Significativos
Use Nomes que Revelem seu Propósito
Dizer que os nomes devem demonstrar seu propósito é fácil. Mas queremos que você saiba que
estamos falando sério. Escolher bons nomes leva tempo, mas economiza mais. Portanto, cuide
de seus nomes e troque-os quando encontrar melhores. Todos que lerem seu código (incluindo
você mesmo) ficarão agradecidos.
O nome de uma variável, função ou classe deve responder a todas as grandes questões. Ele
deve lhe dizer porque existe, o que faz e como é usado. Se um nome requer um comentário, então
ele não revela seu propósito.
int d; // tempo decorrido em dias
O nome d não revela nada. Ele não indica a ideia de tempo decorrido, nem de dias. Devemos
escolher um nome que especifique seu uso para mensuração e a unidade usada.
int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays;
Escolher nomes que revelem seu propósito pode facilitar bastante o entendimento e a alteração
do código. Qual o propósito deste código?
public List<int[]> getThem() {
List<int[]> list1 = new ArrayList<int[]>();
for (int[] x : theList)
if (x[0] == 4)
listl.add(x);
return listl;
}
Por que é dificil dizer o que o código faz? Não há expressões complexas.
O espaçamento e a endentação são cabíveis. Só há três variáveis e duas constantes. Nem
mesmo há classes refinadas ou métodos polimórficos, apenas uma lista de vetores (pelo menos
é o que parece). O problema não é a simplicidade do código, mas seu aspecto implícito, isto é, o
contexto não está explícito no código. Devido a isso, é necessário que saibamos as repostas para
questões como:
1. Que tipos de coisas estão em theList?
2. Qual a importância de um item na posição zero na theList?
3. Qual a importância do valor 4?
4. Como eu usaria a lista retornada?
As respostas para tais questões não estão presentes no exemplo do código, mas poderiam.
Digamos que estejamos trabalhando num jogo do tipo "campo minado". Percebemos que o
tabuleiro é uma lista de células chamada theList. Vamos renomeá-la para gameBoard.
Evite Informações Erradas 19
Cada quadrado no tabuleiro é representada por um vetor simples. Mais tarde, descobrimos
que a posição zero é armazena um valor de status e que o valor 4 significa "marcado com uma
bandeirinha". Ao dar esses nomes explicativos, podemos melhorar consideravelmente o código:
public List<int[]> getFlaggedCells() {
List<int[]> flaggedCells = new ArrayList<int[]>();
for (int[] cell: gameBoard)
if (cel1[STATUS_VALUE] == FLAGGED)
flaggedCells.add(cell);
return flaggedCells;
Note que a simplicidade do código não mudou. Ele ainda possui o mesmo número de
operadores e constantes, com o mesmo número de itens aninhados. Entretanto, o código
ficou muito mais explícito.
Podemos continuar e criar uma classe simples para as células, em vez de usar um vetor intS.
Ela pode ter uma função com um nome revele seu propósito (chamada isFlagged, ou seja
"está marcada com uma bandeirinha") para ocultar os números mágicos.
O resultado é uma nova versão da função:
public List<Cell> getFlaggedCells() {
}
List<Cell> flaggedCells = new ArrayList<Cell>():
for (Cell cell: gameBoard)
if (cell.isFlagged())
flaggedCells.add(cell);
return flaggedCells;
Com essas simples alterações de nomes, não fica dificil entender o que está acontecendo. Esse é
o poder de escolher bons nomes.
Evite Informações Erradas
Os programadores devem evitar passar dicas falsas que confundam o sentido do código.
Devemos evitar palavras cujos significados podem se desviar daquele que desejamos. Por
exemplo, hp, aix e sco seriam nomes ruins de variáveis, pois são nomes de plataformas
Unix ou variantes. Mesmo se estiver programando uma hipotenusa e hp parecer uma boa
abreviação, o nome pode ser mal interpretado.
Não se refira a um grupo de contas como accountList, a menos que realmente seja uma
List. A palavra list (lista) significa algo específico para programadores. Se o que armazena as
contas não for uma List de verdade, poderá confundir os outros.¹ Portanto, accountGroup on
bunchofAccounts ou apenas accounts seria melhor.
Cuidado ao usar nomes muito parecidos. Fica dificil perceber a pequena diferença
entre XYZControllerForEfficientHandlingOfStrings em um móduloe
XYZControllerForEfficientStorageofStrings em outro. Ambas as palavras são
muito semelhantes.
20 Capítulo 2: Nomes Significativos
Usar conceitos similares para montar palavras é informação. Usar formatos inconsistentes
para palavras leva a uma má interpretação. Com os ambientes Java de hoje dispomos do recurso
de autocompletar palavras. Digitamos alguns caracteres de um nome e pressionamos uma
combinação de teclas (se houver uma) e, então, aparece uma lista de possíveis palavras que
se iniciam com tais letras. Isso é muito prático se houver nomes muito parecidos organizados
alfabeticamente num mesmo local e se as diferenças forem óbvias, pois é mais provável que o
desenvolvedor escolha um objeto pelo nome, sem consultar seus comentários ou mesmo a lista
de métodos fornecidos por aquela classe.
Um exemplo real de nomes que podem gerar confusão é o uso da letra "I" minúscula ou da
vogal "O" maiúscula como nome de variáveis. O problema é que eles se parecem com o um e o
zero, respectivamente.
int a = 1;
if (O == 1 )
a = 01;
else
1 = 01;
O leitor pode achar que inventamos esse exemplo, mas já vimos códigos nos quais isso
acontecia bastante. Uma vez, o autor do código sugeriu o uso de fontes distintas de modo a
realçar mais as diferenças, uma solução que teria de ser repassada de forma oral ou escrita a
todos os futuros desenvolvedores. Com uma simples troca de nome, o problema é resolvido com
objetividade e sem precisar criar novas tarefas.
Faça Distinções Significativas
Os programadores criam problemas para si próprios
quando criam um código voltado unicamente para
um compilador ou interpretador. Por exemplo, como
não é possível usar o mesmo nome para referir-se
a duas coisas diferentes num mesmo escopo, você
pode decidir alterar o nome de maneira arbitrária. As
vezes, isso é feito escrevendo um dos nomes errado,
produzindo a uma situação na qual a correção de erros
de ortografia impossibilita a compilação. Não basta
adicionar números ou palavras muito comuns, mesmo
que o compilador fique satisfeito. Se os nomes precisam ser diferentes, então também devem ter
significados distintos.
Usar números sequenciais em nomes (al, a2,...,aN) é o oposto da seleção de nomes
expressivos. Eles não geram confusão, simplesmente não oferecem informação alguma ou dica
sobre a intenção de seu criador. Considere o seguinte:
public static void copyChars (char al[], char a2[])
for (int i = 0; i < al.length; i++) {
a2[i] = al[i];
{
}
Use Nomes Pronunciáveis
Fica muito mais fácil ler essa função quando usam-se source e destination como nomes
de parâmetros. Palavras muito comuns são outra forma de distinção que nada expressam.
Imagine que você tenha uma classe Product. Se houver outra chamada ProductInfo ou
ProductData, você usou nomes distintos que não revelam nada de diferente. Info e Data são
palavras muito comuns e vagas, como "um", "uma" e "a".
Observe que não há problema em usar prefixos como "um" e "a", contanto que façam
uma distinção significativa. Por exemplo, você pode usar "um" para variáveis locais e "a"
para todos os parâmetros de funções. O problema surge quando você decide chamar uma
variável de aZork só porque já existe outra chamada zork.
Palavras muito comuns são redundantes. O nome de uma variável jamais deve conter a
palavra "variáveľ". O nome de uma tabela jamais deve conter a palavra tabela. Então como
NameString é melhor do que Name? Um Name pode ser um número do tipo ponto flutuante?
Caso possa, estaria violando uma regra sobre passar informações incorretas. Imagine que
você encontre uma classe Customer e outra CustomerObject. O que a diferença nos nomes
lhe diz? Qual seria a melhor para possuir o histórico de pagamento de um cliente?
Conhecemos um aplicativo que é assim.A fim de proteger seus desenvolvedores, trocamos
os nomes, mas abaixo está exatamente o tipo de erro:
getActiveAccount();
getActiveAccounts();
getActiveAccountInfo();
Como os programadores desse projeto poderiam saber qual das três funções chamar?
Na ausência de convenções específicas, não há como distinguir moneyAmount de money,
customerInfo de customer, accountData de account e theMessage de message. Faça a distinção
dos nomes de uma forma que o leitor compreenda as diferenças.
Use Nomes Pronunciáveis
Os ser humano é bom com as palavras. Uma parte considerável de seu cérebro é responsável
pelo conceito das palavras. E, por definição, as palavras são pronunciáveis. Seria uma lástima
não tirar proveito dessa importante parte de nosso cérebro que evoluiu para lidar com a língua
falada.Sendo assim, crie nomes pronunciáveis.
Se não puder pronunciá-lo, não terá como discutir sobre tal nome sem parecer um idiota.
"Bem, aqui no bê cê erre três cê ene tê, temos um pê esse zê quê int, viram?". Isso importa
porquea programação é uma atividade social.
Conheço uma empresa que possui uma variável genymdhms (generation date, year,
month, day, hour, minute e second) e seus funcionários saem falando "gê dábliu eme dê agá
eme esse". Tenho um hábito irritante de pronunciar tudo como está escrito, portanto comecei
a falar "gen-yah-muddahims".
Depois desenvolvedores e analistas estavam falando assim também, e ainda soava
estúpido. Mas estávamos fazendo uma brincadeira e, por isso, foi divertido. Engraçado ou
não, estamos tolerando nomeações de baixa qualidade. Novos desenvolvedores tiveram de
pedir que lhes explicassem as variáveis, e, então, em vez de usar termos existentes na língua,
inventavam palavras bobas ao pronunciá-las. Compare
21
22 Capítulo 2: Nomes Significativos
com
class DtaRcrd102
};
private Date genymdhms;
private Date modymdhms;
private final String pszqint = "102";
/* ... */
class Customer {
private Date generationTimestamp;
private Date modificationTimestamp;;
private final String recordId = "102";
/* ... *1
};
Agora é possível uma conversa inteligente: "Ei, Mikey, dê uma olhada este registro! A generation
timestamp ("criação de marcação de horário") está marcada para amanhã! Como pode?".
Use Nomes Passíveis de Busca
Nomes de uma só letra ou números possuem um problema em particular por não ser fácil localizálos ao longo de um texto. Pode-se usar facilmente o grep para MAX_CLASSES_PER_STUDENT,
mas buscar o número 7 poderia ser mais complicado. Nomes, definições de constantes e várias
outras expressões que possuam tal número, usado para outros propósitos podem ser resultados da
busca. Pior ainda quando uma constante é um número grande e alguém talvez tenha trocado os
dígitos, criando assim um bug e ao mesmo tempo não sendo captada pela busca efetuada.
Da mesma forma, o nome "e"é uma escolha ruim para qualquer variável a qual um programador
talvez precise fazer uma busca. É uma letra muito comum e provavelmente aparecerá em todo
texto em qualquer programa. Devido a isso, nomes longos se sobressaem aos curtos, e qualquer
nome passível de busca se sobressai a uma constante no código.
Particularmente, prefiro que nomes com uma única letra SÓ sejam usados como variáveis
locais dentro de métodos pequenos. O tamanho de um nome deve ser proporcional ao
tamanho do escopo.
[N5]. Se uma variável ou constante pode ser vista ou usada em vários lugares dentro do código,
é imperativo atribuí-la um nome fácil para busca. Novamente, compare
for (int j=0; j<34; j++) {
s += (t[j]*4)/5;
com
int realDaysPerIdealDay = 4;
const int WORK_DAYS PER_WEEK = 5;
int sum = 0;
for (int j=0; j < NUMBER_OF_TASKS; j++) {
int realTaskDays = taskEstimate[j] * realDaysPerIdealDay;
int realTaskWeeks = (realdays ! WORK_DAYS_PER_WEEK);
sum += realTaskWeeks;
}
Evite Codificações 23
Note que sum não é um nome prático, mas pelo menos é fácil de procurar. O nome usado no
código serve para uma função maior, mas pense como seria muito mais fácil encontrar WORK
DAYS_PER_WEEK do que buscar em todos os lugares nos quais o 5 aparece e, então, filtrar os
resultados para exibir apenas as instâncias que você deseja.
Evite Codificações
Já temos de lidar com bastante codificação e não precisamos acrescentar mais. Codificar
informações do escopo ou tipos em nomes simplesmente adiciona uma tarefa extra de decifração.
Dificilmente parece lógico contratar um novo funcionário para aprender outra "linguagem"
codificadora além da atual usada no código no qual se está trabalhando. É uma sobrecarga mental
desnecessária ao tentar resolver um problema. Nomes codificados raramente são pronunciáveis,
além de ser fácil escrevê-los incorretamente.
A Notação Húngara
Antigamente, quando trabalhávamos com linguagens com limite de tamanho para os nomes,
violávamos essa regra quando necessário, com certo arrependimento. O Fortran forçava codificações
ao tornar a primeira letra uma indicação para o tipo. Versões anteriores do BASIC só permitiam
uma letra mais um dígito. A Notação Húngara (NH) inovou essas limitações. Na época da API em
C do Windows, a NH era considerada muito importante, quando tudo era um inteiro ou um ponteiro
para um inteiro long de 32 bits ou um ponteiro do tipo void, ou uma das diversas implementações
de "strings" (com finalidades e atributos diferentes). O compilador não verificava os tipos naquele
tempo, então os programadores precisavam de ajuda para lembrar dos tipos.
Em linguagens modernas, temos tipos muito melhores, e os compiladores os reconhecem e os
tornam obrigatórios. Ademais, há uma certa tendência para a criação de classes e funções menores
de modo que as pessoas possam ver onde cada variável que estão usando foi declarada.
Os programadores Java não precisam definir o tipo. Os objetos já são o próprio tipo, e a edição
de ambientes se tornou tão avançada que detectam quando se usa inadequadamente um tipo antes
mesmo da compilação! Portanto, hoje em dia, a NH e outras formas de convenção de tipos são
basicamente obstáculos. Eles dificultam a alteração do nome ou do tipo de uma variável, função
ou classe; dificultam a leitura do código; e criam a possibilidade de que o sistema de codificação
induza o leitor ao erro.
PhoneNumber phoneString:
// o nome nao muda na alteracao do tipo!
Prefixos de Variáveis Membro
Você não precisa mais colocar o prefixo m_em variáveis membro. Mas para isso, suas classes e
funções devem ser pequenas. E você deve usar um ambiente de edição que realce ou colore as
variáveis membro de modo a distingui-las.
public class Part {
private String m_dsc; // Descrição textual
void setName(String name) {
24
m_dsc = name;
Capítulo 2: Nomes Significativos
public class Part {
String description;
void setDescription(String description)
this.description = description;
{
}
}
a
Além disso, as pessoas rapidamente aprendem a ignorar o prefixo (ou sufixo) para visualizar
parte significativa do nome. Quanto mais lemos o código, menos prefixos enxergamos. No
final, estes se tornam partes invisíveis e um indicativo de código velho.
Interfaces e Implementações
Às vezes, há casos especiais para codificações. Por exemplo, digamos que você esteja construindo
uma ABSTRACT FACTORY para criar formas. Essa factory será uma interface, e implementada
por umama classe concreta. Como devemos nomeá-la? IShapeFactory e ShapeFactory? Prefiro
não enfeitar as interfaces. O"T" no início, tão comum no hoje em dia, é na melhor das hipóteses
uma distração, e na pior são informações excessivas. Não quero que meus usuários saibam
que estou lhes dando uma interface, e, sim, apenas uma ShapeFactory. Portanto, se eu devo
codificar seja a interface ou a implementação, escolho esta. Para codificar a interface, é preferível
chamá-la de ShapeFactoryImp, ou mesmo de CShapeFactory.
Evite o Mapeamento Mental
Os leitores não devem ter de traduzir mentalmente os nomes que você escolheu por outros que
eles conheçam. Essa questão costuma levar a decisão de não usar os termos do domínio do
problema e nem os da solução. Este é um problema com nomes de variáveis de uma só letra.
Certamente um contador de iterações pode ser chamado de "i", "j" ou "k" (mas nunca 1)-isso
já se tornou uma tradição - se seu escopo for muito pequeno e não houver outros nomes que
possam entrar em conflito com ele.
Entretanto, na maioria dos contextos, um nome de uma só letra é uma escolha ruim; é apenas
um armazenador que o leitor deverá mentalmente mapear de acordo com o conceito em uso. Não
há razão pior do que usar o nome "e" só porque "a" e "b" já estão sendo usados.
De maneira geral, os programadores são pessoas muito espertas. E esse tipo de pessoas gosta
de se exibir mostrando suas habilidades mentais. Apesar de tudo, se você puder confiantemente
se lembrar de que o "r" minúsculo é uma versão da url sem o host e o contexto, então obviamente
você é muito esperto.
Uma diferença entre um programador esperto e um programador profissional é que este
entende que clareza é fundamental. Os profissionais usam seus poderes para o bem, e escrevem
códigos que outros possam entender.
Nomes de Métodos 25
Nomes de Classes
Classes e objetos devem ter nomes com substantivo(s), como Cliente, PaginaWiki, Conta e
AnaliseEndereco. Evite palavras como Gerente, Processador, Dados ou Info no nome de uma
classe, que também não deve ser um verbo.
Nomes de Métodos
Os nomes de métodos devem ter verbos, como postarPagamento, excluirPagina ou salvar.
Devem-se nomear métodos de acesso, alteração e autenticação segundo seus valores e adicionar
os prefixos get, set ou is de acordo com o padrão javabean.
string name = employee.getName();
customer.setName("mike");
if (paycheck.isPosted())...
Quando os construtores estiverem sobrecarregados, use métodos factory estáticos com nomes
que descrevam os parâmetros. Por exemplo,
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
é melhor do que
Complex fulcrumPoint = new Complex(23.0);
Para forçar seu uso, torne os construtores correspondentes como privados.
Não dê uma de Espertinho
Se os nomes forem muito "espertinhos",
apenas as pessoas que compartilhem do mesmo
senso de humor que seu dono irão lembrá-los,
e só enquanto se lembrarem da brincadeira.
Eles saberão o que deve fazer a função
HolyHandGrenade? Claro, é engraçado, mas
talvez nesse caso Deleteltems fique melhor.
Opte por clareza no lugar de divertimento.
Essas gracinhas em códigos costumam aparecer na forma de coloquialismos e gírias. Por
exemplo, não use firmar () para significar terminar(). Não use piadas de baixo calão,
como cairFora para significar abortar(). Diga o que você quer expressar. Expresse o
que você quer dizer.
26
Selecione uma Palavra por Conceito
Capítulo 2: Nomes Significativos
Escolha uma palavra por cada conceito abstrato e fique com ela. Por exemplo, é confuso ter
pegar, recuperar e obter como métodos equivalentes de classes diferentes. Como lembrar a
qual método pertence cada classe? Infelizmente, você geralmente precisa se lembrar qual empresa,
grupo ou pessoa criou a biblioteca ou a classe de modo a recordar qual termo foi usado. Caso
contrário, você perde muito tempo vasculhando pelos cabeçalhos e exemplos de códigos antigos.
Os ambientes modernos de edição, como o Eclipse e o IntelliJ, oferecem dicas relacionadas
ao contexto, como a lista de métodos que você pode chamar em um determinado objeto. Mas
note que a lista geralmente não lhe oferece os comentários que você escreveu em torno dos
nomes de suas funções. Você tem sorte se receber o parâmetro nomes (names) das declarações
das funções. Os nomes das funções têm de ficar sozinhos, e devem ser consistentes de modo que
você possa selecionar o método correto sem qualquer busca extra.
Da mesma forma, é confuso ter um controlador, um gerenciador e um driver no
mesmo código-fonte. Qual a principal diferença entre um GerenciadorDeDispositivo e um
controlador-de-protocolo? Por que ambos não sãocontroladores ougerenciadores?
Ambos são realmente drivers? O nome faz com que você espere dois objetos com tipos bem
distintos, assim como ter classes diferentes.
Um léxico consistente é uma grande vantagem aos programadores que precisem usar
seu código.
Não Faça Trocadilhos
Evite usar a mesma palavra para dois propósitos. Usar o mesmo termo para duas ideias diferentes
é basicamente um trocadilho.
Se você seguir a regra "uma palavra por conceito", você pode acabar ficando com muitas
classes que possuam, por exemplo, um método add. Contanto que as listas de parâmetros e os
valores retornados dos diversos métodos add sejam semanticamente equivalentes, tudo bem.
Entretanto, uma pessoa pode decidir usar a palavra add por fins de "consistência" quando
ela na verdade não aplica o mesmo sentido a todas. Digamos que tenhamos muitas classes nas
quais add criará um novo valor por meio da adição e concatenação de dois valores existentes.
Agora, digamos que estejamos criando uma nova classe que possua um método que coloque
seu único parâmetro em uma coleção. Deveríamos chamar este método de add? Por termos
tantos outros métodos add, isso pode parecer consistente. Mas, neste caso, a semântica é
diferente. Portanto, deveríamos usar um nome como inserir ou adicionar. Chamar este novo
método de add seria um trocadilho.
Nosso objetivo, como autores, é tornar a leitura de nosso código o mais fácil possível.
Desejamos que nosso código seja de rápida leitura, e não um estudo demorado. Queremos usar a
linguagem de um livro popular no qual é responsabilidade do autor ser claro, e não uma linguagem
acadêmica na qual a tarefa do estudioso é entender minuciosamente o que está escrito.
Use nomes a partir do Domínio da Solução
Lembre-se de que serão programadores que lerão seu código. Portanto, pode usar termos de
Informática, nomes de algoritmos, nomes de padrões, termos matemáticos etc. Não é prudente
Adicione um Contexto Significativo 27
pensar num nome a partir do domínio do problema, pois não queremos que nossos companheiros
de trabalho tenham de consultar o cliente toda hora para saber o significado de um nome o qual
eles já conhecem o conceito, só que por outro nome.
O nome AccountVisitor ("conta do visitante") significa o bastante para um programador
familiarizado com o padrão VISITOR. Qual programador não saberia o que é uma JobQueue
("fila de tarefas")? Há muitas coisas técnicas que os programadores devem fazer. Selecionar
nomes técnicos para tais coisas é, geralmente, o método mais adequado.
Use nomes de Domínios do Problema
Quando não houver uma solução "à la programador", use o nome do domínio do problema. Pelo
menos o programador que fizer a manutenção do seu código poderá perguntar aum especialista
em tal domínio o que o nome significa.
Distinguir os conceitos do domínio do problema dos do domínio da solução é parte da tarefa
de um bom programador e designer. O código que tem mais a ver com os conceitos do domínio
do problema tem nomes derivados de tal domínio.
Adicione um Contexto Significativo
Há poucos nomes que são significativos por si só a maioria não é. Por conta disso, você precisa
usar nomes que façam parte do contexto para o leitor. Para isso você os coloca em classes,
funções e namespaces bem nomeados. Se nada disso funcionar, então talvez como último recurso
seja necessário adicionar prefixos ao nome.
Imagine que você tenha variáveis chamadas firstName, lastName, street, houseNumber,
city, state e zipcode. Vistas juntas, fica bem claro que elas formam um endereço. Mas e se
você só visse a variável state sozinha num método? Automaticamente você assumiria ser parte
de um endereço?
Podem-se usar prefixos para adicionar um contexto: addrFirstName, addrLastName,
addrState etc. Pelo menos os leitores entenderão que essas variáveis são parte de uma estrutura
maior. E claro que uma melhor solução seria criar uma classe chamada Address. Então, até o
compilador sabe que as variáveis pertencem a um escopo maior.
Veja o método na Listagem 2.1. As variáveis precisam de um contexto mais significativo? O
nome da função oferece apenas parte do contexto; o algoritmo apresenta o resto.
Após ter lido a função, você vê que três variáveis, number, verb e pluralModifier, fazem
parte da mensagem de dedução (guess statistics message). Infelizmente, o contexto deve ser
inferido. Ao olhar pela primeira vez o método, o significado das variáveis não está claro.
28 Capítulo 2: Nomes Significativos
Listagem 2-1
Variáveis com contexto obscuro
private void printGuessStatistics(char candidate, int count)
String number;
}
String verb;
String pluralModifer;
if (count == 0) {
number = "no":
verb = "Existem";
pluralModifier = "s";
} else if (count == 1) {
number = "1"
verb = "Existe";
}
t
pluralModifier =;
else {
number = Integer.toString(count);
verb = "Existem";
pluralModifer = "s";
String guessMessage = String.format(
"There %s %s %ss", verb, number, candidate, pluralModifier
):
print (guessMessage);
A função é um pouco extensa demais também e as variáveis são bastante usadas. A fim de
dividir a função em partes menores, precisamos criar uma classe GuessStatisticsMessage
e tornar as três variáveis como campos desta classe. Isso oferecerá um contexto mais claro
para as três variáveis. Elas são definitivamente parte da GuessStatisticsMessage. A melhora do
contexto também permite ao algoritmo ficar muito mais claro ao dividi-lo em funções menores
(veja a Listagem 2.2).
Listagem 2-2
Variáveis possuem contexto
public class GuessStatisticsMessage
private String number:
private String verb;
private String pluralModifier;
{
public String make (char candidate, int count) {
createPluralDependentMessageParts (count);
}
return String.format(
"There %s %s ss",
verb, number, candidate, pluralModifier ):
private void createPluralDependentMessageParts (int count) {
if (count == 0( {
thereAreNoLetters();
} else if (count == 1) {
thereIsOneLetter();
} else {
Não Adicione Contextos Desnecessários
Listagem 2-2 (continuação)
Variáveis possuem contexto
thereAreManyLetters (count);
}
private void thereAreManyLetters(int count)
number = Integer.toString (count);
verb = "Existem";
pluralModifier = "S";
private void thereIsOneLetter()}
number = "1":
verb = "Existe";
pluralModifier =
private void thereAreNoLetters()
number = "no":
verb = "Existem";
pluralModifier = "s";
{
}
29
Não Adicione Contextos Desnecessários
Em um aplicativo fictício chamado "Gas Station Deluxe" (GSD), seria uma péssima ideia
adicionar prefixos a toda classe com GSD. Para ser sincero, você estará trabalhando contra suas
ferramentas. Você digita G e pressiona a tecla de autocompletar e recebe uma lista quilométrica de*
cada classe no sistema. Isso é inteligente? Para que dificultar a ajuda da IDE?
Da mesma forma, digamos que você inventou uma classe MailingAddress no módulo
de contabilidade do GSD e que o chamou de GSDACcountAddress.Mais tarde, você precisa
armazenar um endereço postal de seu cliente no aplicativo. Você usaria GSDAccountAddress?
Parece que o nome é adequado? Dez dos 17 caracteres são redundantes ou irrelevantes.
Nomes curtos geralmente são melhores contanto que sejam claros. Não adicione mais
contexto a um nome do que o necessário.
Os nomes accountAddress e customerAddress estão bons para instâncias da classe
Address, mas seriam ruins para nomes de classes. Address está bom para uma classe. Se precisar
diferenciar entre endereços MAC, endereços de portas e endereços da Web, uma ideia seria
PostalAddress, MAC e URI. Os nomes resultantes são mais precisos, motivo esse da tarefa de
se atribuir nomes.
Conclusão
O mais dificil sobre escolher bons nomes é a necessidade de se possuir boas habilidades de descrição
e um histórico cultural compartilhado. Essa é uma questão de aprender, e não técnica, gerencial ou
empresarial. Como consequência, muitas pessoas nessa área não aprendem essa tarefa muito bem.
30 Capítulo 2: Nomes Significativos
Elas também têm receio de renomear as coisas por temer que outros desenvolvedores sejam
contra. Não compartilhamos desse medo e achamos que ficamos realmente agradecidos quando
os nomes mudam (para melhor). Na maioria das vezes, não memorizamos os nomes de classes
métodos. Mas usamos ferramentas modernas para lidar com detalhes de modo que possamos
nos focalizar e ver se o código é lido como parágrafos, frases, ou pelo menos como tabelas
estruturas de dados (uma frase nem sempre é a melhor forma de se exibir dados). Provavelmente
você acabará surpreendendo alguém quando renomear algo, assim como qualquer outra melhoria
e
no código. Não deixe que isso atrapalhe seu progresso.
e
Siga alguma dessas regras e note se você não melhorou a legibilidade de seu código. Se estiver
fazendo a manutenção do código de outra pessoa, use ferramentas de refatoração para ajudar a
resolver essas questões. Em pouco tempo valerá a pena, ee continuará a vale em longo prazo.
olicVoid callAlicel
3
Funções
Nos primórdios da programação, formávamos nossos sistemas com rotinas e sub-rotinas.
Já na era do Fortran e do PL/1, usávamos programas, subprogramas e funções. De tudo
isso, apenas função prevaleceu. As funções são a primeira linha de organização em qualquer
programa. Escrevê-las bem é o assunto deste capítulo.
32 Capítulo 3: Funções
Veja o código na Listagem 3.1. É dificil encontrar uma função grande em FitNesse', mas
procurando um pouco mais encontramos uma. Além de ser longo, seu código é repetido, há
diversas strings estranhas e muitos tipos de dados e APIs esquisitos e nada óbvios. Veja o quanto
você consegue compreender nos próximos três minutos.
Listagem 3-1
HtmlUtil.java (FitNesse 20070619)
public static String testableHtml(
PageData pageData,
boolean includeSuiteSetup
throws Exception {
WikiPage wikiPage = pageData.getWikiPage ();
}
StringBuffe buffer = new StringBuffer();
if (pageData.hasAttribute("Test")){
if (includeSuiteSetup) {
}
WikiPage suiteSetup =
if
}
PageCrawlerImpl.getInheritedPage(
SuiteResponder.SUITE_SETUP_NAME, wikiPage
(suiteSetup != null)
WikiPagePath pagePath =
suiteSetup.getPageCrawler().getFullPathisuiteSetup);
String pagePathName = PathParser.render (pagePath);
buffer.append("!include -setup.")
.append (pagePathName)
.append("\n"):
WikiPage setup =
PageCrawlerImpl.getInheritedPage ("SetUp", wikiPage);
if (setup != null){
WikiPagePath setupPath =
wikiPage.get PageCrawler().getFullPath(setup);
String setupPathName = PathParser.render (setupPath); buffer.append("!include -setup
.append(setupPathName)
.append("\n");
.")
buffer.append (pageData.getContent());
if (pageData.hasAttribute("Test")}
WikiPage teardown =
PageCrawlerImpl.getInheritedPage ("TearDown", wikiPage};
if (teardown != null) {
WikiPagePath tearDownPath =
wikıPage.getPageCrawler().getFullPath(teardown);
String tearDownPathName = PathParser.render(tearDownPath);
buffer.append("\n")
.append("!include -teardown.")
.append(tearDownPathName)
.append("\n");
1. [I. Ferramenta de teste de código aberto, www.fitnese.org.1.
Funções
Listagem 3-1 (continuação)
HtmlUtil.java (FitNesse 20070619)
if (includeSuiteSetup) {
WikiPage suiteTeardown =
PageCrawlerImpl.getInheritedPage( SuiteResponder. SUITE_TEARDOWN_NAME,
wikiPage
}
:
if (suiteTeardown != null) {
WikiPagePath pagePath =
suiteTeardown.getPageCrawler().getFullPath (suiteTeardown);
String pagePathName = PathParser.render (pagePath);
buffer.append("!include -teardown.")
.append (pagePathName)
.append("\n");
pageData.setContent (buffer.toString{));
return pageData.getHtml{):
33
Conseguiu entender a função depois desses três minutos estudando-a? Provavelmente não.
Há muita coisa acontecendo lá em muitos níveis diferentes de. Há strings estranhas e chamadas
a funções esquisitas misturadas com dois if aninhados controlados por flags.
Entretanto, com umas poucas extrações simples de métodos, algumas renomeações e um
pouco de reestruturação,fui capaz de entender o propósito da função nas nove linhas da Listagem
3.2. Veja se você consegue compreender também em três minutos.
Listagem 3-2
HtmlUtil.java (refatorado)
public static String renderPageWithSetupsAndTeardowns(
ز
PageData pageData, boolean isSuite
throws Exception {
boolean isTestPage = pageData.hasAttribute("Test");
if (isTest Page) {
WikiPage testPage = pageData.getWikiPage();
StringBuffer newPageContent = new StringBuffer();
includeSetupPages (testPage, newPageContent, isSuite);
newPageContent.append (pageData.getContent());
includeTeardownPages (testPage, newPageContent, isSuite):
pageData.setContent (newPageContent.toString{));
return pageData.getHtml():
34 Capítulo 3: Funções
A menos que já estivesse estudando o FitNesse, provavelmente você não entendeu todos
os detalhes.
Se
Ainda assim você talvez tenha compreendido que essa função efetua a inclusão de algumas
páginas SetUp e TearDown em uma página de teste e, então, exibir tal página em HTML.
estiver familiarizado com o JUnit, você já deve ter percebido que essa função pertença a algum
tipo de framework de teste voltado para a Web. E você está certo. Deduzir tal informação da
Listagem 3.2 é muito fácil, mas ela está bastante obscura na Listagem 3.1.
Então, o que torna uma função como a da Listagem 3.2 fácil de ler e entender? Como fazer
uma função transmitir seu propósito? Quais atributos dar às nossas funções que permitirão um
leitor comum deduzir o tipo do programa ali contido?
Pequenas!
A primeira regra para funções é que elas devem ser pequenas. A segunda é que precisam ser
mais espertas do que isso. Não tenho como justificar essa afirmação. Não tenho referências de
pesquisas que mostrem que funções muito pequenas são melhores. Só posso dizer que por cerca
de quatro décadas tenho criado funções de tamanhos variados. Já escrevi diversos monstros de
3.000 linhas; bastantes funções de 100 a 300 linhas; e funções que tinham apenas de 20 a 30
linhas. Essa experiência me ensinou que, ao longo de muitas tentativas e erros, as funções devem
ser muito pequenas.
Na década de 1980, costumávamos dizer que uma função não deveria ser maior do que a tela.
É claro que na época usávamos as telas VT100, de 24 linhas por 80 colunas, e nossos editores
usavam 4 linhas para fins gerenciamento. Hoje em dia, com fontes reduzidas e um belo e grande
monitor, você consegue colocar 150 caracteres em uma linha - não se deve ultrapassar esse
limite e umas 100 linhas ou mais por tela as funções não devem chegar a isso tudo, elas
devem ter no máximo 20 linhas.
O quão pequena deve ser uma função? Em 1999, fui visitar Kent Beck em sua casa, em
Oregon. EUA. Sentamo-nos e programamos um pouco juntos. Em certo ponto, ele me mostrou
um simpático programa de nome Java/Swing o qual ele chamava de Sparkle. Ele produzia na
tela um efeito visual similar a uma varinha mágica da fada madrinha do filme da Cinderela.
Ao mover o mouse, faíscas (sparkles, em inglês) caíam do ponteiro do mouse com um belo
cintilar até o fim da janela, como se houvesse gravidade na tela. Quando Kent me mostrou o
código, fiquei surpreso com tamanha pequeneza das funções. Eu estava acostumado a funções
que seguiam por quilômetros em programas do Swing. Cada função neste programa tinha apenas
duas, ou três, ou quatro linhas. Esse deve ser o tamanho das suas funções.
O quão pequenas devem ser suas funções? Geralmente menores do que a da Listagem 3.2!
Na verdade, a Listagem 3.2 deveria ser enxuta para a Listagem 3.3.
A
2. Ferramenta de codigo aberto de teste de unidade para Java, www.junit.org.
Faça Apenas uma Coisa
Listagem 3-3
HtmlUtil.java (refatorado novamente)
public static String renderPageWithSetupsAndTeardowns(
PageData pageData, boolean isSuite) throws Exception {
if (isTest Page (pageData))
includeSetupAndTeardownFages (pageData, isSuite);
return pageData.getHtml();
35
Blocos e Endentação
Aqui quero dizer que blocos dentro de instruções if, else, while e outros devem ter apenas
uma linha. Possivelmente uma chamada de função. Além de manter a função pequena, isso
adiciona um valor significativo, pois a função chamada de dentro do bloco pode receber um
nome descritivo. Isso também implica que as funções não devem ser grandes e ter estruturas
aninhadas. Portanto, o nível de endentação de uma função deve ser de, no máximo, um ou dois.
Isso, é claro, facilita a leitura e compreensão das funções.
Faça Apenas uma Coisa
Deve ter ficado claro que a Listagem 3.1 faz muito mais
de uma coisa. Ela cria buffers, pega páginas, busca por
páginas herdadas, exibe caminhos, anexa strings estranhas
e gera HTML, dentre outras coisas. A Listagem 3.1 vive
ocupada fazendo diversas coisas diferentes. Por outro
lado, a Listagem 3.3 faz apenas uma coisa simples. Ela
inclui SetUp e TearDown em páginas de teste.
O conselho a seguir tem aparecido de uma forma ou
de outra por 30 anos ou mais.
AS FUNÇÕES DEVEM FAZER UMA COISA. DEVEM FAZÊ-LA BEМ.
DEVEM FAZER APENAS ELA.
O problema dessa declaração é que é dificil saber o que é "uma coisa". A Listagem 3.3 faz
uma coisa? É fácil dizer que ela faz três:
1. Determina se a página é de teste.
2. Se for, inclui SetUps e TearDowns.
3. Exibe a página em HTML.
Então, uma ou três coisas? Note que os três passos da função estão em um nível de abaixo do
nome da função. Podemos descrever a função com um breve parágrafo TO+:
4. A linguagem LOGO usava a palavra "TO" ("PARA") da mesma forma que Ruby e Python usam "def. Portanto, toda função começa com a palavra "TO",
36 Capítulo 3: Funções
TO RenderPage WithSetupsAndTeardowns, verificamos se a página é de teste, se for.
incluimos SetUps e TearDowns. Em ambos os casos, exibimos a página em HTML.
Se uma função faz apenas aqueles passos em um nível abaixo do nome da função, então ela
está fazendo uma só coisa. Apesar de tudo, o motivo de criarmos função é para decompor um
conceito maior (em outras palavras, o nome da função) em uma série de passos no próximo nível
de abstração.
a
Deve estar claro que a Listagem 3.1 contém passos em muitos níveis diferentes de. Portanto,
obviamente ela faz mais de uma coisa. Mesmo a Listagem 3.2 possui dois níveis de abstração
como comprovado pela nossa capacidade de redução. Mas ficaria muito difícil reduzir
Listagem 3.3 de modo significativo. Poderíamos colocar a instrução if numa função chamada
includeSetupsAndTeardownsIfTestPage, mas isso simplesmente reformula o código, sem
modificar o nível de.
Portanto, outra forma de saber se uma função faz mais de "uma coisa" é se você pode
extrair outra função dela a partir de seu nome que não seja apenas uma reformulação de sua
implementação (G34).
Seções Dentro de Funções
Veja a Listagem 4.7 na página 71. Note que a função generatePrimes está dividida em
seções, como declarações, inicializações e seleção. Esse é um indício óbvio de estar fazendo
mais de uma coisa. Não dá para, de forma significativa, dividir em seções as funções que
fazem apenas uma coisa.
Um Nível de Abstração por Função
A fim de confirmar se nossas funções fazem só "uma coisa". Precisamos verificar se todas as
instruções dentro da função estão no mesmo nível de abstração. É fácil ver como a Listagem 3.1
viola essa regra. Há outros conceitos lá que estão em um nível de bem alto, como 0 getHtml();
outros que estão em um nível intermediário, como String pagePathName = PathParser.
render (pagePath); e outros que estão em um nível consideravelmente baixo, como
.append("\n").
Vários níveis de dentro de uma função sempre geram confusão. Os leitores podem não
conseguir dizer se uma expressão determinada é um conceito essencial ou um mero detalhe. Pior,
como janelas quebradas, uma vez misturados os detalhes aos conceitos, mais e mais detalhes
tendem a se agregar dentro da função.
Estrutura Switch
Ler o Código de Cima para Baixo: Regra Decrescente
Queremos que o código seja lido de cima para baixo, como uma narrativa. Desejamos que
cada função seja seguida pelas outras no próximo nível de de modo que possamos ler o
programa descendo um nível de de cada vez conforme percorremos a lista de funções.
Chamamos isso de Regra Decrescente.
Em outras palavras, queremos poder ler o programa como se fosse uma série de
parágrafos TO, cada um descrevendo o nível atual de e fazendo referência aos parágrafos
TO consecutivos no próximo nível abaixo.
Para incluir SetUps e TearDowns, incluimos os primeiros, depois o conteúdo
da página de teste e, então, adicionamos os segundos. Para incluir SetUps,
adicionamos o suite setup, se este for uma coleção, incluimos o setup normal.
Para incluir o suite setup, buscamos na hierarquia acima a página "SuiteSetUp"
e adicionamos uma instrução de inclusão com o caminho àquela página. Para
procurar na hierarquia acima...
Acaba sendo muito difícil para os programadores aprenderema seguir essa regra e criar
funções que fiquem em apenas um nível de. Mas aprender esse truque é também muito
importante, pois ele é o segredo para manter as funções curtas e garantir que façam apenas
"uma coisa". Fazer com que a leitura do código possa ser feita de cima para baixo como uma
série de parágrafos TO é uma técnica eficiente para manter o nível de consistente.
Veja a listagem 3.7 no final deste capítulo. Ela mostra toda a função testableHtml refatorada
de acordo com os princípios descrito aqui. Note como cada função indica a seguinte e como
cada uma mantém um nível consistente de.
Estrutura Switch
É difícil criar uma estrutura switch pequena, pois mesmo uma com apenas dois cases é maior
do que eu gostaria que fosse um bloco ou uma função. Também é dificil construir uma que fala
apenas uma coisa. Por padrão, as estruturas swi tch sempre fazem N coisas. Infelizmente, nem
sempre conseguimos evitar o uso do switch, mas podemos nos certificar se cada um está em
uma classe de baixo nível e nunca é repetido. Para isso, usamos o polimorfismo.
Veja a Listagem 3.4. Ela mostra apenas uma das operações que podem depender do tipo
de funcionário (employee, em inglês).
37
38
Listagem 3-4
Payroll.java
public Money calculatePay (Employee e)
throws InvalidEmployeeType{
switch (e.type)
}
case COMMISSIONED:
return calculateCommissionedPayie);
case HOURLY:
return calculateHourlyPay (e);
case SALARIED:
return calculateSalariedPay (e);
default:
throw new InvalidEmployeeType(e.type):
Capítulo 3: Funções
Esta função tem vários problemas. Primeiro, ela é grande, e quando se adiciona novos tipos de
funcionários ela crescerá mais ainda. Segundo, obviamente ela faz mais de uma coisa. Terceiro,
ela viola o Principio da Responsabilidade Única (SRP, sigla em inglês) por haver mais de um
motivo para alterá-la. Quarto, ela viola o Princípio de Aberto-Fechado* (OCP, sigla em inglês),
pois precisa ser modificada sempre que novos tipos forem adicionados. Mas, provavelmente, o
pior problema com essa função é a quantidade ilimitada de outras funções que terão a mesma
estrutura. Por exemplo, poderíamos ter
ou
isPayday (Employee e, Date date)
deliverPay(Employee e, Money pay)
ou um outro grupo. Todas teriama mesma estrutura deletéria.
A solução (veja a Listagem 3.5) é inserir a estrutura switch no fundo de uma ABSTRACT
FACTORY e jamais deixar que alguém a veja. A factory usará o switch para criar instâncias
apropriadas derivadas de Employee, e as funções, como calculatePay, isPayday
deliverPay, serão enviadas de forma polifórmica através da interface Employee.
e
Minha regra geral para estruturas switch é que são aceitáveis se aparecerem apenas uma vez,
como para a criação de objetos polifórmicos, e estiverem escondidas atrás de uma relação de
herança de modo que o resto do sistema não possa enxergá-la [G23]. É claro que cada caso é um
caso e haverá vezes que não respeitarei uma ou mais partes dessa regra.
Listagem 3-5
Employee e Factory
public abstract class Employee {
public abstract boolean isPayday();
public abstract Money calculatePay();
public abstract void deliverPay(Money pay);
7. a. http://en.wikipedia.org/wiki/Single responsibility principle
Use Nomes Descritivos 39
Use Nomes Descritivos
Na Listagem 3.7, eu mudei o nome do exemplo de nossa função testableHtml para
SetupTeardownIncluder.render, que é bem melhor, pois descreve o que a função faz.
Também dei a cada método privado nomes igualmente descritivos, como isTestable ou
includeSetupAndTeardownPages. É dificil superestimar o valor de bons nomes. Lembre-se
do princípio de Ward: "Você sabe que está criando um código limpo quando cada rotina que
você lê é como você esperava". Metade do esforço para satisfazer esse princípio é escolher bons
nomes para funções pequenas que fazem apenas uma coisa. Quando menor e mais centralizada
for a função, mais fácil será pensar em um nome descritivo.
Não tenha medo de criar nomes extensos, pois eles são melhores do que um pequeno e
enigmático. Um nome longo e descritivo é melhor do que um comentário extenso e descritivo.
Use uma convenção de nomenclatura que possibilite uma fácil leitura de nomes de funções com
várias palavras e, então, use estas para dar à função um nome que explique o que ela faz.
Não se preocupe com o tempo ao escolher um nome. Na verdade, você deve tentar vários
nomes e, então, ler o código com cada um deles. IDEs modernas, como Eclipse ou IntelliJ,
facilita a troca de nomes. Utilize uma dessas IDEs e experimente diversos nomes até encontrar
um que seja bem descritivo.
Selecionar nomes descritivos esclarecerá o modelo do módulo em sua mente e lhe ajudará a
melhorá-lo. É comum que ao buscar nomes adequados resulte numa boa reestruturação do código.
Seja consistente nos nomes. Use as mesmas frases, substantivos e verbos nos nomes de funções
de seu módulo. Considere, por exemplo, os nomes includeSetup-AndTeardownPages,
includeSetupPages, includeSuiteSetupPage e includeSetupPage. A fraseologia
nesses nomes permite uma sequência de fácil dedução. Na verdade, se eu lhe mostrasse
apenas a série acima, você se perguntaria: "O que aconteceu com includeTeardownPages,
includeSuiteTeardownPage e includeTeardownPage?", como isso é "... como o que
você esperava?".
Parâmetros de Funções
A quantidade ideal de parâmetros para uma função
é zero (nulo). Depois vem um (mônade), seguido de
dois (díade). Sempre que possível devem-se evitar
três parâmetros (tríade). Para mais de três deve-se ter
um motivo muito especial (políade) - mesmo assim
não devem ser usados.
Parâmetros são complicados. Eles requerem
bastante conceito. É por isso que me livrei de
quase todos no exemplo. Considere, por exemplo,
o StringBuffer. Poderíamos tê-lo passado
como parâmetro em vez de instanciá-lo como
uma variável, mas então nossos leitores teriam
de interpretá-lo sempre que o vissem. Ao ler a
40 Capítulo 3: Funções
estória contada por pelo módulo, fica mais fácil entender ineludeSetupPage() do que
includeSetupPageInto (newPage-Content). O parâmetro não está no nível de que o
nome função, forçando-lhe reconhecer de um detalhe (ou seja, o StringBuffer) que não seja
importante particularmente naquele momento.
Os parâmetros são mais difíceis ainda a partir de um ponto de vista de testes. Imagine a
dificuldade de escrever todos os casos de teste para se certificar de que todas as várias combinações
de parâmetros funcionem adequadamente. Se não houver parâmetros, essa tarefa é simples. Se
houver um, não é tão difícil assim.
Com dois, a situação fica um pouco mais desafiadora. Com mais de dois, pode ser
desencorajador testar cada combinação de valores apropriados. Os parâmetros de saída são ainda
mais dificeis de entender do que os de entrada. Quando lemos uma função, estamos acostumados
ideia de informações entrando na função através de parâmetros e saindo através do valor
retornado. Geralmente não esperamos dados saindo através de parâmetros. Portanto, parâmetros
de saída costumam nos deixar surpresos e fazer com que leiamos novamente.
à
Um parâmetro de entrada é a melhor coisa depois de zero parâmetro. É fácil entender
SetupTeardown-Includer.render (pageData). Está óbvio que renderizemos os dados
no objeto pageData.
Formas Mônades Comuns
Há duas razões bastante comuns para se passar um único parâmetro a uma função. Você pode estar
fazendo uma pergunta sobre aquele parâmetro, como em boolean fileExists ("MyFile"). Ou
você pode trabalhar naquele parâmetro, transformando-o em outra coisa e retornando-o. Por exemplo,
InputStream fileOpen ("MyFile") transforma a String do nome de um arquivo em um valor
retornado por InputStream. São esses dois usos que os leitores esperam ver em uma função.
duas formas em Você deve escolher nomes que tornem clara a distinção, e sempre use um
contexto consistente. (Veja a seguir Separação comando-consulta). Uma forma menos comum
mas ainda bastante útil de um parâmetro para uma função é um evento. Nesta forma, há um
parâmetro de entrada, mas nenhum de saída. O programa em si serve para interpretar a chamada da
função como um evento, e usar o parâmetro para alterar o estado do sistema, por exemplo, void
passwordAttemptFailedNtimes (int attempts). Use esse tipo com cautela. Deve ficar
claro para o leitor que se trata de um evento. Escolha os nomes e os contextos com atenção.
Tente evitar funções mônades que não sigam essas formas, por exemplo, void include
SetupPageInto (StringBuffer pageText). Usar um parâmetro de saída em vez de
um valor de retorno para uma modificação fica confuso. Se uma função vai transformar seu
parâmetro de entrada,a alteração deve aparecer como o valor retornado. De fato, StringBuffer
transform(StringBuffer in) é melhor do que void transform-(StringBuffer
out), mesmo que a implementação do primeiro simplesmente retorne o parâmetro de entrada.
Pelo menos ele ainda segue o formato de uma modificação.
Parâmetros Lógicos
Esses parâmetros são feios. Passar um booleano para uma função certamente é uma prática horrível,
pois ele complica imediatamente a assinatura do método, mostrando explicitamente que a função
faz mais de uma coisa. Ela faz uma coisa se o valor for verdadeiro, e outra se for falso!
Use Parâmetros de Funções 41
Na Listagem 3.7, não tínhamos alternativa, pois os chamadores já estavam passando
aquela flag (valor booleano) como parâmetro, e eu queria limitar o escopo da refatoração à
função e para baixo. Mesmo assim, a chamada do método render (true) é muito confusa
para um leitor simples. Analisar a chamada e visualizar render (boolean isSuite) ajuda
um pouco, mas nem tanto. Deveríamos dividir a função em duas: renderForSuite() е
renderForSingleTest().
Funções Díades
Uma função com dois parâmetros é mais difícil de entender do que uma com um (mônade).
Por exemplo, é mais fácil compreender writeField(name) do que writeField(outputStream, name) 1. Embora o significado de ambas esteja claro, a primeira apresenta seu propósito
explicitamente quando a lemos. A segunda requer uma pequena pausa até aprendermos a ignorar o
primeiro parâmetro. E isso, é claro, acaba resultando em problemas, pois nunca devemos ignorar
qualquer parte do código. O local que ignoramos é justamente aonde se esconderão os bugs.
Há casos, é claro, em que dois parâmetros são necessários como, por exemplo, em Point p
= new Point (0,0). Os pontos de eixos cartesianos naturalmente recebem dois parâmetros.
De fato, ficaríamos surpresos se vissemos new Point(0). Entretanto, os dois parâmetros neste
caso são componentes de um único valor! Enquanto que output-Stream e name não são
partes de um mesmo valor.
Mesmo funções díades óbvias, como assertEquals (expected, actual), são
problemáticas.
Quantas vezes você já colocou actual onde deveria ser expected? Os dois parâmetros não
possuem uma ordem pré-determinada natural. A ordem expected, actual é uma convenção que
requer prática para assimilá-la.
a
Díades não são ruins, e você certamente terá de usá-las. Entretanto, deve-se estar ciente de que
haverá um preço a pagar e, portanto, deve-se pensar em tirar proveito dos mecanismos disponíveis
você para convertê-los em mônades. Por exemplo, você poderia tornar o método writeField
um membro de outputStream de modo que pudesse dizer outputStream.writeField(name);
tornar outputStream uma variável membro da classe em uso de modo que não precisasse passá-lo
por parâmetro; ou extrair uma nova classe, como FieldWriter, que receba o outputStream em seu
construtor e possua um método write.
Tríades
Funções que recebem três parâmetros são consideravelmente mais dificeis de entender do
que as díades. A questão de ordenação, pausa e ignoração apresentam mais do que o dobro de
dificuldade. Sugiro que você pense bastante antes de criar uma tríade.
Por exemplo, considere a sobrecarga comum de assertEquals que recebe três parâmetros:
assertEquals (message, expected, actual). Quantas vezes você precisou ler o
parâmetro message e deduzir o que ele carrega? Muitas vezes já me deparei com essa tríade em
particular e tive de fazer uma pausa. Na verdade, toda vez que a vejo, tenho de ler novamente e,
então, a ignoro.
10. Acabei de refatorar um módulo que usava uma diade. Consegui tornar o outputStream um campo da classe e converter todas as chamadas ac writeField para
Use Parâmetros de Funções 43
formato imbuímos os nomes dos parâmetros no nome da função. Por exemplo, pode ser melhor
escrever assertEquals do que assertExpectedEqualsActual(expected, actual),0
que resolveria o problema de ter de lembrar a ordem dos parâmetros.
Evite Efeitos Colaterais
Efeitos colaterais são mentiras. Sua função promete fazer apenas uma coisa, mas ela também faz
outras coisas escondida. Ås vezes, ela fará alterações inesperadas nas variáveis de sua própria
classe. Ås vezes, ela adicionará as variáveis aos parâmetros passados à função ou às globais
do sistema. Em ambos os casos elas são "verdades" enganosas e prejudiciais, que geralmente
resultam em acoplamentos temporários estranhos e dependências.
Considere, por exemplo, a função aparentemente inofensiva na Listagem 3.6. Ela usa um
algoritmo padrão para comparar um userName (nome de usuário) a um password
(senha). Ela retorna true (verdadeiro) se forem iguais, e false (falso) caso contrário.
Mas há também um efeito colateral. Consegue identificá-lo?
Listagem 3-6
UserValidator.java
public class UserValidator
private Cryptographer cryptographer;
public boolean checkPassword(String userName, String password)
User user = UserGateway.findByName (userName):
if (user != User.NULL)
String codedPhrase = user.get PhraseEncodedBy Password();
String phrase = cryptographer.decrypt (codedPhrase, password):
if ("Valid Password".equals (phrase)( }
Session.initializei);
return true;
1
return false;
O efeito colateral é a chamada ao Session.initialize(), é claro. A função
checkPassword, segundo seu nome, diz que verifica a senha. O nome não indica que ela
inicializa a sessão. Portanto, um chamador que acredita no que diz o nome da função corre
risco de apagar os dados da sessão existente quando ele decidir autenticar do usuário.
0
Esse efeito colateral cria um acoplamento temporário. Isto é, checkPassword só poderá ser
chamado em determinadas horas (em outras palavras, quando for seguro inicializar a sessão). Se
for chamado fora de ordem, sem querer, os dados da sessão poderão ser perdidos. Os acoplamentos
temporários são confusos, especialmente quando são um efeito colateral. Se for preciso esse tipo
44 Capítulo 3: Funções
de acoplamento, é preciso deixar claro no nome da função. Neste caso, poderíamos renomear
a função para checkPasswordAndInitializeSession, embora isso certamente violaria o
"fazer apenas uma única coisa".
Parâmetros de Saída
Os parâmetros são comumente interpretados como entradas de uma função. Se já usa o programa
há alguns anos, estou certo de que você já teve de voltar e ler novamente um parâmetro que era,
na verdade, de saida, e não de entrada. Por exemplo:
appendFooter(s);
Essa função anexa s como rodapé (Footer, em inglês) em algo? Ou anexa um rodapé a s? sé
uma entrada ou uma saída? Não precisa olhar muito a assinatura da função para ver:
public void appendFooter(StringBuffer report)
Isso esclarecea questão, mas à custa da verificação da declaração da função. Qualquer coisa
que lhe force a verificar a assinatura da função é equivalente a uma relida. Isso é uma interrupção
do raciocínio e deve ser evitado.
Antes do surgimento da programação orientada a objeto, às vezes era preciso ter parâmetros de
saída. Entretanto, grande parte dessa necessidade sumiu nas linguagens OO, pois seu propósito é servir
como um parâmetro de saída. Em outras palavras, seria melhor invocar appendFooter como:
report.appendFooter();
De modo geral, devem-se evitar parâmetros de saída. Caso sua função precise alterar o estado
de algo, faça-a mudar o estado do objeto que a pertence.
Separação comando-consulta
As funções devem fazer ou responder algo, mas não ambos. Sua função ou altera o estado de
um objeto ou retorna informações sobre ele. Efetuar as duas tarefas costuma gerar confusão.
Considere, por exemplo, a função abaixo:
public boolean set(String attribute, String value);
Esta função define o valor de um dado atributo e retorna true (verdadeiro) se obtiver
êxito e false (falso) se tal atributo não existir. Isso leva a instruções estranhas como:
if (set("username", "unclebob"))...
Imagine isso pelo ponto de vista do leitor. O que isso significa? Está perguntando se o atributo
"username" anteriormente recebeu o valor "unclebob"? Ou se "username" obteve êxito ao
receber o valor "unclebob"? É dificil adivinhar baseando-se na chamada, pois não está claro se
a palavra "set" é um verbo ou um adjetivo.
Prefira exceções a retorno de códigos de erro 45
O intuito do autor era que set fosse um verbo, mas no contexto da estrutura if, parece
um adjetivo. Portanto, a instrução lê-se "Se o atributo username anteriormente recebeu o valor
unclebob" e não "atribua o valorunclebob ao atributo username, e se isso funcionar, então...".
Poderíamos tentar resolver isso renomeando a função set para setAndCheckIfExists, mas
não ajudaria muito para a legibilidade da estrutura i f.
if (attributeExists("username")) {
setAttribute("username", "unclebob");
Prefira exceções a retorno de códigos de erro
Fazer funções retornarem códigos de erros é uma leve violação da separação comando-consulta,
pois os comandos são usados como expressões de comparação em estruturas if.
if (deletePage(page) == E_OK)
O problema gerado aqui não é a confusão verbo/adjetivo, mas sim a criação de estruturas
aninhadas.
Ao retornar um código de erro, você cria um problema para o chamador, que deverá lidar
imediatamente com o erro.
if (deletePage(page) == E_OK) }
if (registry.deleteReference(page.name) == E_OK) {
if (configKeys.deleteKey(page.name.makeKey()) == E_OK){
logger.log("página excluída");
} else {
}
} else {
registro");
logger.log("configkey não foi excluída");
logger.log("deleteReference nãc foi excluído do
} else {
logger.log("a exclusão falhou");
return E_ERROR;
Por outro lado, se você usar exceções em vez de retornar códigos de erros, então o código de
tratamento de erro poderá ficar separado do código e ser simplificado:
try {
deletePage(page);
registry.deleteReference (page.name);
configKeys.deleteKey(page.name.makeKey());
}
catch (Exception e) {
logger.log(e.getMessage());
}
46 Capítulo 3: Funções
Extraia os blocos try/catch
Esses blocos não têm o direito de serem feios. Eles confundema estrutura do código e misturam
o tratamento de erro com o processamento normal do código. Portanto, é melhor colocar as
estruturas try e catch em suas próprias funções.
public void delete(Page page) {
try {
}
deletePageAndAllReferences (page);
catch (Exception e) {
logError(e);
}
private void deletePageAndAllReferences (Page page) throws Exception
}
deletePage(page);
registry.deleteReference(page.name);
configKeys.deleteKey(page.name.makeKey());
private void logError(Exception e) {
logger.log(e.getMessage());
}
A função delete acima só faz tratamento de erro. E é fácil entendê-la e seguir adiante.
A função deletePageAndAllReferences só trata de processos que excluem toda uma
página. Pode-se ignorar o tratamento de erro. Isso oferece uma boa separação que facilita a
compreensão e alteração do código.
Tratamento de erro é uma coisa só
As funções devem fazer uma coisa só. Tratamento de erro é uma coisa só. Portanto, uma
função que trata de erros não deve fazer mais nada. Isso implica (como no exemplo acima)
que a palavra try está dentro de uma função e deve ser a primeira instrução e nada mais deve
vir após os blocos catch/finally.
Error.java, o chamariz à dependência
Retornar códigos de erro costuma implicar que há classes ou enum nos quais estão definidos
todos os códigos de erro.
public enum Error {
OK,
INVALID,
NO_SUCH,
LOCKED,
OUT OF RESOURCES,
WAITING_FOR_EVENT;
}
Programação estruturada 47
Classes como esta são chamarizes à dependência, muitas outras classes devem importá-las
e usá-las. Portanto, quando o enum da classe Error enum, é preciso recompilar todas as outras
classes e redistribuí-las". Isso coloca uma pressão negativa na classe Error. Os programadores não
querem adicionar novos erros porque senão eles teriam de compilar e distribuir tudo novamente.
Por isso, eles reutilizam códigos de erros antigos em vez de adicionar novos.
Quando se usam exceções em vez de códigos de erro, as novas exceções são derivadas da
classe de exceções. Podem-se adicioná-las sem ter de recompilar ou redistribuir¹²
Evite repetição
Leia novamente com atenção a Listagem 3.1 e notará
que há um algoritmo que se repete quatro vezes em
quatro casos: SetUp, SuiteSetUp, TearDown e
SuiteTearDown. Não é fácil perceber essa duplicação,
pois as quatro instâncias estão misturadas com outros
códigos e não estão uniformemente repetidas. Mesmo
assim, a duplicação é um problema, pois ela amontoa
o código e serão necessárias quatro modificações se o
algoritmo mudar. Além de serem quatro oportunidades
para a omissão de um erro.
Sanou-se essa duplicação através do método include na Listagem3.7. Leia este código novamente
e note como a legibilidade do módulo inteiro foi melhorada com a retirada de tais repetições.
A duplicação pode ser a raiz de todo o mal no software. Muitos princípios e práticas têm
sido criados com a finalidade de controlá-la ou eliminá-la. Considere, por exemplo, que todas
as regras de normalização de bando de dados de Ted Codd servem para eliminar duplicação
de dados. Considere também como a programação orientada a objeto serve para centralizar o
código em classes-base que seriam outrora redundantes. Programação estruturada, Programação
Orientada a Aspecto e Programação Orientada a Componentes são todas, em parte, estratégias
para eliminar duplicação de código. Parece que desde a invenção da sub-rotina, inovações no
desenvolvimento de software têm sido uma tentativa contínua para eliminar a duplicação de
nossos códigos-fonte.
Programação estruturada
Alguns programadores seguem as regras programação estruturada de Edsger Dijkstra", que disse
que cada função e bloco dentro de uma função deve ter uma entrada e uma saída. Cumprir essas
regras significa que deveria haver apenas uma instrução return na função, nenhum break ou
continue num loop e jamais um goto.
Enquanto somos solidários com os objetivos e disciplinas da programação estruturada, tais
regras oferecem pouca vantagem quando as funções são muito pequenas. Apenas em funções
maiores tais regras proporcionam beneficios significativos.
Portanto, se você mantiver suas funções pequenas, então as várias instruções return, break
ou continue casuais não trarão problemas e poderão ser até mesmo mais expressivas do que
11Aqueles qusaram que poderiam se livrar da recompilação e da redistribuição foram encontrados, e tomadas as devidas providēncias.
48 Capítulo 3: Funções
a simples regra de uma entrada e uma saída. Por outro lado, o goto só faz sentido em funções
grandes, portanto ele deve-se evitá-lo.
Como escrever funções como essa?
Criar um software é como qualquer outro tipo de escrita. Ao escrever um artigo, você primeiro
coloca seus pensamentos no papel e depois os organiza de modo que fiquem fáceis de ler. O
primeiro rascunho pode ficar desastroso e desorganizado, então você o apare, reestrutura e refina
até que ele fique como você deseja.
Quando escrevo funções, elas começam longas e complexas; há muitas endentações e loops
aninhados; possuem longas listas de parâmetros; os nomes são arbitrários; e há duplicação de
código. Mas eu também tenho uma coleção de testes de unidade que analisam cada uma dessas
linhas desorganizadas do código.
Sendo assim, eu organizo e refino o código, divido funções, troco os nomes, elimino a
duplicação, reduzo os métodos e os reorganizo. As vezes, desmonto classes inteiras, tudo com
os testes em execução.
No final, minhas funções seguem as regras que citei neste capítulo. Não as aplico desde o
início. Acho que isso não seja possivel.
Conclusão
Cada sistema é construído a partir de uma linguagem específica a um domínio desenvolvida por
programadores para descrever o sistema. As funções são os verbos dessa linguagem, e classes
os substantivos. Isso não é um tipo de retomada da antiga noção de que substantivos e verbos
nos requerimentos de um documento sejam os primeiros palpites das classes e funções de um
sistema. Mas sim uma verdade muito mais antiga. A arte de programar é, e sempre foi, a arte do
projeto de linguagem.
Programadores experientes veem os sistemas como histórias a serem contadas em vez de
programas a serem escritos. Eles usam os recursos da linguagem de programação que escolhem
para construir uma linguagem muito mais rica e expressiva do que a usada para contar a estória.
Parte da linguagem específica a um domínio é a hierarquia de funções que descreve todas as
ações que ocorrem dentro daquele sistema. Em um ato engenhoso, escrevem-se essas funções
para usar a mesma linguagem específica a um domínio que eles criaram para contar sua própria
parte da história.
Este capítulo falou sobre a mecânica de se escrever bem funções. Se seguir as regras aqui descritas.
suas funções serão curtas, bem nomeadas e bem organizadas. Mas jamais se esqueça de que seu
objetivo verdadeiro é contar a história do sistema, e que as funções que você escrever precisam estar
em perfeita sincronia e formar uma linguagem clara e precisa para lhe ajudar na narração.
Setup TeardownIncluder
SetupTeardownIncluder
Listagem 3-7
SetupTeardownIncluder.java
package fitnesse.html;
import fitnesse.responders.run.SuiteResponder;
import fitnesse.wiki.*;
public class SetupTeardownIncluder
private PageData pageData;
private boolean isSuite;
private WikiPage testPage;
}
private StringBuffer newPageContent;
private PageCrawler pageCrawler;
public static String render(PageData pageData) throws Exception
return render (pageData, false);
public static String render (PageData pageData, boolean isSuite)
throws Exception {
return new SetupTeardownIncluder (pageData).render(isSuite);
private SetupTeardownIncluder (PageData pageData)
this.pageData = pageData;
testPage = pageData.getWikiPage();
pageCrawler = testPage.getPageCrawler();
newPageContent = new StringBuffer();
private String render (boolean isSuite) throws Exception
this.isSuite = isSuite:
if (isTestPage())
includeSetupAndTeardownPages ();
return pageData.getHtml();
private boolean isTestPage() throws Exception {
return pageData.hasAttribute("Test");
{
private void includeSetupAndTeardownPages() throws Exception
includeSetupPages (
includePageContent();
includeTeardownPages();
updatePageContent !);
49
50
Listagem 3-7 (continuação):
SetupTeardownIncluder.java
private void includeSetupPages() throws Exception
if (isSuite)
includeSuiteSetupPage();
includeSetupPage():
{
}
private void includeSuiteSetupPage() throws Exception
includeiSuiteResponder. SUITE_SETUP_NAME, "-setup*);
{
}
private void includeSetupPage() throws Exception {
include("SetUp", "-setup");
private void includePageContent () throws Exception {
newPageContent.append (pageData.getContent ());
private void includeTeardownPages() throws Exception
includeTeardownPage();
if (isSuite)
includeSuiteTeardownPage (l;
private void includeTeardownPage() throws Exception
include("TearDown", "-teardown";
}
private void includeSuiteTeardownPage() throws Exception {
include (SuiteResponder.SUITE_TEARDOWN_NAME, "-teardown"):
private void updatePageContent() throws Exception {
pageData.setContent (newPageContent.toString());
}
private void include (String pageName, String arg) throws Exception
WikiPage inheritedPage = findInheritedPage (pageName);
if (inheritedPage != null)
String pagePathName = getPathNameForPage(inheritedPage);
buildIncludeDirective (pagePathName, arg);
Capítulo 3: Funções
{
private WikiPage findInheritedPage(String pageName) throws Exception
return PageCrawlerImpl.getInheritedPage (pageName, testPage);
private String getPathNameForPage (WikiPage page) throws Exception {
WikiPagePath pagePath = pageCrawler.getFullPath(page);
return PathParser.render (pagePath);
}
private void buildIncludeDirective (String pageFathName, String arg) {
newPageContent
.append("\n!include ")
4
Comentários
"Não insira comentários num código ruim, reescreva-о".
-Brian W. Kernighan eP. J. Plaugher¹
Nada pode ser tão útil quanto um comentário bem colocado. Nada consegue amontoar um
módulo mais do que comentários dogmáticos e supérfluos. Nada pode ser tão prejudicial quanto
um velho comentário mal feito que dissemina mentiras e informações incorretas.
Comentários não são como a Lista de Schindler. Não são o "bom puro". De fato, eles são,
no máximo, um mal necessário. Se nossas linguagens de programação fossem expressivas o
suficiente ou se tivéssemos o talento para manipular com destreza tais linguagens de modo a
expressar nossa intenção, não precisaríamos de muitos comentários, quiçá nenhum.
54 Capítulo 4: Comentários
O uso adequado de comentários é compensar nosso fracasso em nos expressar no código.
Observe que usei a palavra fracasso. E é isso que eu quis dizer. Comentários são sempre fracassos.
Devemos usá-los porque nem sempre encontramos uma forma de nos expressar sem eles, mas
seu uso não é motivo para comemoração.
Então, quando você estiver numa situação na qual precise criar um comentário, pense bem
e veja se não há como se expressar através do código em si. Toda vez que você fizer isso, dê em
si mesmo um tapinha de aprovação nas costas. Toda vez que você escrever um comentário, faça
uma careta e sinta o fracasso de sua capacidade de expressão.
Por que sou não gosto de comentários? Porque eles mentem. Nem sempre, e não
intencionalmente, mas é muito comum. Quanto mais antigo um comentário for e quanto mais
longe estiver do código o qual ele descreve, mais provável será que esteja errado. O motivo é
simples. Não é realístico que programadores consigam mantê-los atualizados.
Códigos mudam e evoluem. Movem-se blocos para lá e para cá, que se bifurcam e se reproduzem
e se unem novamente, formando monstros gigantescos. Infelizmente, os comentários nem sempre os
seguem - nem sempre é possível. E, muito frequentemente, os comentários ficam longe do código
o qual descrevem e se tornam dizeres órfãos com uma exatidão cada vez menor. Por exemplo, olhe
o que aconteceu com o comentário abaixo e a linha que ele procurava descrever:
MockRequest request;
private final String HTTP_DATE_REGEXP =
"[SMTWF][a-z]{2}\\,\\s[0-9]{2}\\s[JFMASOND] [a-z]{2}\\s"+
"[0-9](4)\\s[0-9]{2}\\:[0-9]{2}\\:[0-9]{2}\\sGMT";
private Response response;
private FitNesseContext context;
private FileResponder responder:
private Locale saveLocale;
// Exemplo: "Tue, 02 Apr 2003 22:18:49 GMT"
Outras instâncias de variáveis que provavelmente foram adicionadas posteriormente ficaram
entre a constante HTTP_DATE_REGEXPe seu comentário descritivo.
É possível dizer que os programadores deveriam ser disciplinados o bastante para manter
os comentários em um elevado estado de atualização, relevância e precisão. Concordo que
deveriam. Mas eu preferiria que essa energia fosse direcionada para tornar o código tão claro e
descritivo que de início nem se precisaria de comentários.
Comentários imprecisos são muito piores do que nenhum. Eles enganam e iludem; deixam
expectativas que jamais serão cumpridas; citam regras antigas que não precisariam mais, ou não
deveriam, ser seguidas.
Só se pode encontrar a verdade em um lugar: no código. Só ele pode realmente lhe dizer o que
ele faz. Ele é a única fonte de informações verdadeiramente precisas. Entretanto, embora às vezes
comentários sejam necessários, gastaríamos energia considerável para minimizá-los.
Comentários Compensam um Código Ruim
Uma das motivações mais comuns para criar comentários é um código ruim. Construímos um
módulo e sabemos que está confuso e desorganizado. Estamos cientes da bagunça. Nós mesmos
dizemos "Oh, é melhor inserir um comentário!". Não! É melhor limpá-lo.
Comentários Bons 55
Códigos claros e expressivos com poucos comentários são de longe superiores a um amontoado
e complexo com muitos comentários. Ao invés de gastar seu tempo criando comentários para
explicar a bagunça que você fez, use-o para limpar essa zona.
Explique-se no código
Certamente há vezes em que não é possível se expressar direito no código. Infelizmente, devido
a isso, muitos programadores assumiram que o código raramente é, se é que possa ser, um bom
meio para se explicar. Evidentemente isso é falso. O que você preferiria ver? Isso:
// Verifica se o funcionario tem direito a todos os beneficios
if ((employee.flags & HOURLY_FLAG) &&
Ou isso?
(employee.age > 65))
if (employee.isEligibleForFullBenefits())
Só é preciso alguns segundos de pensamento para explicar a maioria de sua intenção no
código. Em muitos casos, é simplesmente uma questão de criar uma função cujo nome diga a
mesma coisa que você deseja colocar no comentário.
Comentários Bons
Certos comentários são necessários ou benéficos. Veremos alguns que considero valerem os
bits que consumem. Tenha em mente, contudo, que o único comentário verdadeiramente bom é
aquele em que você encontrou uma forma para não escrevê-lo.
Comentários Legais
As vezes, nossos padrões de programação corporativa nos forçam a escrever certos comentários
por questões legais. Por exemplo, frases sobre direitos autorais e autoria são informações
necessárias e lógicas para se colocar no início de um arquivo fonte.
Por exemplo, abaixo está o comentário padrão de cabeçalho que colocamos no início de todo
arquivo fonte do FitNesse. Fico feliz em dizer que nossa IDE evita a união automática desse
comentário para que não fique aglomerado.
// Direitos autorais (C) 2003,2004,2005 por Object Mentor, Inc. Todos
os direitos reservados.
// Distribuido sob os termos da versão 2 ou posterior da Licenca
Publica Geral da GNU.
Comentários como esse não devem ser contratos ou tomos legais. Onde for possível, faça
referência a uma licença padrão ou outro documento externo em vez de colocar todos os termos
e condições no mesmo comentário.
56 Capítulo 4: Comentários
Comentários Informativos
As vezes é prático fornecer informações básicas em um comentário. Por exemplo, considere o
comentário abaixo que explica o valor retornado de um método abstrato:
// Retorna uma instancia do Responder sendo testado.
protected abstract Responder responderInstance();
Um comentário como este pode ser útil às vezes, mas, sempre que possível, é melhor usar o
nome da função para transmitir a informação. Por exemplo, neste caso, o comentário ficaria
redundante se trocássemos o nome da função: responderBeingTested.
Assim ficaria um pouco melhor:
// formato igual a kk:mm:ss EEE, MMM dd, aaaa
Pattern timeMatcher = Pattern.compile("\\d*:\\d*: \\d* \\w*, ilw* l!d*, \\d*");
Neste caso, o comentário nos permite saber que a expressão regular deve combinar com uma
hora e data formatadas com a função SimpleDateFormat.format usando a string específica com
o formato. Mesmo assim, teria ficado melhor e mais claro se esse código tivesse sido colocado
em uma classe especial para converter os formatos de datas e horas. Então, o comentário
provavelmente seria supérfluo.
Explicação da intenção
Às vezes, um comentário vai além de ser apenas informações úteis sobre a implementação e
fornece a intenção por trás de uma decisão. No caso a seguir, vemos uma decisão interessante
documentada através de um comentário. Ao comparar dois objetos, o autor decidiu que queria
classificar como superiores os objetos de sua classe em relação aos de outras.
public int compareTo(Object o)
}
if(o instanceof WikiPagePath)
WikiPagePath p = (WikiPagePath) о;
String compressedName = StringUtil.join(names, "");
String compressedArgumentName = StringUtil.join(p.names, ");
return compressedName.compareTo (compressedArgumentName);
return 1; // somos superiores porque somos tipo certo.
Abaixo está um exemplo melhor ainda. Talvez você discorde da solução do programador, mas
pelo menos você sabe o que ele estava tentando fazer.
public void testConcurrentAddWidgets() throws Exception {
WidgetBuilder widgetBuilder =
new WidgetBuilder(new Class[]{BoldWidget.class});
String text = ""bold text'
Comentários Bons 57
ParentWidget parent =
new BoldWidget(new MockWidgetRoot(), ""bold textн);
AtomicBoolean failFlag = new AtomicBoolean();
failFlag.set(false);
//Essa e a nossa melhor tentativa para conseguir uma condicao de corrida.
//Para isso criamos um grande numero de threads.
for (int i = 0; i < 25000; i++) {
WidgetBuilderThread widgetBuilderThread =
failFlag);
}
new WidgetBuilderThread(widgetBuilder, text, parent,
Thread thread = new Thread(widgetBuilderThread);
thread.start();
}
assertEquals(false, failFlag.get());
Esclarecimento
Às vezes é bom traduzir o significado de alguns parâmetros ou valores retornados obscuros para
algo inteligível. De modo geral, é melhor encontrar uma forma de esclarecer tal parâmetro on
valor retornado por si só, mas quando for parte da biblioteca padrão, ou de um código que não se
possa alterar, então um comentário esclarecedor pode ser útil.
public void testCompareTo() throws Exception
{
WikiPagePath a = PathParser.parse("PageA");
WikiPagePath ab = PathParser.parse("PageA.PageB");
WikiPagePath b = PathParser.parse("PageB");
WikiPagePath aa = PathParser.parse("PageA.PageA");
WikiPagePath bb= PathParser.parse("PageB.PageB");
WikiPagePath ba = PathParser.parse("PageB.PageA");
assertTrue(a.compareTo(a) == 0);
assertTrue(a.compareTo(b) !=
a == a
0); !1 a != b
assertTrue(ab.compareTo(ab) == 0); ab ab
assertTrue(a.compareTo (b) == -1); a 스 b
assertTrue(aa.compareTo (ab) ==-1); // aa 스 ab
assertTrue(ba.compareTo(bb) == -1); !/ ba < bb
assertTrue(b.compareTo(a) == 1); // ь
> a
ab aa
1! bb > ba
assertTrue(ab.compareTo(aa) == 1); //
assertTrue(bb.compareTo(ba) == 1);
Há um risco considerável, é claro, de que um comentário esclarecedor possa estar incorreto. Leia
o exemplo anterior e veja como é difícil verificar se estão corretos. Isso explica tanto o porquê da
necessidade do esclarecimento como seu risco. Portanto, antes de criar comentários como esses,
certifique-se de que não há outra saída melhor e, então, certifique-se ainda mais se estão precisos.
58 Capítulo 4: Comentários
Alerta Sobre Consequências
Ás vezes é útil alertar outros programadores sobre certas
consequências. Por exemplo, o comentário abaixo explica
porque um caso de teste em particular está desabilitado:
}
// NãoNão execute a menos que você
// tenha tempo disponível.
public void _testWithReallyBigFile()
{
writeLinesToFile(10000000);
response.setBody(testFile);
response.readyToSend(this);
String responseString = output.
toString();
assertSubString("Content-Length: 1000000000*, responseString);
assertTrue(bytesSent > 1000000000);
Hoje em dia, desabilitaríamos o teste de caso através do atributo @ignore com uma string
explanatória adequada: @ignore ("Leva muito tempo para executar"). Antes da chegada do JUnit4,
uma convenção comum era colocar um traço inferior (underscore) no início do nome do método.
O comentário, enquanto divertido, passa sua mensagem muito bem.
Outro exemplo mais direto seria:
public static SimpleDateFormat makeStandardHttpDateFormat()
{
//SimpleDateFormat não é uma thread segura,
//é preciso criar cada instância independentemente.
SimpleDateFormat df = new SimpleDateFormat ("EEE, dd MMM yyyy
HH:mm:ss z");:
df.setTimeZone(TimeZone.getTimeZone ("GMT"));
return df;
Talvez você reclame por haver melhores maneiras de resolver esse problema. Talvez eu
concorde com você, mas o comentário como foi feito é perfeitamente lógico. Ele evitará que um
programador afoito use um inicializador estático em prol da eficiência.
Comentário TODO
Às vezes é cabível deixar notas "To Do" ('Fazer') em comentários no formato //TODO. No caso
a seguir, o comentário TODO explica por que a função tem uma implementação degradante е o
que se deveria fazer com aquela função.
//TODO-MdM essas não são necessárias
// Esperamos que isso não esteja mais aqui quando verificarmos o modelo
protected VersionInfo makeVersion() throws Exception
{
return null;
}
Comentários Ruins 59
TODOS são tarefas que os programadores acham que devem ser efetuadas, mas, por alguma
razão, não podem no momento. Pode ser um lembrete para excluir uma instrução desnecessária
ou um apelo para que alguém olhe o problema. Ou um pedido para que alguém pense em um nome
melhor ou um lembrete para fazer uma alteração que é dependente de um evento determinado.
Seja qual for o TODO, ele não justifica deixar um código ruim no sistema.
Hoje em dia, a maioria das IDEs oferecem ferramentas e recursos para localizar todos os
comentários TODO; portanto, não é provável que fiquem perdidos no código. Mesmo assim, você
não deseja que seu código fique amontoado de TODOS, sendo assim, procure-os regularmente e
elimine os que puder.
Destaque
Pode-se usar um comentário para destacar a importância de algo que talvez pareça irrelevante.
String listItemContent = match.group(3).trim();
// a função trim é muito importante. Ela remove os espaços
// iniciais que poderiam fazer com que o item fosse
// reconhecido como outra lista.
new ListItemWidget(this, listItemContent, this.level + 1);
return buildList(text.substring(match.end()));
Javadocs em APIs Públicas
Não há nada de tão prático e satisfatório como uma API pública em descrita. Os javadocs para a
biblioteca Java padrāo são um exemplo. No máximo, seria dificil escrever programas Java sem eles.
Se estiver criando uma API pública, então você certamente deveria escrever bons javadocs
para ela. Mas tenha em mente os outros conselhos neste capítulo. Os javadocs podem ser tão
enganadores, não-locais e desonestos como qualquer outro tipo de comentário.
Comentários Ruins
A maioria dos comentários cai nesta categoria. Geralmente eles são suportes ou desculpas para
um código de baixa qualidade ou justificativas para a falta de decisões, amontoados como se o
programador estivesse falando com si mesmo.
Murmúrio
Usar um comentário só porque você sente que deve ou porque o processo o requer é besteira. Se
optar criar um comentário, então gaste o tempo necessário para fazê-lo bem.
Por exemplo, a seguir está um caso que encontrei no FitNesse, no qual um comentário poderia
ter sido útil. Entretanto, o autor estava com pressa ou não prestava muita atenção. Seu murmúrio
foi deixado para trás como um enigma:
public void loadProperties()
try
60 Capítulo 4: Comentários
}
String propertiesPath =
propertiesLocation + "/" + PROPERTIES_FILE;
FileInputStream propertiesStream =
new FileInputStream(propertiesPath);
loadedProperties.load(propertiesStream);
catch(IOException e)
// Nenhum arquivo de propriedades significa que todos os padrões
estão carregados
}
}
ao
O que esse comentário no bloco catch significa? Claramente fazia sentido para o autor,
mas o significado não foi muito bem transmitido. Aparentemente, se capturarmos (catch) uma
IOException, significaria que não há arquivo de propriedades; e, neste caso, todos os padrões
estão carregados. Mas quem carrega os padrões? Eles foram carregados antes da chamada
loadProperties.load? Ou este capturou a exceção, carregou os padrões e, então, passou
exceção para que ignorássemos? Ou loadProperties. 1oad carregou todos os padrões antes
de tentar carregar o arquivo? Será que o autor estava limpando sua consciência por ter deixado
o bloco do catch vazio? Ou - e essa possibilidade é assustadora - ele estava tentando dizer a si
mesmo para voltar depois e escrever o código que carregaria os padrões?
a
Nosso único recurso é examinar o código em outras partes do sistema para descobrir o que
está acontecendo. Qualquer comentário que lhe obrigue a analisar outro módulo em busca de um
significado falhou em transmitir sua mensagem e não vale os bits que consume.
Comentários Redundantes
A Listagem 4.1 uma função simples com um comentário no cabeçalho que é completamente
redundante. Provavelmente leva-se mais tempo para lê-lo do que o código em si.
Listagem 4-1
waitForClose
// Utility method that returns when this.closed is true. Throws an exception
// if the timeout is reached.
public synchronized void waitForClose(final long timeoutMillis)
throws Exception
i
if(!closed)
}
wait(timeoutMillis);
if(!closed)
throw new Exception ("MockResponseSender could not be closed");
Qual o propósito desse comentário? Certamente não é mais informativo do que o código.
Nem mesmo justifica o código ou oferece uma intenção ou raciocínio. É mais fácil ler o código
apenas. De fato, ele é menos preciso do que o código e induz o leitor a aceitar tal falta de precisão
Comentários Ruins 61
em vez da interpretação verdadeira. É mais como um vendedor interesseiro de carros usados lhe
garantindo que não é preciso olhar sob o capô.
Agora considere o grande número de javadocs inúteis e redundantes na Listagem 4.2 retirada
do Tomcat. Esses comentários só servem para amontoar e encobrir o código. Eles não passam
informação alguma. Para piorar, só lhe mostrei os primeiros, mas há muito mais neste módulo.
Listagem 4-2
ContainerBase.java (Tomcat)
public abstract class ContainerBase
implements Container, Lifecycle, Pipeline,
MBeanRegistration, Serializable {
The processor delay for this component.
protected int backgroundProcessorDelay =-1;
The lifecycle event support for this component.
protected LifecycleSupport lifecycle =
new LifecycleSupport (this)
* The container event listeners for this Container.
protected ArrayList listeners = new ArrayList ();
+
The Loader implementation with which this Container is
associated.
protected Loader loader = null;
The Logger implementation with which this Container is
* associated.
protected Log logger = null;
Associated logger name.
protected String logName = null;
The Manager implementation with which this Container is
associated.
protected Manager manager = null;
62
Listagem 4-2 (continuação):
ContainerBase.java (Tomcat)
The cluster with which this Container is associated.
*1
protected Cluster cluster = null;
The human-readable name of this Container.
protected String name = null;
The parent Container to which this Container is a child.
protected Container parent = null:
*
The parent class loader to be configured when we install
Loader.
protected ClassLoader parentClassLoader = null:
*
The Pipeline object with which this Container is
associated.
protected Pipeline pipeline = new StandardPipeline(this);
The Realm with which this Container is associated.
protected Realm realm = null;
*
The resources DirContext object with which this Container
is associated.
protected DirContext resources = null;
a
Capítulo 4: Comentários
Comentários Ruins 63
Comentários Enganadores
As vezes, com todas as melhores das intenções, um programador faz uma afirmação não muito
clara em seus comentários. Lembre-se também do redundante e enganador comentário que vimos
na Listagem 4.1.
Como você descobriu que o comentário era enganador? O método não retornava quando this.
closed virava true (verdadeiro), mas só se this.closed já fosse true (verdadeiro);
caso contrário, ele esperava por um tempo limite e, então, lançava uma exceção se this.closed
ainda não fosse true (verdadeiro).
Essa pequena desinformação, expressada emum comentário mais dificil de ler do que o códigoem
si, poderia fazer com que outro programador despreocupadamente chamasse essa função esperando-a
que retornasse assim que this.closed se tornassetrue (verdadeiro). Esse pobre programador
logo se veria efetuando uma depuração tentando descobrir o porquê da lentidão do código.
Comentários Imperativos
É basicamente tolo ter uma regra dizendo que toda função deva ter um Javadoc, ou toda variável
um comentário. Estes podem se amontoar no código, disseminar mentiras e gerar confusão e
desorganização.
Por exemplo, os javadocs exigidos para cada função levariam a abominações, como as da
Listagem 4.3. Essa zona não acrescenta nada e só serve para ofuscar o código e abrir o caminho
para mentiras e desinformações.
Listagem 4-3
@param title The title of the CD
@param author The author of the CD
on the CD @param tracks The number of tracks
@param durationInMinutes The duration of the CD in minutes
public void addCD(String title, String author,
CD cd = new CD():
cd.title = title;
int tracks, int durationInMinutes) {
cd.author = author;
cd.tracks = tracks;
cd.duration = duration:
cdList.add (cd);
Comentários Longos
Às vezes, as pessoas, toda vez que editam um módulo, sempre adicionam um comentário no
início. Após várias alterações, a quantidade de comentários acumulada parece mais uma redação
ou um diário. Já vi módulos com dezenas de páginas assim.
64 Capítulo 4: Comentários
Changes (from 11-Oct-2001)
11-Oct-2001: Re-organised the class and moved it to new package
com.jrefinery.date (DG);
05-Nov-2001: Added a getDescription() method, and eliminated NotableDate
class (DG!;
12-Nov-2001: IBD requires setDescription() method, now that NotableDate
class is gone (DG); Changed getPreviousDayOfWeeki), getFollowingDayOfWeek() and getNearestDayOfWeek() to correct
bugs (DG);
05-Dec-2001
27-Aug-2002 :
: Fixed bug in Spreadsheet Date class (DG):
29-May-2002: Moved the month constants into a separate interface
(MonthConstants) (DG);
Fixed bug in addMonths() method, thanks to N???levka Petr (DG);
03-Oct-2002: Fixed errors reported by Checkstyle (DG);
13-Mar-2003: Implemented Serializable (DG);
29-May-2003 : Fixed bug in addMonths method (DG);
04-Sep-2003: Implemented Comparable. Updated the isInRange javadocs (DG);
05-Jan-2005: Fixed bug in addYears() method (1096282) (DG);
Há muito tempo, havia um bom motivo para criar e preservar essas informações no início de
cada módulo, pois não existiam ainda os sistemas de controle de código fonte para fazer isso por
nós. Hoje em dia, entretanto, esses comentários extensos são apenas entulhos que confundem o
código, devendo assim ser completamente removidos.
Comentários Ruidosos
Às vezes você vê comentários que nada são além de "chiados". Eles dizem o óbvio e não
fornecem novas informações.
Construtor padrão.
*/
protected AnnualDateRule() {
}
Ah, sério? Ou este:
/** Dia do mes. */
private int dayOfMonth;
E há também o seguinte tipo de redundância:
1**
Retorna do dia do mês.
*
* @return o dia do mês.
*/
public int getDayOfMonth() {
return dayOfMonth;
Esses comentários são tão irrelevantes que aprendemos a ignorá-los. Ao lermos o código, nossos
olhos passam direto por eles. No final, os comentários passam a "mentir" conforme o código muda.
Comentários Ruins 65
O primeiro comentário na Listagem 4.4 parece adequado. Ele explica por que o block catch
é ignorado. Contudo, o segundo não passa de um chiado. Aparentemente, o programador estava
tão frustrado por criar blocos try/catch na função que ele precisou desabafar.
Listagem 4-4
startSending
private
}
 void startSending()
try
doSending();
catch (SocketException e)
// normal. someone stopped the request.
catch (Exception e)
try
response.add(ErrorResponder.makeExceptionString(e));
response.closeAl1():
catch (Exception el)
//Give me a break!
}
Em vez de desabafar em comentários sem sentido e ruidosos, ele poderia ter pegado tal
frustração e usado-a para melhorar a estrutura do código. Ele deveria ter redirecionado sua energia
para colocar o último bloco try/catch em uma função separada, como mostra a Listagem 4.5.
Listagem 4-5
startSending (refatorado)
private void startSending()
try
doSending();
catch (SocketException e)
// normal. someone stopped the request.
catch (Exception e)
2 A tendência atual das IDEs de verificação da ortografia em comentários será um alívio para nós que lemos bastante códigos.
66
Listagem 4-5 (continuação)
startSending (refatorado)
addExceptionAndCloseResponse (e);
private void addExceptionAndCloseResponse (Exception e)
try
}
response.add(ErrorResponder.makeExceptionString(e)); response.closeAll1):
catch (Exception el)
}
Capítulo 4: Comentários
Troque a tentação para criar ruídos pela determinação para limpar seu código. Você perceberá
que isso lhe tornará um programador melhor e mais feliz.
Ruídos assustadores
Os javadocs também podem ser vistos como ruídos. Qual o objetivo dos Javadocs (de uma
biblioteca de código livre bem conhecida) abaixo?
** NOome. *!
private String name;
/** The version. */
private String version;
/** Nome da licenca. */
private String licenceName;
/** Versão. */
private String info;
Releia os comentários com mais atenção. Notou um erro de recortar-colar? Se os autores não
prestarem atenção na hora de escrever os comentários (ou colá-los), por que os leitores deveriam
esperar algo de importante deles?
Evite o comentário se é possível usar uma função ou uma variável
Considere o pedaço de código abaixo:
// o módulo da lista global <mod> depende do
// subsistema do qual fazemos parte?
if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem()))
Comentários Ruins 67
Poderia-se evitar o comentário e usar:
ArrayList moduleDependees = smodule.getDependSubsystems();
String ourSubSystem = subSysMod.getSubSystem();
if (moduleDependees.contains(ourSubSystem))
O autor do código original talvez tenha escrito primeiro o comentário (pouco provável) e, então,
o código de modo a satisfazer o comentário. Entretanto, o autor deveria ter refatorado o código,
como eu fiz, para que pudesse remover o comentário.
Marcadores de Posição
Algumas vezes os programadores gostam de marcar uma posição determinada no arquivo fonte.
Por exemplo, recentemente encontrei o seguinte num programa:
// Ações /////////.////////////////////!///
É raro, mas há vezes que faz sentido juntar certas funções sob um indicador como esses. Mas, de
modo geral, eles são aglomerações e devem-se excluí-los especialmente as várias barras no final.
Pense assim: um indicador é chamativo e óbvio se você não os vê muito frequentemente.
Portanto, use-os esporadicamente, e só quando gerarem beneficios significativos. Se usar
indicadores excessivamente, eles cairão na categoria de ruídos e serão ignorados.
Comentários ao lado de chaves de fechamento
As vezes, os programadores colocam comentários especiais ao lado de chaves de fechamento,
como na Listagem 4.6.
Embora isso possa fazer sentido em funções longas com estruturas muito aninhadas, só serve para
amontoar o tipo de funções pequenas e encapsuladas que preferimos. Portanto, se perceber uma
vontade de comentar ao lado de chaves de fechamento, tente primeiro reduzir suas funções.
Listagem 4-6
wc.java
public class wc{
public static void main(String[] args)
}
BufferedReader in = new BufferedReader (new InputStreamReader (System.in});
String line;
int lineCount = 0;
int charCount = 0;
int wordCount = 0;
try {
while ((line = in.readLine()) != null)
lineCount++;
charCount += line.length():
String words[] = line.split("\\W");
wordCount += words.length;
} //while
System.out.println ("wordCount = " + wordCount);:
System.out.println("lineCount ="+ lineCount);
System.out.println("charCount =+ charCount);
// try
68
Listagem 4-6 (continuação)
wc.java
catch (IOException e) {
System.err.println("Error:" + e.getMessage()};
} //catch
} //main
Capítulo 4: Comentários
Créditos e autoria
Os
/* Adicionado por Rick */
sistemas de controle de código fonte são muito bons para lembrar que adicionou o quê e
quando. Não há necessidade de poluir o código com comentários de autoria. Talvez você ache
que tais comentários sejam úteis para ajudar outras pessoas a saberem o que falar sobre o código.
Mas a verdade é que eles permanecem por anos, ficando cada vez menos precisos e relevantes.
Novamente, o sistema de controle de código fonte é um local melhor para este tipo de
informação.
Explicação do código em comentários
Poucas práticas são tão condenáveis quanto explicar o código nos comentários. Não faça isso!
InputStreamResponse response = new InputStreamResponse();
response.setBody(formatter.getResultStream(), formatter.
getByteCount());
// InputStream resultsStream = formatter.getResultStream();
// StreamReader reader = new StreamReader(resultsStream);
// response.setContent(reader.read(formatter.getByteCount()));
Outros que vissem esse código não teriam coragem de excluir os comentários. Eles achariam que
estão lá por um motivo e são importantes demais para serem apagados. Portanto, explicação de
códigos em comentários se acumula como sujeira no fundo de uma garrafa de vinho ruim.
Observe o código do Commons do Apache:
this.bytePos = writeBytes(pngIdBytes, 0);
//hdrPos = bytePos;
writeHeader();
writeResolution();
//dataPos = bytePos;
if (writeImageData()) }
}
writeEnd();
this.pngBytes = resizeByteArray(this.pngBytes, this.maxPos);
else {
this.pngBytes = null;
}
return this.pngBytes;
Por que aquelas duas linhas de código estão comentadas? Elas são importantes? Foram deixados
como lembretes para alguma alteração iminente? Ou são apenas aglomerados que alguém
comentara anos atrás e simplesmente não se preocupou em limpar?
Comentários Ruins 69
Houve uma época, na década de 1960, em que explicar o código em comentários poderia ser
prático. Masjá faz um tempo que temos os sistemas de controle de código fonte, que lembrarão
o código para nós. Não precisamos explicá-lo em comentários. Simplesmente exclua o código.
Prometo que não o perderá.
Comentários HTML
Códigos HTML em comentários de código fonte são uma aberração, como pode ver no código
abaixo. Eles dificultam a leitura dos comentários onde seriam fáceis de ler - no editor/IDE. Se
forem extrair comentários com alguma ferramenta (como o Javadoc) para exibir numa página da
Web, então deveria ser responsabilidade de tal ferramenta, e não do programador, adicionar os
comentários com os códigos HTML adequados.
**
*
*
Tarefa para executar os testes do Fit.
Essa tarefa efetua os testes do FitNesse e exibe os resultados.
<p/>
<pre>
Uso:
&lt;taskdef name=&quot;execute-fitnesse-tests&quot; classname=&quot;fitnesse.ant.ExecuteFitnesseTestsTask&quot;
classpathref=&quot;classpath&quot; /&gt;
* OU
&lt;taskdef classpathref=&quot;classpath&quot;
resource=&quot;tasks.properties&quot; /&gt;
* <p/>
*
*
*
&lt;execute-fitnesse-tests
suitepage=&quot;FitNesse.SuiteAcceptanceTests&quot;
fitnesseport=&quot; 8082&quot; resultsdir=&quot;$(results.dir}&quot; resultshtmlpage=&quot;fit-results.html&quot;
classpathref=&quot;classpath&quot; /&gt;
* </pre>
Informações não-locais
Se você precisar escrever um comentário, então, coloque-o perto do código que ele descreve. Não
forneça informações gerais do sistema no contexto de um comentário local. Considere, por exemplo,
o comentário do Javadoc abaixo. Além de ser terrivelmente redundante, ele também fala sobre a
porta padrão.Ainda assim, a função nem sabe que porta é essa. O comentário não está descrevendo
a função, mas alguma outra em alguma parte distante do sistema. Certamente não há garantia de
que esse comentário será atualizado quando o código que contém tal padrão for alterado.
/**
Porta na qual o FitNesse deveria rodar. Padrão para <b>8082</b>.
*
* @param fitnessePort
*/
public void setFitnessePort(int fitnessePort)
this.fitnessePort = fitnessePort;
}
70 Capítulo 4: Comentários
Informações excessivas
Não adicione discussões históricas interessantes ou descrições irrelevantes de detalhes em seus
comentários. Abaixo está o comentário de um módulo projetado para testar se uma função
poderia codificar e decodificar base64. Além do número RFC, a pessoa que ler este código não
precisa das informações históricas contidas no comentário.
/*
RFC 2045 - Multipurpose Internet Mail Extensions (MIME)
Parte um: seção 6.8 do Formato dos Corpos de Mensagens da Internet.
Codificação e Transferencia de Conteúdo em Base64
O processo de codificação representa grupos de entrada de 24 bits
como strings de saída de 4 caracteres codificados. Da esquerda para
a direita, forma-se um grupo de entrada de 24 bits pela concatenação
de 3 grupos de entrada de 8 bits.
Esses 24 bits serão, então, tratados como 4 grupos concatenados
de 6 bits, cada um traduzido para um único digito do alfabeto da
base64. Ao codificar um fluxo de bits através da codificação para
base64, deve-se presumir que tal fluxo esteja ordenado com o bit mais
significante vindo primeiro.
Ou seja, o primeiro bit no fluxo será o mais relevante no primeiro
byte de
8 bits, o oitavo será o bit menos relevante no mesmo primeiro byte
de 8 bits,
e assim por diante.
*/
Conexões nada óbvias
A conexão entre um comentário e o código que ele descreve deve ser óbvia. Se for fazer um
comentário, então você deseja, pelo menos, que o leitor seja capaz de ler o comentário e o código
e, então, entender o que foi falado.
Considere, por exemplo, o comentário abaixo do Commons do Apache:
é
1*
* começa com um array grande o bastante para conter todos os
pixels
* (mais os bytes de filtragem) e 200 bytes extras para informações
no cabeçalho
*/
this.pngBytes = new byte[((this.width + 1) this.height * 3) + 200];
O que é um byte de filtragem? Ele tem a ver com o +1? Ou com o *3? Com ambos? Um pixel
um byte? Por que 200? O objetivo de um comentário é explicar o que o código não consegue
por si só. É uma lástima quando um comentário também precisa ser explicado.
Cabeçalhos de funções
Funções curtas não requerem muita explicação. Um nome bem selecionado para uma função
pequena que faça apenas uma coisa costuma ser melhor do que um comentário no cabeçalho.
Comentários Ruins 71
Javadocs em códigos não-públicos
Assim como os Javadocs são práticos para as APIs públicas, eles são uma maldição para o
código não voltado para a distribuição ao público. Gerar páginas Javadoc para classes e funções
dentro de um sistema geralmente não é prático, e a formalidade extra dos comentários javadocs
unem um pouco mais de entulhos e distração.
Exemplo
Na Listagem 4.7, criei um módulo para o primeiro XP Immersion para servir de exemplo de má
programação e estilo de comentário. Então, Kent Beck refatorou esse código para uma forma muito
mais agradável na presença de algumas dezenas de estudantes empolgados. Mais tarde, adaptei o
exemplo para meu livro Agile Software Development, Principles, Patterns, and Practices e o
primeiro de meus artigos da coluna Craftsman publicados na revista Software Development.
Para mim, o fascinante desse módulo é que havia uma época quando muitos de nós o teríamos
considerado "bem documentado". Agora o vemos como uma pequena bagunça. Veja quantos
problemas diferentes você consegue encontrar.
Listagem 4-7
GeneratePrimes.java
This class Generates prime numbers up to a user specified
maximum. The algorithm used is the Sieve of Eratosthenes.
* <p>
Eratosthenes of Cyrene, b. c. 276 BC, Cyrene, Libya --
d. c. 194, Alexandria. The first man to calculate the
circumference of the Earth. Also known for working on
calendars with leap years and ran the library at Alexandria.
<p>
The algorithm is quite simple. Given an array of integers
starting at 2. Cross cut all multiples of 2. Find the next
uncrossed integer, and cross out all of its multiples.
Repeat untilyou have passed the square root of the maximum
value.
@author Alphonse
@version 13 Feb 2002 atp
import java.util.*:
public class GeneratePrimes
*
@param maxValue is the generation limit.
public static int [] generatePrimes (int maxValue)
if (maxValue >= 2) // the only valid case
// declarations
int s = maxValue + 1; // size of array
boolean[] f = new boolean[s];
int i;
72
Listagem 4-7 (continuação)
GeneratePrimes.java
// initialize array to true.
for (i = 0; i < s; i++
f[i] = true;
// get rid of known non-primes
f[0] = f[l] = false;
!/ sieve
int j;
for (i = 2; i < Math.sqrt(s) + 1; i++)
if (f[i]) // if i is uncrossed, cross its multiples.
{
for (j = 2* i; j < s; j += 1)
f[j] = false; // multiple is not prime
}
}
// how many primes are there?
int count = 0;
for (i = 0; i < s; i++)
if (f[i]
count++; // bump count.
int[] primes = new int [count];
// move the primes into the result
for (i = 0, j = 0; i < s; 1++)
if {f[i])
primes[j++] = i;
// if prime
return primes: // return the primes
else // maxValue < 2
return new int [0]; // return null array if bad input.
}
Capítulo 4: Comentários
Na Listagem 4.8 pode-se ver uma versão refatorada do mesmo módulo. Note que o uso de
comentários foi limitado de forma significativa - há apenas dois no módulo inteiro, e ambos são
auto-explicativos.
Listagem 4.8:
PrimeGenerator.java (refatorado)
* This class Generates prime numbers up to a user specified
maximum. The algorithm used is the Sieve of Eratosthenes
* Given an array of integers starting at 2:
* Find the first uncrossed integer, and cross out all its
Comentários Ruins
Listagem 4-8 (continuação)
PrimeGenerator.java (refatorado)
multiples. Repeat until there are no more multiples
in the array.
public class PrimeGenerator
private static boolean[] crossedOut;
private static int[] result;
public static int[] generatePrimes(int maxValue)
if (maxValue < 2)
return new int [0]:
else
uncrossIntegersUpTo imaxValue);
crossoutMultiplesi);
putUncrossedIntegersIntoResult();
return result;
private static void uncrossIntegersUpTo(int maxValue)
crossedOut = new boolean [maxValue + 1];
for (int i = 2; i < crossedOut.length; i++)
crossedOut[i] = false;
private static void crossOutMultiples()
int limit = determineIterationLimit();
for (inti = 2; i <= limit; i++)
if (notCrossed(i))
crossOutMultiplesOf(i);
private static int determineIterationLimit()
}
1
11
Every multiple in the array has a prime factor that
is less than or equal to the root of the array size,
so we don't have to cross out multiples of numbers
larger than that root.
double iterationLimit = Math.sqrt (crossedOut.length);
return (int) iterationLimit;
private static void crossOutMultiplesOf(int i)
for (int multiple = 2*i;
multiple < crossedOut.length;
multiple += i)
crossedout [multiple] = true;
73
74
Listagem 4-8 (continuação) PrimeGenerator.java (refatorado)
private static boolean notCrossed(int i)
return crossedOut[i] == false;
}
private static void putUncrossedIntegersIntoResult()
result = new int [numberOfUncrossedIntegers()l;
for (int j= 0, i = 2; i < crossedOut.length; i++)
if (notCrossed(i))
result[j++] = i;
private static int numberOfUncrossedIntegers()
{
int count = 0;
for (int i = 2; i < crossedOut.length; i++)
if (notCrossed())
count++:
return count;
Capítulo 4: Comentários
Como o primeiro comentário é muito parecido com a função generatePrimes, fica fácil dizer
que ele é redundante. Mesmo assim, acho que o comentário serve para facilitar a leitura do
algoritmo, portanto prefiro mantê-lo.
Já o segundo se faz praticamente necessário. Ele explica a lógica por trás do uso da raiz
quadrada como o limite da iteração. Não consegui encontrar um nome simples para a variável
ou qualquer estrutura diferente de programação que esclarecesse esse ponto. Por outro lado,
uso da raiz quadrada poderia ser um conceito. Realmente estou economizando tanto tempo
assim ao limitar a iteração à raiz quadrada? O cálculo desta demora mais do que o tempo que
economizo?
이
Vale a pena ponderar. Usar a raiz quadrada como o limite da iteração satisfaz o hacker em
mim que usa a antiga linguagem C e Assembly, mas não estou convencido de que compense o
tempo e o esforço que todos gastariam para entendê-la.
Bibliografia
[KP78]: Kernighan and Plaugher, The Elements of Programming Style, 2d. ed., McGrawHill, 1978.
5
Formatação
Quando as pessoas olham o código, desejamos que fiquem impressionadas com a polidez, a
consistência e a atenção aos detalhes presentes. Queremos que reparem na organização.
Desejamos que suas sobrancelhas se levantem ao percorrerem os módulos; que percebam que
foram profissionais que estiveram ali. Se, em vez disso, virem um emaranhado de código como
76 Capítulo 5: Formatação
se tivesse sido escrito por um bando de marinheiros bêbados, então provavelmente concluirão
que essa mesma falta de atenção foi perpetuada por todo o projeto.
Você deve tomar conta para que seu código fique bem formatado, escolher uma série de regras
simples que governem seu código e, então, aplicá-la de forma consistente. Se estiver trabalhando
em equipe, então, todos devem concordar com uma única série de regras de formatação. Seria
bom ter uma ferramenta automatizada que possa aplicar essas regras para você.
O objetivo da formatação
Primeiro de tudo, sejamos claros. A formatação do código é importante. Importante demais para
se ignorar e importante demais para ser tratada religiosamente. Ela serve como uma comunicação,
e essa é a primeira regra nos negócios de um desenvolvedor profissional.
Talvez você pensasse que "fazer funcionar" fosse a primeira regra. Espero, contudo, que, a
esta altura, este livro já tenha tirado esse conceito de sua mente. A funcionalidade que você cria
hoje tem grandes chances de ser modificada na próxima distribuição, mas a legibilidade de seu
código terá um grande efeito em todas as mudanças que serão feitas. A formatação do código
e a legibilidade anteriores que continuam a afetar a capacidade de extensão e de manutenção
tempos após o código original foram alteradas além de reconhecimento. Seu estilo e disciplina
sobrevivem, mesmo que seu código não.
Então quais as questões sobre formatação que nos ajuda a comunicar melhor?
Formatação vertical
Comecemos com o tamanho vertical. O seu código-fonte deve ser de que tamanho? Em Java, o
tamanho do arquivo está intimamente relacionado ao da classe. Discutiremos sobre o tamanho das
classes quando falarmos sobre classes. Mas, por agora, consideremos apenas o tamanho do arquivo.
Qual o tamanho da maioria dos códigos-fonte em Java? Há uma grande diversidade de
tamanhos e algumas diferenças notáveis em estilo (veja a Figura 5.1). Há sete projetos diferentes
na figura: Junit, FitNesse, testNG, Time and Money, JDepend, Ant e Tomcat. As linhas verticais
mostram os comprimentos mínimo e máximo em cada projeto. A caixa exibe aproximadamente
um terço (um desvio padrão') dos arquivos. O meio da caixa é a média. Portanto, o tamanho
médio do código no projeto FitNesse é de cerca de 65 linhas, e cerca de um terço dos arquivos
estão entre 40 e 100+ linhas. O maior arquivo no FitNesse tem aproximadamente 400 linhas,
o menor 6.
Note que essa é uma escala logarítmica; portanto, a pequena diferença na posição vertical
indica uma diferença muito grande para o tamanho absoluto.
e
Junit, FitNesse e Time and Money são compostos de arquivos relativamente pequenos.
Nenhum ultrapassa 500 linhas e a maioria dos arquivos tem menos de 200 linhas. Tomcat e
Ant, por outro lado, têm alguns arquivos com milhares de linhas e outros, próximos à metade,
ultrapassam 200 linhas.
O que isso nos diz? Parece ser possível construir sistemas significativos (o FitNesse tem
quase 50.000 linhas) a partir de códigos simples de 200 linhas, com um limite máximo de 500.
Embora essa não deva ser uma regra fixa, deve-se considerá-la bastante, pois arquivos pequenos
costumam ser mais fáceis de se entender do que os grandes.
sigma? acin
Formatação Vertical
A metáfora do jornal
77
Pense num artigo de jornal bem redigido. Você o lê verticalmente. No topo você espera ver
uma manchete que lhe diz do que se trata a estória e lhe permite decidir se deseja ou não ler. O
primeiro parágrafo apresenta uma sinopse da estória toda, omitindo todos os detalhes, falando de
uma maneira mais geral. Ao prosseguir a leitura, verticalmente, vão surgindo mais detalhes até
que datas, nomes, citações, alegações e outras minúcias sejam apresentadas.
Desejamos que um código fonte seja como um artigo de jornal. O nome deve ser simples
mas descritivo. O nome em si deve ser o suficiente para nos dizer se estamos no módulo certo ou
não. As partes mais superiores do código-fonte devem oferecer os conceitos e algoritmos de alto
nível. Os detalhes devem ir surgindo conforme se move para baixo, até encontrarmos os detalhes
e as funções de baixo nível no código-fonte.
10000.0
Lines per file
1000.0
100.0
10.0
1.0
junit fitnesse testNG tam jdepend ant tomcat
Figura 5.1:
Escala logarítmica de distribuição de tamanho de arquivos (altura da caixa = sigma)
Um jornal é composto de muitos artigos; a maioria é bastante pequena. Alguns são um
pouco maiores. Muito poucos possuem textos que preencham a página toda. Isso torna o jornal
aproveitável. Se ele fosse apenas uma estória extensa com uma aglomeração desorganizada de
fatos, datas e nomes, nós simplesmente não o leríamos.
Espaçamento vertical entre conceitos
Quase todo código é lido da esquerda para a direita e de cima para baixo. Cada linha representa
uma expressão ou uma estrutura, e cada grupo de linhas representa um pensamento completo.
Esses pensamentos devem ficar separados por linhas em branco.
Considere, por exemplo, a Listagem 5.1. Há linhas em branco que separam a declaraçãoe a
importação do pacote e cada uma das funções. Essa simples e extrema regra tem grande impacto
no layout visual do código. Cada linha em branco indica visualmente a separação entre conceitos.
Ao descer pelo código, seus olhos param na primeira linha após uma em branco.
78 Capítulo 5: Formatação
Retirar essas linhas em branco, como na Listagem 5.2, gera um efeito notavelmente obscuro
na legibilidade do código.
Listagem 5-2
BoldWidget.java
package fitnesse.wikitext.widgets;
import java.util.regex.*:
public class BoldWidget extends ParentWidget {
public static final String REGEXP = "";
private static final Pattern pattern = Pattern.compile("'"*(+?)*",
Pattern.MULTILINE + Pattern.DOTALL);
public BoldWidget (ParentWidget parent, String text) throws Exception {
super (parent):
Matcher match = pattern.matcher (text);
match.find();
addChildWidgets (match.group(1));}
public String render() throws Exception {
StringBuffer html = new StringBuffer("<b>");
html.append(childHtml()).append("</b>");
return html.toString();
Esse efeito é ainda mais realçado quando você desvia seus olhos do código. No primeiro
exemplo, os diferentes agrupamentos de linhas saltam aos olhos, enquanto no segundo tudo fica
meio confuso. A diferença entre essas duas listagens é um pouco de espaçamento vertical.
Continuidade vertical
Se o espaçamento separa conceitos, então a continuidade vertical indica uma associação íntima.
Assim, linhas de código que estão intimamente relacionadas devem aparecer verticalmente
unidas. Note como os comentários inúteis na Listagem 5.3 quebram essa intimidade entre a
instância de duas variáveis.
Listagem 5.3
public class ReporterConfig {
1**
* The class name of the reporter listener
*
private String m_className;
* The properties of the reporter listener
*
private List<Property> m_properties = new ArrayList<Property> ();
public void addProperty (Property property) m_properties.add(property):
}
Formatação Vertical 79
A Listagem 5.4 está muito mais fácil de se ler. Ela cabe numa única visão, pelo menos para
mim. Posso olhá-la e ver que é uma classe com duas variáveis e um método, sem ter de mover
muito minha cabeça ou meus olhos. A listagem anterior me faz usar mais o movimento dos olhos
e da cabeça para obter o mesmo nível de entendimento.
Listagem 5.4
public class ReporterConfig {
private String m_className;
private List<Property> m_properties = new ArrayList<Property>();
public void addProperty (Property property) {
m_properties.add(property);
Distância vertical
e
Já ficou tentando se encontrar numa classe, passando de uma função para a próxima, subindo
descendo pelo código-fonte, tentando adivinhar como as funções se relacionam e operam, só para
se perder nesse labirinto de confusão? Já subiu pela estrutura de herança buscando a definição de
uma variável ou função? Isso é frustrante, pois você está tentando entender o que o sistema faz,
enquanto gasta tempo e energia mental numa tentativa de localizar e lembra onde estão as peças.
Os conceitos intimamente relacionados devem ficar juntos verticalmente [G10].
Obviamente essa regra não funciona para conceitos em arquivos separados. Mas, então, não
se devem separar em arquivos distintos conceitos intimamente relacionados, a menos que tenha
uma razão muito boa. Na verdade, esse é um dos motivos por que se devem evitar variáveis
protegidas. Para os conceitos que são tão intimamente relacionados e que estão no mesmo
arquivo-fonte, a separação vertical deles deve ser uma medida do quão importante eles são para
a inteligibilidade um do outro. Queremos evitar que nossos leitores tenham de ficar visualizando
vários dos nossos arquivos-fonte e classes.
Declaração de variáveis. Devem-se declarar as variáveis o mais próximo possível de onde
serão usadas.
Como nossas funções são muito pequenas, as variáveis locais devem ficar no topo de cada
função, como mostraa função razoavelmente longa abaixo do Junit4.3.1.
private static void readPreferences()
InputStream is= null;
try {
{
is= new FileInputStream(getPreferencesFile());
setPreferences (new Properties(getPreferences()));
getPreferences().load(is);
} catch (IOException e) }
try {
if (is != null)
is.close();
} catch (IOException el)}
}
}
80 Capítulo 5: Formatação
Geralmente, devem-se declarar as variáveis de controle para loops dentro da estrutura de iteração,
como mostra essa pequenina função da mesma fonte acima.
public int countTestCases() {
int count= 0;
for (Test each: tests)
count += each.countTestCases();
return count;
}
Em raros casos pode-se declarar uma variável no início de um bloco ou logo depois de um
loop em uma função razoavelmente longa. Veja um exemplo no pedacinho abaixo de uma função
muito extensa do TestNG.
for (XmlTest test : m_suite.getTests())
TestRunner tr = m_runnerFactory.newTestRunner(this, test);
tr.addListener(m_textReporter);
m_testRunners.add(tr);
invoker = tr.getInvoker();
for (ITestNGMethod m: tr.getBeforeSuiteMethods())
beforeSuiteMethods.put(m.getMethod(), m);
}
for (ITestNGMethod m: tr.getAfterSuiteMethods())
afterSuiteMethods.put(m.getMethod(), m);
}
}
Instâncias de variáveis. Por outro lado, devem-se declarar as instâncias de variáveis no início da
classe. Isso não deve aumentar a distância vertical entre tais variáveis, pois, numa classe bem
projetada, elas são usadas por muitos, senão todos, os métodos da classe.
a Muito já se discutiu sobre onde devem ficar as instâncias de variáveis. Em C++ é comum
regra da tesoura, na qual colocamos todas as instâncias das variáveis no final. Em java, contudo,
a convenção é colocá-las no início da classe.
Não vejo motivo para seguir uma ou outra convenção. O importante é que as instâncias de
variáveis sejam declaradas em um local bem conhecido. Todos devem saber onde buscar as
declarações.
Considere, por exemplo, o estranho caso da classe TestSuite no JUnit 4.3.1. Resumi
bastante essa classe para mostrar a questão. Se você ler até cerca de metade do código, verá
duas instâncias de variáveis declaradas. Seria dificil ocultá-las num lugar melhor. Quem ler este
código se depararia por acaso com as declarações (como ocorreu comigo).
public class TestSuite implements Test {
static public Test createTest (Class<? extends TestCase>
Formatação Vertical
theClass,
String name) {
public static Constructor<? extends TestCase>
getTestConstructor(Class<? extends TestCase> theClass)
throws NoSuchMethodException {
}
public static Test warning(final String message) {
private static String exceptionToString (Throwable t) {
private String fName;
private Vector<Test> fTests= new Vector<Test>(10);
public TestSuite() {
}
public TestSuite(final Class<? extends TestCase> theClass)
public TestSuite(Class<? extends TestCase> theClass, String
name) {
}
81
Funções dependentes. Se uma função chama outra, elas devem ficar verticalmente próximas,
e a que chamar deve ficar acima da que for chamada, se possível. Isso dá um fluxo natural ao
programa. Se essa convenção for seguida a fim de legibilidade, os leitores poderão confiar que
as declarações daquelas funções virão logo em seguida após seu uso. Considere, por exemplo,
o fragmento do FitNesse na Listagem 5.5. Note como a função mais superior chama as outras
abaixo dela e como elas, por sua vez, chama aquelas abaixo delas também. Isso facilita encontrar
as funções chamadas e aumenta consideravelmente a legibilidade de todo o módulo.
82 Capítulo 5: Formatação
Listagem 5-5
WikiPageResponder.java
public class WikiPageResponder implements SecureResponder
protected WikiPage page;
protected PageData pageData; protected String pageTitle;
protected Request request; protected PageCrawler crawler;
public Response makeResponse (FitNesseContext context, Request request)
throws Exception {
String pageName = get PageNameOrDefault(request, "FrontPage");
loadPage pageName, contextl;
if (page == null)
return not FoundResponse (context, request);
else
return makePageResponse (context);
}
private String getPageNameOrDefault (Request request, String defaultPageName)
}
String pageName = request.getResource();
if (StringUtil.isBlank (pageName))
pageName = defaultPageName;
return pageName;
protected void loadPage (String resource, FitNesseContext context)
throws Exception {
WikiPagePath path = PathParser.parse (resourcе);
crawler = context.root.getPageCrawler();
crawler.set DeadEndStrategy(new VirtualEnabledPageCrawler());
page = crawler.getPage (context.root, path);
if (page != null)
pageData = page.getData();
private Response not FoundResponse (FitNesseContext context, Request request)
throws Exception {
return new Not FoundResponder().makeResponse (context, request);
}
private SimpleResponse makePageResponse (FitNesseContext context)
throws Exception {
pageTitle = PathParser.render (crawler.getFullPath (page))
String html = makeHtml (context);
SimpleResponse response = new SimpleResponse();
response.setMaxAge(0);
response.setContent (html);
return response:
}
Formatação Horizontal 83
Além disso, esse fragmento apresenta um bom exemplo de como manter as constantes
no nível apropriado [G35]. A constante "FrontPage" poderia ter sido colocada na função
getPageNameOrDefault, mas isso teria ocultado uma constante bem conhecida e esperada em
uma função de baixo nível. Foi melhor passar tal constante a partir do local no qual ela faz
sentido para um onde ela realmente é usada.
Afinidade conceitual. Determinados bits de código
querem ficar perto de outros bits. Eles possuem uma certa
afinidade conceitual. Quanto maior essa afinidade, menor
deve ser a distância vertical entre eles.
Como vimos, essa afinidade deve basear-se numa
dependência direta, como uma função chamando outra ou
uma função usando uma variável. Mas há outras causas
possíveis de afinidade, que pode ser causada por um grupo
de funções que efetuam uma operação parecida. Considere
o pedaço de código abaixo do JUnit 4.3.1:
public class Assert {
static public void assertTrue(String
message, boolean condition) {
}
if (!condition)
fail(message);
static public void assertTrue(boolean condition)
assertTrue(null, condition);
{
static public void assertFalse(String message, boolean
condition) {
assertTrue(message, !condition);
static public void assertFalse(boolean condition)
assertFalse(null, condition);
{
}
Essas funções possuem uma afinidade conceitual forte, pois compartilham de uma mesma
convenção de nomes e efetuam variações de uma mesma tarefa básica. O fato de uma chamar a
outra é secundário. Mesmo se não o fizessem, ainda iriam querer ficar próximas.
Ordenação vertical
De modo geral, desejamos que as chamadas das dependências da função apontem para baixo.
Isto é, a função chamada deve ficar embaixo da que a chama². Isso cria um fluxo natural para
baixo no módulo do código-fonte, de um nível maior para um menor.
Assim como nos artigos de jornais, esperamos que a maioria dos conceitos venha primeiro, e
também que seja expressada com uma quantidade mínima de detalhes. Esperamos que os detalhes
84 Capítulo 5: Formatação
de baixo nível venham por último. Isso nos permite passar os olhos nos arquivos-fonte e obter
uma idéia de algumas das primeiras funções, sem ter de mergulhar nos detalhes. A Listagem 5.5
está organizada dessa forma. Talvez os exemplos da Listagem 15.5 (p. 263) e 3.7 (p. 50) estejam
ainda melhores.
Isso é exatamente o oposto de linguagens, como Pascal, Ce C++, que exigem a definição das
funções, ou pelo menos a declaração, antes de serem usadas.
Formatação horizontal
Qual deve ser o tamanho de uma linha? Para responder isso, vejamos como ocorre em
programas comuns.
1
Novamente, examinemos sete projetos diferentes. A Figura 5.2 mostra a distribuição do
comprimento das linhas em todos os sete projetos. A regularidade é impressionante, cada linha
fica com cerca de 45 caracteres. De fato, todo comprimento de 20 a 60 representa cerca de
por cento do número total de linhas. Isso são 40%! Talvez outros 30 por cento possuam menos
do que 10 caracteres. Lembre-se de que é uma escala logarítmica, portanto a aparência linear
do declínio gradual acima de 80 caracteres é realmente muito significante. Os programadores
claramente preferem linhas curtas.
Isso sugere que devemos nos esforçar para manter nossas linhas curtas. O antigo limite de 80
de Hollerith é um pouco arbitrário, e não sou contra linhas com 100 ou mesmo 120 caracteres.
Mas ultrapassar isso provavelmente é apenas falta de cuidado.
100.0000%
Número de linhas
10.0000%
1.0000%
0.1000
0.0100%
0.0010%
0.0001%
0.0000%
이 10 20 30 40 50 60 70 80 90 100 110 120 130 140 150
Largura da linhа
Figura 5.2:
Distribuição da largura da linha em Java
Eu costumava seguir a regra na qual jamais se deve ter de rolar a tela para a direita. Mas, hoje
em dia, os monitores estão muito largos para isso, e programadores mais jovens também podem
diminuir a fonte de modo que 200 caracteres caibam na tela. Não faça isso. Eu, pessoalmente,
determinei 120 como meu limite.
Formatação Horizontal
Espaçamento e continuidade horizontal
85
Usamos o espaço em branco horizontal para associar coisas que estão intimamente relacionadas
e para desassociar outras fracamente relacionadas. Considere a função seguinte:
private void measureLine(String line) {
lineCount++;
int lineSize = line.length();
totalChars += lineSize;
lineWidthHistogram.addLine(lineSize, lineCount);
recordWidestLine(lineSize);
}
Coloquei os operadores de atribuição entre espaços em branco para destacá-los. As instruções
de atribuição têm dois elementos principais e distintos: os lados esquerdo e direito. Os espaços
tornam essa separação óbvia.
Poroutro lado, não coloque espaços entre os nomes das funções e os parênteses de abertura. Isso
porque a função e seus parâmetros estão intimamente relacionados. Separá-los iria fazer com que
parecesse que não estão juntos. Eu separo os parâmetros entre parênteses na chamada da função
para realçar a vírgula e mostrar que eles estão separados.
Outro uso do espaço em branco é para destacar a prioridade dos operadores.
public class Quadratic {
public static double rootl(double a, double b, double c)
double determinant = determinant(a, b, c);
return (-b + Math.sqrt(determinant)) / (2*a);
}
public static double root2(int a, int b, int c) }
double determinant = determinant(a, b, с);
}
return (-b Math.sqrt(determinant)) / (2*a);
{
private static double determinant (double a, double b, double с)
return b*b - 4*a*c;
}
Note como é fácil ler as equações. Os fatores não possuem espaços em branco entre eles
porque eles têm maior prioridade. Os termos são separados por espaços em branco porque a
adição e a subtração têm menor prioridade.
Infelizmente, a maioria das ferramentas para reformatação de código não faz essa distinção
entre operadores e usam o mesmo espaçamento para todos. Portanto, costuma-se perder
espaçamentos sutis como os acima na hora da reformatação do código.
86 Capítulo 5: Formatação
Alinhamento horizontal
Quando eu era programador em assembly,eu usava o alinhamento horizontal para realçar certas
estruturas. Quando comecei a programar em C, C++ e, depois, em Java, continuei a tentar alinhar
todos os nomes das variáveis numa série de declarações, ou todos os valores numa série de
instruções de atribuição. Meu código ficava assim:
public class FitNesseExpediter implements ResponseSender
{
private Socket socket;
private InputStream input;
private OutputStream output;
private Request request;
private Response response;
private FitNesseContext context;
protected long requestParsingTimeLimit;
private long requestProgress;
private long requestParsingDeadline;
private boolean hasError;
public FitNesseExpediter(Socket s,
FitNesseContext context) throws Exception
}
this.context = context;
socket = s;
input = s.getInputStream();
output = s.getOutputStream();
requestParsingTimeLimit = 10000;
Entretanto, descobri que esse tipo de alinhamento não é prático. Ele parece enfatizar as coisas
erradas e afasta meus olhos do propósito real. Por exemplo, na lista de declarações acima, você
fica tentado a ler todos os nomes das variáveis sem se preocupar com seus tipos. Da mesma
forma, na lista de atribuições, você se sente tentado a ler toda a lista de valores, sem se preocupar
em ver o operador de atribuição. Para piorar as coisas, as ferramentas de reformatação automática
geralmente eliminam esse tipo de alinhamento.
Portanto, acabei não fazendo mais esse tipo de coisa. Atualmente, prefiro declarações e
atribuições não alinhadas, como mostrado abaixo, pois eles destacam uma deficiência importante.
Se eu tiver listas longas que precisem ser alinhadas, o problema está no tamanho das listas, e
não na falta de alinhamento. O comprimento da lista de declarações na FitNesseExpediter
abaixo sugere que essa classe deva ser dividida.
public class FitNesseExpediter implements ResponseSender
{
private Socket socket;
private InputStream input;
private OutputStream output;
private Request request;
Formatação Horizontal 87
Quem estou tentanto enganar? Ainda sou um programador em assembly. Pode-se afastar o
programador da linguagem, mas não se pode afastar a linguagem do programador!
private Response response;
private FitNesseContext context;
protected long requestParsingTimeLimit;
private long requestProgress;
private long requestParsingDeadline;
private boolean hasError;
public FitNesseExpediter(Socket s, FitNesseContext context) throws
Exception
{
}
this.context = context;
socket = s;
input = s.getInputStream();
output = s.getOutputStream();
requestParsingTimeLimit = 10000;
Endentação
Um arquivo-fonte é mais como uma hierarquia do que algo esquematizado. Há informações
pertinentes ao arquivo como um todo, às classes individuais dentro do arquivo, aos métodos
dentro das classes, aos blocos dentro dos métodos e, recursivamente, aos blocos dentro de
blocos. Cada nível dessa hierarquia é um escopo no qual se podem declarar nomes e no qual são
interpretadas declarações e instruções executáveis.
A fim de tornar visível a hierarquia desses escopos, endentamos as linhas do código-fonte
de acordo com sua posição na hierarquia. Instruções no nível do arquivo, como a maioria das
declarações de classes, não são endentadas. Métodos dentro de uma classe são endentados
um nível à direita dela. Implementações do método são implementadas um nível à direita da
declaração do método. Implementações de blocos são implementadas um nível à direita do bloco
que as contém, e assim por diante.
Os programadores dependem bastante desse esquema de endentação. Eles alinham visualmente
na esquerda as linhas para ver em qual escopo elas estão. Isso lhes permite pular escopos,
como de implementações de estruturas if e while, que não são relevantes no momento. Eles
procuram na esquerda por novas declarações de métodos, novas variáveis e até novas classes.
Sem a endentação, os programas seriam praticamente ininteligíveis para humanos.
Considere os programas seguintes sintática e semanticamente idênticos:
public class FitNesseServer implements SocketServer { private
FitNesseContext
context; public FitNesseServer(FitNesseContext context) { this.context =
context; ) public void serve (Socket s) { serve(s, 10000); } public void
serve(Socket s, long requestTimeout) { try { FitNesseExpediter sender =
new
FitNesseExpediter(s, context); sender.setRequestParsingTimeLimit(requestTimeout); sender.start(); }
catch(Exception e) { e.printStackTrace(); {}}
88
public class FitNesseServer implements SocketServer
private FitNesseContext context;
{
public FitNesseServer(FitNesseContext context) {
this.context = context;
public void serve (Socket s) {
serve(s, 10000);
Capítulo 5: Formatação
}
public void serve(Socket s, long requestTimeout) {
try {
FitNesseExpediter sender = new FitNesseExpediter(s,
context);
sender.setRequestParsingTimeLimit(requestTimeout); sender.start();
}
catch (Exception e) {
e.printStackTrace():
}
}
}
Seus olhos conseguem discernir rapidamente a estrutura do arquivo endentado. Quase
instantaneamente você localiza as variáveis, os construtores, os métodos acessores (leitura e
escrita, ou setter and getter) e os métodos. Bastam alguns segundos para perceber que se trata
de um tipo simples de interface pra um socket, com um tempo limite. A versão sem endentação,
contudo, é praticamente incompreensível sem um estudo mais profundo.
Ignorando a endentação. As vezes, ficamos tentados a não usar a endentação em estruturas i f curtas,
loops while pequenos ou funções pequenas. Sempre que não resisto a essa tentação, quase sempre
acabo voltando e endentando tais partes. Portanto, evito alinhar uniformemente escopos como este:
public class CommentWidget extends TextWidget
{
public static final String REGEXP = "^#[^\r\n]*(?:(?:\r\n)|\n[\r)?";
public CommentWidget(ParentWidget parent, String text)(super(parent,
text);}
public String render() throws Exception {return ""; }
}
Prefiro expandir e endentar escopos, como este:
public class CommentWidget extends TextWidget {
public static final String REGEXP = "^#[^\r\n]*(?: (?:\r\n)\n\r)?";
public CommentWidget(ParentWidget parent, String text)
super(parent, text);
}
}
Regras de formatação do Uncle Bob
}
public String render() throws Exception {
return""
89
Escopos minúsculos
De vez em quando, o corpo de uma estrutura while ou for é minúscula, como mostra abaixo.
Como não gosto disso, procuro evitá-las. Quando isso não for possível, verifico se o corpo da
estrutura está endentado adequadamente e entre parênteses. Inúmeras vezes já me enganei com
um ponto-e-vírgula quietinho lá no final de um loop while na mesma linha. A menos que você
torne esse ponto-e-vírgula visível endentando-o em sua própria linha, fica difícil visualizá-lo.
while (dis.read(buf, 0, readBufferSize) != -1)
Regra de equipes
O título desse tópico faz um jogo com as
palavras. Todo programador tem suas regras de
formatação prediletas, mas se ele for trabalhar
em equipe, as regras são dela. Uma equipe de
desenvolvedores deve escolher um único estilo
de formatação, e, então, todos os membros
devem usá-lo. Desejamos que o software tenha
um estilo consistente. Não queremos que pensem
que o código foi escrito por um bando de pessoas em desacordo.
Quando entrei no projeto FitNesse em 2002, sentei com a equipe para escolher um estilo de
programação. Isso levou 10 minutos. Decidimos onde colocaríamos nossas chaves, o tamanho
da endentação, como nomearíamos as classes, variáveis e métodos, e assim por diante. Então,
codificamos essas regras no formatador de código de nossa IDE e ficamos com ela desde então.
Não eram as regras que eu preferia, mas as que foram decididas pela equipe. E como membro,
tive seguí-las na hora de programar no projeto FitNesse.
Lembre-se: um bom sistema de software é composto de uma série de documentos de fácil leitura.
Eles precisam ter um estilo consistente e sutil. O leitor precisa poder confiar que as formatações
que ele vir em um arquivo-fonte terão o mesmo significado nos outros. A última coisa que
queremos é adicionar mais complexidade ao código-fonte programando-o com um monte de
estilos diferentes.
Regras de formatação do Uncle Bob
As regras que uso são muito simples e estão ilustradas no código da Listagem 5.6.
Considere isso um exemplo de como o código é o melhor documento padrão em programação.
90
Listagem 5-6
CodeAnalyzer.java
public class CodeAnalyzer implements JavaFileAnalysis
private int lineCount;
private int maxLineWidth;
private int widestLineNumber:
private LineWidthHistogram lineWidthHistogram;
private int totalChars;
public CodeAnalyzer() {
lineWidthHistogram = new LineWidthHistogram();
}
Capítulo 5: Formatação
public static List<File> findJavaFiles (File parentDirectory) {
List<File> files = new ArrayList<File> ();
findJavaFiles (parentDirectory, files);
return files;
private static void findJavaFiles(File parentDirectory, List<File> files)
for (File file: parent Directory.listFiles()( }
}
if (file.getName().endsWith(".java"))
files.add(file);:
else if (file.isDirectory ())
findJavaFiles(file, files);:
public void analyzeFile(File javaFile) throws Exception {
BufferedReader br = new BufferedReader (new FileReader (javaFile}):
String line;
}
while {(line = br.readLine()) != null)
measureLine (line):
private void measureLine(String line) {
lineCount++:
int lineSize = line.length();
totalChars += lineSize;
lineWidthHistogram.addLine(lineSize, lineCount);
recordwidestLine(lineSize):
Regras de formatação do Uncle Bob
Listagem 5-6 (continuação)
CodeAnalyzer.java
private void recordwidestLine(int lineSize)
if (lineSize > maxLineWidth) {
maxLinewidth = lineSize;
widestLineNumber = lineCount;
{
}
public int getLineCount () {
return lineCount;
public int getMaxLineWidth() {
return maxLineWidth;
public int getWidestLineNumber() {
return widestLineNumber:
}
public LinewidthHistogram getLineWidthHistogram() {
return lineWidthHistogram
public double getMeanLineWidth() {
return (double) totalChars/lineCount;
public int getMedianLineWidth() {
Integer[] sortedWidths = getSortedWidths();
int cumulativeLineCount = 0;
for (int width: sortedWidths) {
cumulativeLineCount += lineCountForWidth(width);
}
}
if (cumulativeLineCount > lineCount/2)
return width;
throw new Error ("Cannot get here");
private int lineCount ForWidth(int width) {
return linewidthHistogram.getLinesforwidth(width).size();
private Integer[] getSortedWidths() {
Set<Integer> widths = linewidthHistogram.getWidths();
Integer[] sortedWidths = (widths.toArray (new Integer [0]));
Arrays.sort (sortedwidths);
return sortedWidths;
91
6
Objetos e Estruturas de Dados
Há um motivo para declararmos nossas variáveis como privadas. Não queremos que ninguém
dependa delas. Desejamos ter a liberdade para alterar o tipo ou a implementação, seja por
capricho ou impulso. Por que, então, tantos programadores adicionam automaticamente métodos
de acesso (escrita, ou setters, e leitura, ou getters) em seus objetos, expondo suas variáveis
privadas como se fossem públicas?
Abstração de dados
Considere a diferença entre as listagens 6.1 e 6.2. Ambas representam os dados de um ponto no
plano cartesiano. Um expõe sua implementação e o outro a esconde completamente.
94
Listagem 6-1
Caso concreto
public class Point
public double x;
public double y:
}
Capítulo 6: Objetos e Estruturas de Dados
Listagem 6-2
Caso abstrato
public interface Point {
double getX();
double getY();
void setCartesian(double x, double y);
double getR();
double getTheta():
void setPolar (double r, double theta);
O belo da Listagem 6.2 é que não há como dizer se a implementação possui coordenadas
retangulares ou polares. Pode não ser nenhuma! E ainda assim a interface representa de modo
claro uma estrutura de dados.
Mas ela faz mais do que isso. Os métodos exigem uma regra de acesso. Você pode ler as coordenadas
individuais independentemente, mas deve configurá-las juntas como uma operação atômica.
A Listagem 6.1, por outro lado, claramente está implementada em coordenadas retangulares,
e nos obriga a manipulá-las independentemente. Isso expõe a implementação. De fato, ela seria
exposta mesmo se as variáveis fossem privadas e estivéssemos usando métodos únicos de escrita
e leitura de variáveis.
Ocultar a implementação não é só uma questão de colocar uma camada de funções entre
as variáveis. E uma questão de ! Uma classe não passa suas variáveis simplesmente por meio
de métodos de escrita e leitura. Em vez disso, ela expõe interfaces abstratas que permite aos
usuários manipular a essência dos dados, sem precisar conhecer a implementação.
Considere as listagens 6.3 e 6.4. A primeira usa termos concretos para comunicar o nivel de
combustível de um veículo, enquanto a segunda faz o mesmo, só que usando. No caso concreto,
você tem certeza de que ali estão apenas métodos acessores (escrita e leitura, ou getter e setter)
de variáveis. No caso abstrato, não há como saber o tipo dos dados.
Listagem 6-3
Veículo concreto
public interface Vehicle {
double getFuelTankCapacityInGallons();
double getGallonsOfGasoline();
}
Anti-simetria data/objeto
Listagem 6-4
Veículo abstrato
public interface Vehicle {
double getPercentFuelRemaining(};
}
95
Em ambos os casos acima, o segundo é preferível. Não queremos expor os detalhes de nossos
dados. Queremos expressar nossos dados de forma abstrata. Isso não se consegue meramente
através de interfaces e/ou métodos de escrita e leitura. É preciso pensar bastante na melhor
maneira de representar os dados que um objeto contenha. A pior opção é adicionar levianamente
métodos de escrita e leitura.
Anti-simetria data/objeto
Esses dois exemplos mostram a diferença entre objetos e estruturas de dados. Os objetos usam
abstrações para esconder seus dados, e expõem as funções que operam em tais dados. As estruturas de
dados expõem seus dados e não possuem funções significativas. Leia este parágrafo novamente.
Note a natureza complementar das duas definições. Elas são praticamente opostas. Essa
diferença pode parecer trivial, mas possui grandes implicações.
Considere, por exemplo, a classe shape procedimental na Listagem 6.5. A classe Geometry
opera em três classes shape que são simples estruturas de dados sem qualquer atividade. Todas
as ações estão na classe Geometry.
Listagem 6-5
Classe shape procedimental
public class Square {
public Point topLeft;
public double side:
}
public class Rectangle {
public Point topLeft;
public double height;
public double width;
public class Circle {
public Point center;
public double radius;
public class Geometry {
public final double PI = 3.141592653589793;
public double area (Object shapel throws NoSuch:
if (shape instanceof Square) {
Square s = (Square) shape;
return s.side s.side;
}
96
Listagem 6-5 (continuação)
Classe shape procedimental
else if (shape instanceof Rectangle)
Rectangle r = (Rectangle) shape;
return r.height * r.width:
else if (shape instanceof Circle)
Circle c = (Circle) shape;
return PI *c.radius c.radius;
throw new NoSuchShapeException();
Capítulo 6: Objetos e Estruturas de Dados
Programadores de orientação a objeto talvez torçam o nariz e reclamem que isso é
procedimental e estão certos. Mas nem sempre. Imagine o que aconteceria se adicionássemos
uma função perimeter() à Geometry. As classes shape não seriam afetadas! Assim como
quaisquer outras classes que dependessem delas!
Por outro lado, se adicionarmos uma nova classe shape, teremos de alterar todas as funções em
Geometry. Leia essa frase novamente. Note que as duas situações são completamente opostas.
Agora, considere uma solução orientada a objeto na Listagem 6.6. O método área() é
polifórmico. Não é necessária a classe Geometry. Portanto, se eu adicionar uma nova forma,
nenhuma das funções existentes serão afetadas, mas se eu adicionar uma nova função, todas as
classes shape deverão ser alteradas¹.
Listagem 6-6
Classes shape polifórmicas
public class Square implements Shape
private Point topLeit;
private double side:
public double area() {
return side*side:
}
public class Rectangle implements Shape (
private Point topLeft;
private double height;
private double width:
public double area () {
return height * width;
1. Desenvolvedores orientados a objeto experiente conhecem outras maneiras de se contornar isso. O padrão Visitor, ou dual-dispatch. por exemplo.
A lei de Demeter
Listagem 6-6 (continuação)
Classes shape polifórmicas
public class Circle implements Shape
private Point center;
private double radius;
public final double PI = 3.141592653589793;
public double area() {
return PI * radius radius:
t
}
97
Novamente, vemos que a natureza complementar dessas duas definições: elas são praticamente
opostas! Isso expõe a dicotomia fundamental entre objetos e estruturas de dados:
O código procedimental (usado em estruturas de dados) facilita a adição de novas funções
sem precisar alterar as estruturas de dados existentes. O código orientado a objeto (OO), por
outro lado, facilita a adição de novas classes sem precisar alterar as funções existentes.
O inverso também é verdade:
O código procedimental dificulta a adição de novas estruturas de dados, pois todas as
funções teriam de ser alteradas. O código 00 dificulta a adição de novas funções, pois
todas as classes teriam de ser alteradas.
Portanto, o que é dificil para a OO é fácil para o procedimental, e o que é dificil para o
procedimental é fácil para a OO!
Em qualquer sistema complexo haverá vezes nas quais desejaremos adicionar novos tipos de
dados em vez de novas funções. Para esses casos, objetos e OO são mais apropriados. Por ouro
lado, também haverá vezes nas quais desejaremos adicionar novas funções em vez de tipos de
dados. Neste caso, estruturas de dados e código procedimental são mais adequados.
Programadores experientes sabem que a ideia de que tudo é um objeto é um mito. As vezes,
você realmente deseja estruturas de dados simples com procedimentos operando nelas.
A lei de Demeter
Há uma nova heurística muito conhecida chamada Lei de Demeter²: um módulo não deve enxergar
o interior dos objetos que ele manipula. Como vimos na seção anterior, os objetos escondem seus
dados e expõem as operações. Isso significa que um objeto não deve expor sua estrutura interna
por meio dos métodos acessores, pois isso seria expor, e não ocultar, sua estrutura interna.
Mais precisamente, a Lei de Demeter diz que um método f de uma classe C só deve chamar
os métodos de:
C
Um objeto criado por f
• Um objeto passado como parâmetro para f
• Um objeto dentro de uma instância da variável C
2 http://en.wikipedia.org/wiki/Law of Demeter
98 Capítulo 6: Objetos e Estruturas de Dados
O método não deve chamar os métodos em objetos retornados por qualquer outra das funções
permitidas. Em outras palavras, fale apenas com conhecidos, não com estranhos.
O código³ seguinte parece violar a Lei de Demeter (dentre outras coisas), pois ele chama a
função getScratchDir() no valor retornado de getOptions() e, então, chama getAbsolutePath() no
valor retornado de getScratchDir().
final String outputDir = ctxt.getOptions().getScratchDir().
getAbsolutePath();
Carrinhos de trem
Esse tipo de código costuma ser chamador de carrinho de trem, pois parece com um monte
de carrinhos de trem acoplados. Cadeias de chamadas como essa geralmente são consideradas
descuidadas e devem ser evitadas [G36]. Na maioria das vezes é melhor dividi-las assim:
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
Esses dois pedaços de código violam a
Lei de Demeter? Certamente módulo que os
contém sabe que o objeto etxt possui opções
(options), que contêm um diretório de rascunho
(scratchDir), que tem um caminho absoluto
(AbsolutePath). É muito conhecimento para
uma função saber. A função de chamada sabe
como navegar por muitos objetos diferentes.
Se isso é uma violação da Lei de Demeter depende se ctxt, Options e ScracthDir são
ou não objetos ou estruturas de dados. Se forem objetos, então sua estrutura interna deveria estar
oculta ao invés de exposta, portanto o conhecimento de seu interior é uma violação clara da lei.
Por outro lado, se forem apenas estruturas de dados sem atividades, então eles naturalmente
expõem suas estruturas internas, portanto aqui não se aplica a lei.
O uso de funções de acesso confunde essas questões. Se o código tiver sido escrito como
abaixo, então provavelmente não estaríamos perguntando sobre cumprimento ou não da lei.
final String outputDir = ctxt.options.scratchDir.absolutePath;
Essa questão seria bem menos confusa se as estruturas de dados simplesmente tivessem
variáveis públicas e nenhuma função, enquanto os objetos tivessem apenas variáveis privadas e
funções públicas. Entretanto, há frameworks e padrões (e.g., "beans") que exigem que mesmo
estruturas de dados simples tenham métodos acessores e de alteração.
3. Está em algum lugar no framework do Apache
A lei de Demeter 99
Híbridos
De vez em quando, essa confusão leva a estruturas híbridas ruins que são metade objeto e metade
estrutura de dados. Elas possuem funções que fazem algo significativo, e também variáveis ou
métodos de acesso e de alteração públicos que, para todos os efeitos, tornam públicas as variáveis
privadas, incitando outras funções externas a usarem tais variáveis da forma como um programa
procedimental usaria uma estrutura de dados*.
Esses híbridos dificultam tanto a adição de novas funções como de novas estruturas de dados.
Eles são a pior coisa em ambas as condições. Evite criá-los. Eles indicam um modelo confuso cujos
autores não tinham certeza - ou pior, não sabiam - se precisavam se proteger de funções ou tipos.
Estruturas ocultas
E se ctxt, options e scratchDir forem objetos com ações reais? Então, como os objetos
devem ocultar suas estruturas internas, não deveríamos ser capazes de navegar por eles. Então,
como conseguiríamos o caminho absoluto de scratchDir ('diretório de rascunho')?
ou
ctxt.getAbsolutePathOfScratchDirectoryOption();
ctx.getScratchDirectoryOpt.ion().getAbsolutePath(
A primeira opção poderia levar a uma abundância de métodos no objeto ctxt. A segunda
presume que getScratchDirectoryOption() retorna uma estrutura de dados, e não
um objeto. Nenhuma das opções parece boa.
Se ctxt for um objeto, devemos dizê-lo para fazer algo; não devemos perguntá-lo sobre sua
estrutura interna. Por que queremos o caminho absoluto de scratchDir? O que faremos com ele?
Considere o código, muitas linhas abaixo, do mesmo módulo:
String outFile = outputDir + "/" + className.replace(% 7) +
".class";
FileOutputStream fout = new FileOutputStream(outFile);
BufferedOutputStream bos = new BufferedOutputStream(fout):
A mistura adicionada de diferentes níveis de detalhes [G34][G6] é unum pouco confusa. Pontos,
barras, extensão de arquivos e objetos File não devem ser misturados entre si e nem com o código
que os circunda. Ignorando isso, entretanto, vimos que a intenção de obter o caminho absoluto do
diretório de rascunho era para criar um arquivo de rascunho de um determinado nome.
Então, e se disséssemos ao objeto ctxt para fazer isso?
BufferedoutputStream bos = ctxt.createScratchFileStream(classFileName);
That seems like a reasonable thing for an object to do! Isso permite ao ctxt esconder sua estrutura
interna e evitar que a função atual viole a Lei de Demeter ao navegar por objetos os quais ela
não deveria enxergar.
4. Ås vezes chama-se de Feature Envy em [Refatoração].
100 Capítulo 6: Objetos e Estruturas de Dados
Objetos de transferência de dados
A forma perfeita de uma estrutura de dados é uma classe com variáveis públicas e nenhuma função.
Ås vezes, chama-se isso de objeto de transferência de dados, ou DTO (sigla em inglês). Os
DTOs são estruturas muitos úteis, especialmente para se comunicar com bancos de dados ou
analisar sintaticamente de mensagens provenientes de sockets e assim por diante. Eles costumam
se tornar os primeiros numa série de estágios de tradução que convertem dados brutos num banco
de dados em objetos no código do aplicativo.
De alguma forma mais comum é o formulário "bean" exibido na Listagem 6.7. Os beans têm
variáveis privadas manipuladas por métodos de escrita e leitura. O aparente encapsulamento dos
beans parece fazer alguns puristas da OO sentirem-se melhores, mas geralmente não oferece
vantagem alguma.
Listagem 6-7
address.java
public class Address {
private String street;
private String streetExtra;
private String city;
private String state;
private String zip;
public Address (String street, String streetExtra,
String city, String state, String zip) {
this.street = street;
this.streetExtra = streetExtra;
this.city = city:
this.state = state;
this.zip = zip;
public String getStreet()
return street;
}
public String getStreerExtra() {
return streetExtra;
public String getCity() {
return city:
public String getState() {
return state;
}
public String getZip() {
return zip:
Bibliografia 101
O Active Record
Os Active Records são formas especiais de DTOs. Eles são estruturas de dados com variáveis
públicas (ou acessadas por Beans); mas eles tipicamente possuem métodos de navegação, como
save (salvar) e find (buscar). Esses Active Records são traduções diretas das tabelas de bancos
de dados ou de outras fontes de dados.
Infelizmente, costumamos encontrar desenvolvedores tentando tratar essas estruturas de dados
como se fossem objetos, colocando métodos de regras de negócios neles. Isso é complicado, pois
cria um híbrido entre uma estrutura de dados e um objeto.
A solução, é claro, é tratar o Record Active como uma estrutura de dados e criar objetos
separados que contenham as regras de negócio e que ocultem seus dados internos (que
provavelmente são apenas instâncias do Active Record).
Conclusão
Os objetos expõem as ações e ocultam os dados. Isso facilita a adição de novos tipos de objetos
sem precisar modificar as ações existentes e dificulta a inclusão de novas atividades em objetos
existentes. As estruturas de dados expõem os dados e não possuem ações significativas. Isso
facilita a adição de novas ações às estruturas de dados existentes e dificulta a inclusão de novas
estruturas de dados em funções existentes.
Em um dado sistema, às vezes, desejaremos flexibilidade para adicionar novos tipos de
dados, e, portanto, optaremos por objetos. Em outras ocasiões, desejaremos querer flexibilidade
para adicionar novas ações, e, portanto, optaremos tipos de dados e procedimentos.
Bons desenvolvedores de software entendem essas questões sem preconceito e selecionam a
abordagem que melhor se aplica no momento.
Bibliografia
[Refatoração] Refatoração - Aperfeiçoando o Projeto de Código Existente, Martin Fowler et
al., Addison-Wesley, 1999.
7
Tratamento de Erro
por Michael Feathers
Pode parecer estranho ter uma seção sobre tratamento de erro num livro sobre código limpo,
mas essa tarefa é uma das quais todos temos de fazer quando programamos. A entrada pode
estar errada e os dispositivos podem falhar. Em suma, as coisas podem dar errado, e quando isso
ocorre, nós, como programadores, somos responsáveis por certificar que nosso código faça o que
seja preciso fazer.
A conexão com um código limpo, entretanto, deve ser clara. O tratamento de erro domina
completamente muitos códigos-fonte. Quando digo "domina", não quero dizer que eles só fazem
tratamento de erro, mas que é quase impossível ver o que o código faz devido a tantos tratamentos
de erros espalhados. Esse recurso é importante, mas se obscurecer a lógica, está errado.
Neste capítulo ressaltarei uma série de técnicas e considerações que você pode usar para criar
um código que seja limpo e robusto, que trate de erros com elegância e estilo.
104 Capítulo 7: Tratamento de Erro
Use exceções em vez de retornar códigos
Num passado longínquo havia muitas linguagens que não suportavam exceções. Nelas, as
técnicas para tratar e informar erros era limitada. Ou você criava uma flag de erro ou retornava
um código de erro que o chamador pudesse verificar. O código na Listagem 7.1 ilustra essas
abordagens.
Listagem 7-1
DeviceController.java
public class DeviceController{
public void sendShutDown() {
DeviceHandle handle = getHandle (DEV1);
// Check the state of the device
if (handle != DeviceHandle. INVALID) {
// Save the device status to the record field
retrieveDeviceRecord (handle);
// If not suspended, shut down
if (record.getStatus() != DEVICE_SUSPENDED) {
pauseDevice (handle);
clearDeviceWorkQueue (handle);
closeDevice (handlel:
} else {
logger.log("Device suspended. Unable to shut down");
else
logger.log("Invalid handle for: " + DEV1.toString(});
O problema era que essas técnicas entupiam o chamador, que devia verificar erros
imediatamente após a chamada. Infelizmente, facilmente se esqueciam de fazer isso. Por esse
motivo, é melhor lançar uma exceção quando um erro for encontrado. O código de chamada fica
mais limpo e sua lógica não fica ofuscada pelo tratamento de erro.
A Listagem 7.2 mostra o código depois de termos optado por lançar exceções em métodos
que podem detectar erros.
Listagem 7-2
DeviceController.java (com exceções)
public class DeviceController {
public void sendShutDown(){
try {
tryToShutDown()
} catch (DeviceShutDownError e) {
logger.log (e);
}
Crie primeiro sua estrutura try-catch-finally
Listagem 7-2 (continuação):
DeviceController.java (com exceções)
private void tryToShutDown() throws DeviceShutDownError
DeviceHandle handle = getHandle (DEV1);
DeviceRecord record = retrieveDeviceRecord(handle):
pauseDevice(handle);
clearDeviceWorkQueue (handle);
closeDevice (handle);
private DeviceHandle getHandle (DeviceID id) {
throw new DeviceShutDownError("Invalid handle for: "+ id.toString());
105
Observe como fica muito mais claro. Isso não é apenas uma questão estética. O código fica
melhor porque duas preocupações que estavam intrincadas, o algoritmo para o desligamento
do dispositivo e o tratamento de erro, agora estão separadas. Você pode pegar cada uma delas e
estudá-las independentemente.
Crie primeiro sua estrutura try-catch-finally
Uma das coisas mais interessantes sobre exceções é que elas definem um escopo dentro de
seu programa. Ao executar o código na parte try da estrutura try...catch...finally, você declara que
aquela execução pode ser cancelada a qualquer momento e, então, continuar no catch.
De certa forma, os blocos try são como transações. Seu catch tem de deixar seu programa
num estado consistente, não importa o que aconteça no try. Por essa razão, uma boa prática é
começar com uma estrutura try...catch...finally quando for escrever um código que talvez lance
exceções. Isso lhe ajuda a definir o que o usuário do código deve esperar, independente do que
ocorra de errado no código que é executado no try.
Vejamos um exemplo. Precisamos criar um código que acesse um arquivo e consulte alguns
objetos em série.
Começamos com um teste de unidade que mostra como capturar uma exceção se o
arquivo não existir:
@Test(expected = StorageException.class)
public void retrieveSectionShouldThrowOnInvalidFileName()
sectionStore.retrieveSection("invalid file");
}
O teste nos leva a cria esse stub:
{
public List<RecordedGrip> retrieveSection(String sectionName) {
// retorno ficticio ate que tenhamos uma implementacao real
return new ArrayList<RecordedGrip>();
106 Capítulo 7: Tratamento de Erro
Nosso teste falha porque ele não lança uma exceção. Em seguida, mudamos nossa implementação
de modo a tentar acessar um arquivo inválido. Essa operação lança uma exceção:
public List<RecordedGrip> retrieveSection(String sectionName) {
try {
}
FileInputStream stream = new FileInputStream(sectionName)
} catch (Exception e)}
throw new StorageException("retrieval error", e);
return new ArrayList<RecordedGrip>();
Nosso teste funciona agora porque capturamos a exceção. Neste momento, podemos refatorar.
Podemos reduzir o tipo de execução que capturamos para combinar com aquele que realmente
é lançado pelo construtor FileInputStream: FileNotFoundException:
public List<RecordedGrip> retrieveSection(String sectionName) }
try {
FileInputStream stream = new FileInputStream(sectionName);
stream.close();
} catch (FileNotFoundException e) {
throw new StorageException("retrieval error", e);
return new ArrayList<RecordedGrip>();
}
Agora que definimos o escopo com uma estrutura try...catch, podemos usar o TDD para
construir o resto da lógica que precisamos, que será adicionada na criação do FilelnputStream do
close e poderá fingir que nada de errado aconteceu.
Experimente criar testes que forçam exceções e, então, adicione a ação ao seu tratador para
cumprir seus testes. Isso fará com que você crie primeiro o escopo de transação do bloco try e lhe
ajudará a manter essa natureza de transação daquele escopo.
Use exceções não verificadas
A discussão acabou. Por anos, programadores Java têm discutido sobre as vantagens e
desvantagens de exceções verificadas. Quando a verificação exceções surgiu com a primeira
versão do Java, parecia uma ótima ideia. A assinatura de todo método listaria todas as exceções
que ele passaria ao seu chamador. Ademais, essas exceções eram parte do tipo do método. Seu
código literalmente não seria compilado se a assinatura não fosse a mesma da que seu código
podia fazer.
Naquela época, pensamos que exceções verificadas fosse uma ideia ótima; e era, elas tinham
algumas vantagens. Entretanto, ficou claro agora que elas não são necessárias para a produção
de um software robusto. O C# não verifica exceções, e, apesar das tentativas, nem o C++. Nem
mesmo Python ou Ruby. Ainda assim é possível criar um software robusto em todas essas
linguagens, porque, nesse caso, temos de decidir se realmente as exceções verificadas valem o
preço que se paga.
Que preço? O de verificar exceções é a violação do Princípio de Aberto-Fechado'.
Se você lançar uma exceção a ser verificada a partir de um método em seu código ео
1. [Martin].
Crie primeiro sua estrutura try-catch-finally 107
catch estiver três níveis acima, será preciso declará-la na assinatura de cada método entre
você e o catch. Isso significa que uma modificação em um nível mais baixo do software pode
forçar a alteração de assinaturas em muitos níveis mais altos. Os módulos alterados podem ser
reconstruídos e redistribuídos, mesmo que nada inerente a eles tenha sido mudado.
Considere a hierarquia de chamadas de um sistema grande. As funções no topo chamam
as abaixo delas, que chamam outras abaixo delas e ad infinitum. Agora digamos que uma das
funções dos níveis mais baixos seja modificada de uma forma que ela deva lançar uma exceção.
Se essa exceção for verificada, então a assinatura da função deverá adicionar uma instrução
throws. Mas isso significa que cada função que chamar nossa função modificada também deverá
ser alterada para capturar a nova exceção ou anexar a instrução throws apropriada a sua assinatura.
Ad infinitum. O resultado aninhado é uma cascata de alterações que vão desde os níveis mais
baixo do software até o mais alto! Quebra-se o encapsulamento, pois todas as funções no caminho
de um lançamento (throw) devem enxergar os detalhes daquela exceção de nível mais baixo.
Segundo o propósito de exceções de que elas lhe permitem tratar erros distantes, é uma pena que
as exceções verificadas quebrem dessa forma o encapsulamento.
As exceções verificadas podem às vezes ser úteis se você estiver criando uma biblioteca crítica:
é preciso capturá-las. Mas no desenvolvimento geral de aplicativo, os custos da dependência
superam as vantagens.
Forneça exceções com contexto
Cada exceção lançada deve fornecer contexto o suficiente para determinar a fonte e a localização
de um erro. Em Java, você pode pegar um stack trace de qualquer exceção; entretanto, ele não
consegue lhe dizer o objetivo da operação que falhou.
Crie mensagens de erro informativas e as passe juntamente com as exceções. Mencione a
operação que falhou e o tipo da falha. Se estiver registrando as ações de seu aplicativo, passe
informações suficientes para registrar o erro de seu catch.
Defina as classes de exceções segundo as necessidades
do chamador
Há muitas formas de classificar erros. Pode ser pela origem: eles vieram desse componente ou
daquele? Pelo tipo: são falhas de dispositivos, de redes ou erros de programação? Entretanto,
quando definimos as classes de exceção num aplicativo, nossa maior preocupação deveria ser
como elas são capturadas.
Vejamos um exemplo de uma classificação ruim de exceção. Aqui, há uma estrutura try...
catch...finally para uma chamada a uma biblioteca de outro fabricante. Ela cobre todas as
exceções que a chamada talvez lance:
ACMEPort port = new ACMEPort(12);
try {
port.open();
} catch (DeviceResponseException e)}
reportPortError(e);
logger.log("Device response exception", e);
} catch (ATM1212UnlockedException e) {
reportPortError(e);
108
logger.log("Unlock exception", e);
} catch (GMXError e) }
reportPortError(e);
logger.log("Device response exception");
} finally {
Capítulo 7: Tratamento de Erro
A estrutura possui muita duplicação, e não deveríamos estar surpresos. Na maioria dos casos
de tratamento de exceções, o que fazemos é relativamente padrão, independente da situação no
momento. Temos de registrar um erro e nos certificar que podemos prosseguir.
Neste caso, como sabemos que a tarefa que estamos fazendo é basicamente a mesma independente
da exceção, podemos simplificar nosso código consideravelmente. Para isso, pegamos a API que
estamos chamando e garantimos que ela retorne um tipo comum de exceção.
}
LocalPort port = new LocalPort(12);
try {
port.open();
catch (PortDeviceFailure e) }
reportError(e);
logger.log(e.getMessage(), e);
} finally }
}
Nossa classe LocalPort é um simples wrapper ("empacotador") que captura e traduz as
exceções lançadas pela classe ACMEPort:
public class LocalPort {
private ACMEPort innerPort;
}
public LocalPort(int portNumber) {
innerPort = new ACMEPort(portNumber);
public void open() {
innerPort.open();
try {
} catch (DeviceResponseException e) {
throw new PortDeviceFailure(e);
} catch (ATM1212UnlockedException e) {
}
throw new PortDeviceFailure(e);
catch (GMXError e) }
throw new PortDeviceFailure(e);
Wrappers como o que definimos para a ACMEPort podem ser muito úteis. Na verdade,
empacotar APIs de terceiros é a melhor prática que existe. Ao fazer isso, você minimiza as
dependências nelas: você pode escolher migrar para uma biblioteca diferente no futuro sem
Defina o fluxo normal 109
muitos problemas. Empacotar também facilita a simulação de chamadas de terceiros quando for
testar seu próprio código.
Uma última vantagem de empacotar (wrapping) é que você não fica preso às escolhas do
modelo de API de um fornecedor em particular. Você pode definir a API que preferir. No exemplo
anterior, definimos um único tipo de exceção para a falha do dispositivo port e descobrimos que
poderíamos escrever um código muito mais limpo.
Geralmente, uma única classe de exceção está bom para uma parte específica do código.
As informações enviadas com a exceção podem distinguir os erros. Use classes diferentes
apenas se houver casos em que você queira capturar uma exceção e permitir que a outra
passe normalmente.
Defina o fluxo normal
Se você seguir os conselhos das seções anteriores,
acabará com uma boa quantidade de divisão entre
sua lógica do negócio e seu tratamento de erro.
A maioria de seu código começará a parecer um
algoritmo limpo e sem apetrechos. Entretanto, esse
processo eleva ao máximo a detecção de erro em
seu programa. Você empacota suas APIs de modo
que você possa lançar suas próprias exceções e
definir um controlador acima de seu código para
que você possa lidar com qualquer computação
talvez não queira cancelar.
cancelada. Na maioria das vezes, essa é uma abordagem ótima, mas há situações nas quais você.
Vejamos um exemplo. Abaixo está um código confuso que soma as despesas em um aplicativo
de finanças:
try {
MealExpenses expenses = expenseReportDAO.getMeals(employee.
getID());
m_total += expenses.getTotal();
} catch(MealExpensesNotFound e)
m_total += getMealPerDiem();
}
Neste negócio, se as refeições (meals) forem um custo, elas se tornam parte do total. Caso
contrário, o funcionário (employee) recebe uma quantia para ajuda de custos (PerDiem) pela
refeição daquele dia. A exceção confunde a lógica.
Não seria melhor se não tivéssemos de lidar com o caso especial? Dessa forma, nosso código
seria muito mais simples. Ele ficaria assim:
MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
m_total += expenses.getTotal();
Podemos tornar o código mais simples? Parece que sim. Podemos alterar a ExpenseReportDAO
de modo que ela sempre retorne um objeto MealExpense. Se não houver gastos com refeições,
110 Capítulo 7: Tratamento de Errо
ela retorna um objeto MealExpense que retorna a ajuda de custos como seu total:
public class PerDiemMealExpenses implements MealExpenses {
public int getTotal() {
}
// retorna a ajuda de custos padrao
}
Isso se chama o Padrão Special Case ('padrão do caso especial'), de Fowler. Você cria uma
classe ou configure um objeto de modo que ele trate de um caso especial para você. Ao fazer
isso, o código do cliente não precisa lidar com o comportamento diferente. Este fica encapsulado
num objeto de caso especial.
Não retorne null
Acho que qualquer discussão sobre tratamento de erro deveria incluir as coisas que fazemos que
levam a erros. A primeira da lista seria retornar null. Já perdi a conta dos aplicativos que já vi que
em quase toda linha verificava por null. Abaixo está um exemplo:
public void registerItem(Item item)
if (item != null) {
ItemRegistry registry = peristentStore.getItemRegistry();
if (registry != null)}
Item existing = registry.getItem(item.getID());
if (existing.getBillingPeriod().hasRetailowner()) {
existing.register(item):
Se você trabalhar num código-fonte como esse, ele pode não parecer tão ruim assim para
você, mas ele é! Quando retornamos nu11, basicamente estamos criando mais trabalho para nós
mesmos e jogando problemas em cima de nossos chamadores. Só basta esquecer uma verificação
nul1 para que o aplicativo fique fora de controle.
Percebeu que não havia uma verificação de null na segunda linha do if aninhado? O que
teria acontecido em tempo de execução se persistentStore fosse nul1? Teríamos uma
NullPointerException em tempo de execução, e ou alguém está capturando-a no nível mais
alto ou não. Em ambos os casos isso é péssimo. O que você faria exatamente em respostaa um
lançamento de NullPointerException das profundezas de seu aplicativo?
E fácil dizer que o problema com o código acima é a falta de uma verificação de null.
mas, na verdade, o problema é que ele tem muitos. Se você ficar tentado a retornar nu11 de um
método, em vez disso, considere lançar uma exceção ou retornar um objeto SPECIAL CASE.
Se estiver chamando um método que retorne nu11 a partir de uma API de terceiros, considere
empacotá-lo com um método que lance uma exceção ou retorne um objeto de caso especial.
Em muitos casos, objetos de casos especiais são uma solução fácil. Imagine que seu código
fosse assim:
List<Employee> employees = getEmployees ();
if (employees != null) {
for (Employee e : employees) {
Não passe null
totalPay += e.getPay();
}
}
111
Neste momento, getEmployees pode retornar null, mas ele precisa? Se alterássemos getEmployee
de modo que ele retornasse uma lista vazia, poderíamos limpar o código:
List<Employee> employees = getEmployees ();
for (Employee e: employees) {
}
totalPay += e.getPay();
Felizmente, Java possui o Collections.emptyList(), e ele retorna uma lista predefinida e imutável
que podemos usar para esse propósito:
public List<Employee> getEmployees() {
if(.. there are no employees.. )
return Collections.emptyList();
}
Se programar dessa forma, você minimizará a chance de NullPointerExceptions e seu
código será mais limpoо.
Não passe null
Retornar nul1 dos métodos é ruim, mas passar null para eles é pior. A menos que esteja
trabalhando com uma API que espere receber nu11, você deve evitar passá-lo em seu código
sempre que possível.
Vejamos um exemplo do porquê. Abaixo está um método simples que calcula a distância
entre dois pontos:
public class MetricsCalculator
public double xProjection(Point pl, Point p2)
return (p2.xpl.x) * 1.5;
{
}
}
O que acontece quando alguém passa nu11 como parâmetro?
calculator.xProjection(null, new Point (12, 13));
Receberemos uma NullPointerException, é claro.
Podemos consertar isso? Poderíamos criar um novo tipo de exceção e lançá-lo:
public class MetricsCalculator
public double xProjection(Point p1, Point p2)
if (p1 == null || p2 == null) {
{
112 Capítulo 7: Tratamento de Erro
throw InvalidArgumentException(
"Invalid argument for
MetricsCalculator.xProjection");
}
return (p2.x p1.x) * 1.5;
}
}
Ficou melhor? Pode ser um pouco melhor do que uma exceção de ponteiro nu11, mas lembre-se
de que temos de definir um tratador para InvalidArgumentException. O que ele deve fazer?
Há algum procedimento bom?
Há uma alternativa. Poderíamos usar uma série de confirmações:
public class MetricsCalculator
{
public double xProjection(Point p1, Point p2) }
assert p1 != null: "p1 não pode ser nulo";
assert p2 != null: "p2 não pode ser nulo";
return (p2.x p1.x) * 1.5;
}
É uma boa informação, mas não resolve o problema. Se alguém passar nul1, ainda teremos um
erro em tempo de execução.
Na maioria das linguagens de programação não há uma boa forma de lidar com um valor nulo
passado acidentalmente para um chamador. Como aqui este é o caso, a abordagem lógica seria
proibir, por padrão, a passagem de nu11. Ao fazer isso, você pode programar com o conhecimento
de que um nu11 numa lista de parâmetros é sinal de problema, e acabar com mais alguns erros
por descuido.
Conclusão
Um código limpo é legível, mas também precisa ser robusto. Esses objetivos não são conflitantes.
Podemos criar programas limpos e robustos se enxergarmos o tratamento de erro como uma
preocupação à parte, algo que seja visível independentemente de nossa lógica principal. Na
medida em que somos capazes de fazer isso, podemos pensar nisso de forma independente e dar
um grande passo na capacidade de manutenção de nosso código.
Bibliografia
[Martin]: Agile Software Development: Principles, Patterns, and Practices, Robert C. Martin,
Prentice Hall, 2002.
8
Limites
por James Grenning
CCCCC
KAKE
Raramente controlamos todos os softwares em nossos sistemas. De vez em quando compramos
pacotes de outros fabricantes ou usamos códigos livres, ou dependemos de equipes em nossa própria
empresa para construir componentes ou subsistemas para nós. De algum modo, devemos integrar,
de forma limpa, esse código externo ao nosso. Neste capítulo veremos as práticas e técnicas para
manter limpos os limites de nosso software.
114 Capítulo 8: Limites
uso de códigos de terceiros
Há uma tensão natural entre o fornecedor de uma interface e seu usuário. Os fornecedores de
pacotes e frameworks de outros fabricantes visam a uma maior aplicabilidade de modo que
possam trabalhar com diversos ambientes e atender a um público maior. Já os usuários desejam
uma interface voltada para suas próprias necessidades. Essa tensão pode causar problemas nos
limites de nossos sistemas.
Tomemos o java.util.Map como exemplo. Como pode ver na Figura 8.1, os Maps tem
uma interface bastante ampla com diversas capacidades. Certamente esse poder e flexibilidade
são úteis, mas também pode ser uma desvantagem. Por exemplo, nosso aplicativo pode construir
um Map e passá-lo adiante. Nosso objetivo talvez seja que nenhum dos recipientes de nosso
Map não exclua nada do Map. Mas logo no início da lista está o método clear (). Qualquer
usuário do Map tem o poder de apagá-lo. Ou talvez, segundo a convenção que adotamos, o Map
pode armazenar apenas certos tipos de objetos, mas não é certo que ele restrinja os tipos que
são adicionados a ele. Qualquer usuário determinado pode adicionar itens de qualquer tipo a
qualquer Maр.
Se nosso aplicativo precisa de um Map de Sensors, você pode se deparar com um Sensors assim:
clear() void Mар
containsKey (Object key) boolean - Maр
containsValue (Object value) boolean - Map
entrySet() Set - Map
equals (Object o) boolean Map
get (Object key) Object - Map
• getClass() Class<? extends Object>- Object
hashCode() int - Map
isEmpty() boolean - Maр
keySet() Set Map
notify() void Object
notifyAll() void Object
put (Object key, Object value) Object- Map
putAll(Map t) void Map
remove (Object key) Object Maр
size() int Maр
toString() String Object
values() Collection - Map
wait() void Object
wait(long timeout) void Object
wait(long timeout, int nanos) void - Object
Figura 8.1: Métodos do Map
Se nosso aplicativo precisar de um Map de sensors, você talvez encontre sensors assim:
Map sensors = new HashMap();
E, quando alguma outra parte do código precisa acessar o Sensor, você vê isso:
Sensor s = (Sensor)sensors.get(sensorId );
O uso de códigos de terceiros 115
Não vemos isso apenas uma vez, mas várias ao longo do código. O cliente deste código fica com
a responsabilidade de obter um object do Map e atribuí-lo o tipo certo. Apesar de funcionar, não
é um código limpo. Ademais, esse código não explica muito bem o que ele faz. Pode-se melhorar
consideravelmente sua legibilidade com o uso de tipos genéricos, como mostra abaixo:
Map<Sensor> sensors = new HashMap<Sensor>();
Sensor s = sensors.get(sensorId );
Entretanto, isso não resolve o problema de que Map<sensor> oferece mais capacidade do que
precisamos ou queremos.
Passar adiante pelo sistema uma instância de Map<Sensor> significa que haverá vários
lugares para mexer se a interface para o Map mudar. Você talvez pense que uma mudança seja
pouco provável, mas lembre-se de que houve uma quando o suporte a genéricos foi adicionado
no Java 5. De fato, já vimos sistemas que impedem o uso de genéricos devido à magnitude das
alterações necessárias para manter o uso abrangente dos Maps.
Abaixo está uma forma limpa de usar o Map. Nenhum usuário do Sensors se importaria se
um pouco de genéricos for usado ou não. Essa escolha se tornou (e sempre deve ser) um detalhe
da implementação.
public class Sensors{
private Map sensors = new HashMaр();
public Sensor getById(String id) {
return (Sensor) sensors.get(id);
}
//codigo
}
A interface no limite (Map) está oculta. É possível alterá-la causando muito pouco impacto no
resto do aplicativo. O uso de tipos genéricos não é mais uma questão tão problemática assim,
pois o gerenciamento de declarações e de tipos é feito dentro da classe Sensors.
Essa interface também foi personalizada para satisfazer as necessidades do aplicativo. Seu
resultado é um código mais fácil de se entender e mais dificil de ser utilizado incorretamente. A classe
Sensors pode forçar regras de modelo e de negócios.
Não estamos sugerindo que cada uso do Map seja encapsulado dessa forma. Mas lhe aconselhando
para não passar os Maps (ou qualquer outra interface num limite) por todo o sistema. Se usar uma
interface, como a Map, no limite, a mantenha numa classe ou próxima a uma família de classes em
que ela possa ser usada. Evite retorná-la ou aceitá-la como parâmetro em APIs públicas.
Explorando e aprendendo sobre limites
Códigos de terceiros nos ajudam a obter mais funcionalidade em menos tempo. Por onde começar
quando desejamos utilizar pacotes de terceiros? Não é tarefa nossa testá-los, mas pode serer melhor
para nós criar testes para os códigos externos que formos usar.
Suponha que não esteja claro como usar uma biblioteca de terceiros. Podemos gastar um dia
ou dois (até mais) lendo a documentação e decidindo como vamos usá-la. Então, escreveríamos
116 Capítulo 8: Limites
nosso código para usar o código externo e vemos se ele é ou não o que achávamos. Não
ficaríamos surpresos de acabar em longas sessões de depuração tentando descobrir se os bugs
que encontramos são do nosso código ou no deles.
Entender códigos de terceiros é dificil. Integrá-lo ao seu também é. Fazer ambos ao mesmo
tempo dobra a dificuldade. E se adotássemos uma outra abordagem? Em vez de experimentar e
tentar o novo código, poderíamos criar testes para explorar nosso conhecimento sobre ele. Jim
Newkirk chama isso de testes de aprendizagem.
Nesses testes, chamamos a API do código externo como o faríamos ao usá-la em nosso
aplicativo.
Basicamente estaríamos controlando os experimentos que verificam nosso conhecimento
daquela AРІ.
O teste se focaliza no que desejamos saber sobre a API.
Aprendendo sobre log4j
Digamos que queremos usar o pacote log4j do Apache em vez de nosso próprio gravador de
registro interno.
Baixaríamos o pacote e então abriríamos a página de documentação inicial. Sem ler muito,
criamos nosso primeiro caso de teste, esperando que seja impresso "oi" no console.
@Test
public void testLogCreate() {
Logger logger = Logger.getLogger("MyLogger");
logger.info("oi");
}
Quando o executamos, o registrador (logger) produz um erro o qual nos diz que precisamos de algo
chamado Appender. Após ler um pouco mais, descobrimos que existe um ConsoleAppender. Então,
criamos um ConsoleAppender e vemos se desvendamos os segredos de registro no console.
@Test
public void testLogAddAppender() {
Logger logger = Logger.getLogger("MyLogger");
ConsoleAppender appender = new ConsoleAppender();
logger.addAppender(appender);
logger.info("oi");
Desta vez, descobrimos que o Appender não possui fluxo de saída. Estranho... Parecia lógico ter
um. Depois de buscar ajuda no Google, tentamos o seguinte:
@Test
public void testLogAddAppender() {
Logger logger = Logger.getLogger("MyLogger");
logger.removeAllAppenders();
logger.addAppender(new ConsoleAppender(
new PatternLayout("%p %t %m%n"),
ConsoleAppender.SYSTEM_OUT));
logger.info("oi");
Aprendendo sobre log4j 117
Funcionou. Uma mensagem de registro com "oi" apareceu no console! Parece estranho ter de
dizer ao ConsoleAppender o que ele precisa escrever no console. Mais interessante ainda é
quando removemos o parâmetro ConsoleAppender.SystemOut e ainda é exibido "oi". Mas
quando retiramos o PatternLayout, mais uma vez há mensagem de falta de um fluxo de saída.
Esse comportamento é muito estranho.
Lendo a documentação com um pouco mais de atenção, vimos que o construtor
ConsoleAppender padrão vem "desconfigurado", o que não parece muito óbvio ou prático.
Parece um bug, ou pelo menos uma inconsistência, no 1og4 j. Recorrendo novamente ao Google,
lendo e testando, acabamos chegando à Listagem 8.1. Descobrimos bastante coisa sobre como
funciona o log4j, e colocamos esse conhecimento numa série de testes simples de unidade.
Listagem 8-1
LogTest.java
public class LogTest{
private Logger logger;
@Before
public void initialize() {
}
@Test
logger = Logger.getLogger("logger")
logger.removeAllAppenders():
Logger.get RootLogger().removeAllAppenders();
public void basicLogger(){ BasicConfigurator.configure();
logger.info("basicLogger"):
}
@Test
public void addAppenderWithStream(){ logger.addAppender (new ConsoleAppender(
new PatternLayout ("%p %t %men"), ConsoleAppender.SYSTEM_OUT));
}
@Test
logger.info("addAppenderWithStream");
public void addAppenderWithoutStream() (
logger.addAppender (new ConsoleAppender(
new PatternLayout ("&p %t m%n")});
}
logger.info("addAppenderWithoutStream");
Agora sabemos como obter um console simples e inicializado de registro, e podemos
encapsular esse conhecimento em nossas classes de registro de modo que o resto de nosso
aplicativo fique isolado da interface limite do log4j.
Os testes de aprendizagem são melhores que de graçа
Os testes de aprendizagem acabam não custando nada. Tivemos de aprender sobre a API
mesmo, e escrever aqueles testes foi uma forma fácil e separada de obter o conhecimento que
118 Capítulo 8: Limites
conseguimos. Os testes de aprendizagem são experimentos precisos que ajudam a aumentar
nosso entendimento.
Esses testes não só saem de graça como geram um retorno positivo de nosso investimento.
Quando houver nossas distribuições daquele pacote externo, podemos executar os testes para ver
se há diferenças nas atividades.
Os testes de aprendizagem verificam se os pacotes de terceiros que estamos usando se
comportam como desejamos. Uma vez integrados, não há garantias de que o código se manterá
compatível com as nossas necessidades. Os autores originais sofrerão pressão para alterarem
seus códigos para satisfazer suas próprias necessidades. Eles consertarão bugs e adicionarão
novos recursos. Cada distribuição vem com um novo risco. Se o pacote for alterado de uma
forma que fique incompativel com nossos testes, descobriremos de imediato.
Você precise ou não do conhecimento proporcionado pelos testes de aprendizagem, deve-se
definir um limite claro por meio de uma série de testes externos que experimentem a interface da
mesma forma que seu código faria. Sem esses testes limite para facilitar a migração. poderemos
ficar tentados a manter por mais tempo do que deveríamos a versão antiga.
O uso de código que não existe ainda
Há outro tipo de limite, um que separa o conhecido do desconhecido. Geralmente há lugares
no código onde nosso conhecimento parece sumir. Às vezes, o que está do outro lado nos é
desconhecido (pelo menos agora). As vezes, optamos não olhar além do limite.
Alguns anos atrás fiz parte do time do desenvolvimento de software para um sistema de
comunicação de rádios. Havia um subsistema, o "Transmissor", que eu pouco sabia a respeito,
e as pessoas responsáveis por ele não tinham ainda definido sua interface. Não queríamos ficar
parados, então começamos a trabalhar longe daquela parte desconhecida do código.
Sabíamos muito bem onde nosso mundo terminava e onde começava o novo. Conforme
trabalhávamos, às vezes chegávamos a esse limite entre os dois mundos. Embora névoas e
nuvens de ignorância ofuscassem nossa visão para além do limite, nosso trabalho nos mostrou o
que queríamos que fosse a interface limite. Desejávamos dizer ao transmissor algo assim:
Configure o transmissor na frequência fornecida e emita uma representação analógica dos
dados provenientes desde fluxo.
Não tínhamos ideia de como isso seria feito, pois a API ainda não havia sido desenvolvida.
Portanto, decidimos trabalhar nos detalhes depois.
Para não ficarmos parados, definimos nossa própria interface. Demos um nome fácil de
lembrar, como Transmitter. Criamos um método chamado transmit que pegava uma
frequência e um fluxo de dados. Essa era a interface que gostariamos de ter.
O bom de criar a interface que desejamos é que podemos controlá-la. Isso ajuda a manter o
código do lado do cliente mais legível e centralizado na função para a qual fora criado.
Na Figura 8.2 você pode ver que preenchemos as classes do CommunicationsController
a partir da API do transmitter, a qual não controlávamos e havia sido definida. Ao usar
nossa própria interface para o aplicativo, mantivemos limpo e expressivo nosso código
do CommunicationsController. Uma vez definida a API do transmitter, criamos o
O uso de código que não existe ainda 119
TransmitterAdapter para fazer a conexão. O ADAPTER encapsulou a interação com a API
e forneceu um único local para ser modificado se a API for aperfeiçoada.
<<interface>>
Controlador de Transmitter
comunicação
+ transmit(frequéncia, fluxo)
Transmitter
falso
Adaptador do
Transmitter
<<futuro>>
API do Transmitter
Figura 8.2: Adivinhando deverá ser o transmitter
Esse modelo também nos dá um seam³ bastante conveniente no código para testarmos.
Ao usar um FakeTransmitter (transmissor falso) adequado, podemos testar as classes
do CommunicationsController. Além de podermos criar testes limite uma vez que temos a
TransmitterAPI para garantir que estamos usando corretamente a API.
Limites limpos
Coisas interessantes ocorrem nos limites. A alteração é uma delas. Bons projetos de software
acomodam modificações sem muito investimento ou trabalho. Quando usamos códigos que
estão fora de controle, deve-se dar uma atenção especial ao nosso investimento e garantir que
uma mudança futura não seja muito custosa.
O código nos limites precisa de uma divisão clara e testes que definem o que se deve esperar.
Devemos evitar que grande parte de nosso código enxergue as particularidades dos de terceiros.
É melhor depender de algo que você controle do que pegar algo que acabe controlando você.
Lidamos com os limites de códigos externos através de alguns poucos lugares em nosso código
que fazem referência a eles. Podemos empacotá-los como fizemos com o Map, ou talvez usar um
ADAPTER para converter nossa interface perfeita na que nos for fornecida. De qualquer forma,
nosso código se comunica melhor conosco, provê uso consistente interno pelo limite e possui
poucos pontos para serem mexidos quando o código externo sofrer alteração.
Bibliografia
[BeckTDD]: Test Driven Development, Kent Beck, Addison-Wesley, 2003.
[GOF]: Padrões de Projeto, Soluções Reutilizáveis de Software Orientado a Objetos, Gamma
et al., Addison-Wesley, 1996.
[WELC]: Working Effectively with Legacy Code, Addison-Wesley, 2004.
2 Consulte o padrão Adapter no [GOF].
I Iwant a giRL ust
Testes de Unidade
like the
Jegiel
Married dear
dLd Dad!
e
Nossa profissão evoluiu bastante ao longo dos últimos dez anos. Em 1997 não se ouvia falar
em Desenvolvimento Dirigido a Testes (TDD, sigla em inglês). Para a grande maioria de nós,
os testes de unidade eram um pequeno pedaço de código descartável que escrevíamos para nos
certificar que nossos programas funcionavam. Meticulosamente criávamos nossas classes
métodos e, então, improvisávamos um código para testá-los. Tipicamente, isso envolvia um
programa simples de controle que nos permitisse interagir manualmente com o programa que
havíamos escrito.
Lembro-me de ter criado em meados da década de 1990 um programa em C++ para um
sistema integrado em tempo real. Era um simples contador com a seguinte assinatura:
122 Capítulo 9: Testes de Unidade
void Timer::ScheduleCommand(Command* theCommand, int milliseconds)
A idéia era simples: o método execute de Command seria executado numa nova thread após
um número específico de milésimos de segundos. O programa era como testá-lo.
Criei um simples programa de controle que esperava alguma ação no teclado. Sempre que um
caractere era pressionado, ele agendaria um comando que escreveria o mesmo caractere cinco
segundos depois. Então eu digitava uma melodia no teclado e esperava que ela fosse reproduzida
na tela cinco segundos depois.
"Eu ... quero-uma-mulher ... igual ... a-com-quem-me-ca ... sei ... querido ... pa ... pai."
Realmente cantei essa melodia enquanto digitava o ponto "." e, então, a cantava novamente
quando aparecia na tela.
Esse era meu teste! Depois que o vi funcionar e o mostrei aos meus colegas, joguei o código
do teste fora.
Como eu disse, nossa profissão evoluiu. Atualmente eu criaria um teste que garantisse que
cada canto do código funcionasse como eu esperava. Eu isolaria meu código do resto do sistema
operacional em vez de apenas invocar as funções padrão de contagem; simularia aquelas funções
de modo que eu tivesse controle absoluto sobre o tempo; agendaria comandos que configurassem
flags booleanas; e, então, adiantaria o tempo, observando as flags e verificando se elas mudavam
de falsas para verdadeiras quando eu colocasse o valor correto no tempo.
Quando pego uma coleção de testes para passar adiante, eu me certifico se eles são adequados
para serem executados por qualquer pessoa que precise trabalhar com o código, e se eles e o
código estavam juntos no mesmo pacote de origem.
Isso, progredimos bastante, mas ainda podemos ir mais longe. Os movimentos do Agile e
do TDD têm incentivado muitos programadores a criarem testes de unidade automatizados, e
muitos outros estão se unindo a cada dia. Mas nessa correria para adicionar testes ao nosso
oficio, muitos programadores têm se esquecido de alguns dos pontos mais sutis e importantes de
se escrever bons testes.
As três leis do TDD
Hoje em dia todos sabem que o TDD nos pede para criar primeiro os testes de unidade antes do
código de produção. Mas essa regra é apenas o início. Considere as três leis¹ abaixo:
Primeira Lei Não se deve escrever o código de produção até criar um teste de unidade de falhas.
Segunda Lei Não se deve escrever mais de um teste de unidade do que o necessário para falhar,
e não compilar é falhar.
Terceira Lei Não se deve escrever mais códigos de produção do que o necessário para aplicar o
teste de falha atual.
IEEE Software, maio/junho 2007 (Vol. 24, No. 3) pp. 32-36
Como manter os testes limpos 123
Essas três leis lhe colocam numa rotina que talvez dure trinta segundos. Os testes e o código
de produção são escritos juntos, com os testes apenas alguns segundos mais adiantados.
Se trabalharmos dessa forma, criaríamos dezenas de testes a cada dia, centenas a cada mês
e milhares a cada ano; os testes cobririam praticamente todo o nosso código de produção.
O tamanho completo desses testes, que pode competir com o tamanho do próprio código de
produção, pode apresentar um problema de gerenciamento intimidador.
Como manter os testes limpos
Há alguns anos, pedi para orientar uma equipe que tinha decidido explicitamente que seus códigos
de testes não deveriam ser preservados segundo os mesmos padrões de qualidade que seu código
de produção. Eles se deram autorização para violar as leis em seus testes de unidade. "Rápida e
porcamente" era o lema. As variáveis não precisavam de nomes bem selecionados, as funções
de teste não tinham de ser curtas e descritivas. Os códigos de testes não precisavam ser bem
desenvolvidos e divididos de modo pensado. Se que o resto dos códigos de testes funcionasse e
que cobrisse o código de produção, já era o suficiente.
Alguns de vocês lendo isso talvez simpatizem com tal decisão. Talvez, lá no passado, você criou
testes tipo aquele que fiz para aquela classe Timer. É um grande passo ir da criação daquele tipo de
teste descartável para uma coleção de testes de unidade automatizados. Portanto, assim como a equipe
que eu orientara, você talvez decida que testes feitos "porcamente" sejam melhores do que nada.
O que aquela equipe não percebera era que ter testes daquele tipo é equivalente, se não pior,
a não ter teste algum. O problema é que muitos testes devem ser alterados conforme o código de
produção evolui. Quanto pior o teste, mais dificil será de mudá-lo. Quanto mais confuso for o
código de teste, são maiores as chances de você levar mais tempo espremendo novos testes para
dentro da coleção do que na criação do código de produção. Conforme você modifica o código
de produção, os testes antigos começam a falhar e a bagunça no código de teste dificulta fazêlos funcionar novamente. Sendo assim, os testes começam a ser vistos como um problema em
constante crescimento.
De distribuição em distribuição, o custo de manutenção da coleção de testes de minha equipe
aumentou. Com o tempo, isso se tornou a maior das reclamações entre os desenvolvedores. Quando
os gerentes perguntaram o motivo da estimativa de finalização estava ficando tão grande, os
desenvolvedores culparam os testes. No final, foram forçados a descartar toda coleção de testes.
Mas, sem uma coleção de testes, eles perderam a capacidade de garantir que, após alterações
no código-fonte, ele funcionasse como o esperado e que mudanças em uma parte do sistema não
afetariam as outras partes. Então, a taxa de defeitos começou a crescer. Conforme aumentava o
número de bugs indesejáveis, começaram a temer fazer alterações e pararam de limpar o código
de produção porque temiam que isso poderia fazer mais mal do que bem. O código de produção
começou a se degradar. No final das contas, ficaram sem testes, com um código de produção
confuso e cheio de bugs, com consumidores frustrados e o sentimento de que o esforço para
criação de testes não valeu de nada.
De certa forma estavam certos. Tal esforço tinha sido em vão. Mas fora decisão deles permitir
que os testes ficassem uma bagunça e se tornasse a origem do fracasso. Se tivessem mantido os
testes limpos, o esforço para a criação dos testes não teria os deixado na mão. Posso dizer isso
com um pouco de certeza, pois participei de tudo, e já orientei muitas equipes que obtiveram
sucesso com testes de unidade limpos.
124 Capítulo 9: Testes de Unidade
A moral da história é simples: Os códigos de testes são tão importantes quanto o código de
produção. Ele não é componente secundário. Ele requer raciocínio, planejamento e cuidado. É
preciso mantê-lo tão limpo quanto o código de produção.
Os testes habilitam as "-idades"
Se não mantiver seus testes limpos, irá perdê-los. E, sem eles, você perde exatamente o que
mantém a flexibilidade código de produção. Isso mesmo, você leu certo. São os testes de
unidade que mantêm seus códigos flexíveis, reutilizáveis e passíveis de manutenção. A razão é
simples. Se você tiver testes, não terá medo de alterar o código! Sem os testes, cada modificação
pode gerar um bug. Não importa o grau de flexibilidade de sua arquitetura ou de divisão de seu
modelo, pois sem os testes você ficará relutante em fazer mudanças por temer gerar bugs não
detectados.
Mas com os testes esse medo praticamente some. Quanto maior a cobertura de seus testes,
menor o medo. Você pode fazer mudanças quase sem penalidade ao código que tenha uma
arquitetura emaranhada e um modelo confuso e opaco. De fato, você pode improvisar essa
arquitetura e esse modelo sem temer!
Portanto, ter uma coleção de testes de unidade automatizados que cubram o código de
produção é o segredo para manter seu projeto e arquitetura os mais limpos possíveis. Os testes
habilitam todas as "-idades", pois eles possibilitam as alterações.
Dessa forma, caso seus testes estejam ruins, então sua capacidade de modificar seu código fica
comprometida e você começa a perder a capacidade de melhorar a estrutura dele. Quanto piores
forem os testes, pior o código se torna. No final, você perde os testes e seu código se degrada.
Testes limpos
O que torna um teste limpo? Três coisas: legibilidade, legibilidade e legibilidade. Talvez isso
seja até mais importe nos testes de unidade do que no código de produção. O que torna os testes
legíveis? O mesmo que torna todos os códigos legíveis: clareza, simplicidade e consistência de
expressão. Num teste você quer dizer muito com o mínimo de expressões possíveis.
Considere o código do FitNesse na Listagem 9.1. Esses três testes são difíceis de entender
e certamente podem ser melhorados. Primeiro, há uma quantidade terrível de código duplicado
[G5] nas chamadas repetidas a addPage e assertSubString. Mais importante ainda é que este código
está carregado de detalhes que interferem na expressividade do teste.
Listagem 9-1
SerializedPageResponder Test.java
{
public void testGetPageHieratchyAsXml() throws Exception
crawler.addPage (root, PathParser.parse ("Pageone")); crawler.addPage (rcot, PathParser.parse ("PageOne.ChildOne"));
crawler.addPage (root, PathParser.parse("PageTwo"));
Testes Limpos 125
Listagem 9-1 (continuação)
SerializedPageResponderTest.java
}
request.set Resource ("root");
request.addInput("type", "pages"):
Responder responder = new SerializedPageResponder!);
SimpleResponse response =
(SimpleResponse) responder.makeResponse(
new FitNesseContext (root), request);
String xml = response.getContent();
assertEquals("text/xml", response.getContentType())
assertSubString("<name>PageOne</name>", xml);
assertSubString("<name>PageTwo</name>", xml);
assertSubString("<name>ChildOne</name>", xml);
public void testGetPageHieratchyAsXmlDoesntContainSymbolicLink:
throws Exception
i
WikiPage pageOne = crawler.addPage(root, PathParser.parse("P.
crawler.addPage (root, PathParser.parse("PageOne.ChildOne"));
crawler.addPage(root, PathParser.parse("PageTwc"))
PageData data = pageOne.getData(); WikiPageProperties properties = data.getProperties();
WikiPageProperty symLinks = properties.set (SymbolicPage. PROP
symLinks.set ("SymPage", "PageTwo");
pageone.commit (data);
request.setResource("root");
request.addInput ("type", "pages");
Responder responder = new SerializedPageResponder();
SimpleResponse response =
(SimpleResponse) responder.makeResponse(
new FitNesseContext (root), request);
String xml = response.getContent ();
assertEquals("text/xml", response.getContentTyре());
assertSubString("<name>PageOne</name>", xml):
assertSubString("<name>PageTwo</name>", xml); assertSubString("<name>ChildOne</name>", xml);
assertNotSubString ("SymPage", xml);
public void testGetDataAsHtml() throws Exception
crawler.addPage(root, PathParser.parse("Test PageOne"), "test
request.setResource ("TestPageOne");
request.addInput("type", "data");
Por exemplo, veja as chamadas para PathParser. Elas transformam strings em instâncias
PagePath pelos crawler. Essa transformação é completamente irrelevante na execução do
teste e serve apenas para ofuscar o objetivo. Os detalhes em torno da criação do responder еa
definição do tipo de response também são apenas aglomerados. E tem a inepta forma pela qual
126 Capítulo 9: Testes de Unidade
é construído URL requisitado a partir de um resource e um parâmetro. (Ajudei a escrever esse
código, portanto me sinto completamente no direito de criticá-lo).
No final, esse código não foi feito para ser lido. O pobre leitor é inundado com um monte de
detalhes que devem ser entendidos antes que os testes façam algum sentido. Agora, considere os
testes improvisados na Listagem 9.2. Eles fazem exatamente o mesmo, mas foram refatorados
de uma forma muito mais clara e descritiva.
Listagem 9-2
SerializedPageResponderTest.java (refatorado)
public void testGet PageHierarchyAsXml() throws Exception
makePages ("PageOne", "PageOne.ChildOne". "PageTwo");
{
submitRequest ("root", "type:pages"):
assertResponselsXML();
assertResponseContains(
"<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
public void testSymbolicLinksAreNotInXmlFageHierarchy() throws Exception
WikiPage page = makePage("PageOne");
makePages ("PageOne.ChildOne", "PageTwo"):
addLinkTo (page, "PageTwo", "SymPage");
submitRequest ("root", "type:pages");
assertResponseIsXML():
assert ResponseContains(
}
"<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
assertResponseDoesNotContain("SymPage");
public void testGetDataAsXml() throws Exception {
makePageWithContent ("Test PageOne", "test page");
submitRequest ("TestPageOne", "type:data");
assertResponseIsXML(;
assertResponseContains ("test page", "<Test";
A estrutura desses testes tornou óbvio o padrão CONSTRUIR-OPERAR-VERIFICAR.
Cada um dos testes está claramente dividido em três partes. A primeira produz os dados do teste,
a segunda opera neles e a terceira verifica se a operação gerou os resultados esperados.
Note que a grande maioria dos detalhes maçantes foi eliminada. Os testes vão direto ao
ponto e usam apenas os tipos de dados e funções que realmente precisam. Quem ler esses
testes dev ser capaz de descobrir rapidamente o que fazem, sem se deixar enganar ou ficar
sobrepujado pelos detalhes.
itNe
Testes Limpos
Linguagem de testes específica ao domínio
127
Os testes na Listagem 9.2 mostram a técnica da construção de uma linguagem específica a um
domínio para seus testes. Em vez de usar as APIs que os programadores utilizam para manipular o
sistema, construímos uma série de funções e utilitários que usam tais APIs e que tornam os testes
mais convenientes de se escrever e mais fáceis de ler. Esses funções e utilitários se tornaram uma
API especializada usada pelos testes. Eles testam a linguagem que os programadores usam para
auxiliá-los a escrever seus testes e para ajudar àqueles que precisem ler esses testes mais tarde.
Essa API de teste não foi desenvolvida de uma só vez; ela evoluiu de uma contínua refatoração
de códigos de testes que ficaram demasiadamente ofuscados por detalhes confusos. Assim como
você me viu refatorar a Listagem 9.1 para Listagem 9.2, desenvolvedores disciplinacos também
refatoram seus códigos de teste para formas mais sucintas e expressivas.
Um padrão duplo
De um certo modo, a equipe que mencionei no início deste capítulo estava certa. O código dentro
da API de teste tem um conjunto diferente de padrões de engenharia em relação ao código de
produção. Ele pode ser simples, sucinto e expressivo, mas não precisa ser mais eficiente do
que o do código de produção. Apesar de tudo, ele roda num ambiente de teste, e não de um de
produção, e esses dois ambientes possuem requisitos diferentes.
Considere o teste na Listagem 9.3 que escrevi como parte de um sistema de controle de
ambiente que eu estava fazendo a prototipagem. Sem entrar em detalhes, posso lhe dizer que o
teste verifica se o alarme de temperatura baixa, o aquecedor e o ventilador estão todos ligados
quando a temperatura estiver "fria demais".
Listagem 9-3
EnvironmentControllerTest.java
@Test
public void turnOnLoTempAlarmAtThreashold() throws Exception
hw.setTemp (WAY_TOO_COLD);
controller.tic():
assertTrue (hw.heaterState());
assertTrue (hw.blowerState());
assertFalse(hw.coolerState();
assertFalse(hw.hiTempAlarm());
assertTrue(hw.loTempAlarm()):
Há, é claro, muitos detalhes aqui. Por exemplo, o que faz a função tic? Na verdade, prefiro
que você não se atenha a isso ao ler esse teste, mas que se preocupe apenas se você concorda ou
não se o estado final do sistema é consistente com a temperatura sendo "fria demais".
Note que, ao ler o teste, seus olhos precisam ler e reler entre o nome do estado sendo verificado
e a medida do estado sendo verificado. Você vê heaterState e, então, seus olhos deslizam
para a direita, para assertTrue. Você vê coolerState e seus olhos devem se voltar para a
128 Capítulo 9: Testes de Unidade
esquerda, para assertFalse. Isso é entediante e falível, além de dificultar a leitura do teste.
Aperfeiçoei a legibilidade deste teste consideravelmente na Listagem 9.4.
Listagem 9-4
EnvironmentControllerTest.java (refatorado)
@Test
}
public void turnOnLoTempAlarmAtThreshold() throws Exception {
wayTooCold();
assertEquals ("HBchL", hw.getState());
É claro que criei uma função wayTooCo1d para ocultar o detalhe da função tic. Mas o que
se deve notar é a estranha string em assertEquals. As letras maiúsculas significam "ligado" e
as minúsculas "desligado", e elas sempre seguema seguinte ordem: {heater, blower, cooler, hi-tempalarm, lo-temp-alarm}.
Mesmo que esse código esteja perto de violar a regra do mapeamento mental³, neste caso
parece apropriado. Note que, uma vez conhecendo o significado, seus olhos deslizam sobre a
string e você logo consegue interpretar os resultados. Torna-se quase uma satisfação ler o teste.
Dê uma olhada na Listagem 9.5 e veja como é fácil entender esses testes.
Listagem 9-5
EnvironmentControllerTest.java (seleção maior)
@Test
public void turnOnCoolerAndBlowerIfTooHot () throws Exception (
tooHot():
assert Equals("hBChl", hw.getState!));
}
@Test
public void turnOnHeaterAndBlowerIfTooCold() throws Exception
tooCold();
assertEquals("HBchl", hw.getState());
@Test
public void turnonHiTempAlarmAtThreshold() throws Exception
way TooHot ();
assert Equals ("hBCH1", hw.getState());
}
@Test
public void turnOnLoTempAlarmAtThreshold() throws Exception {
wayTooCold();
assertEqualsi"HBchL". hw.getState());
A função getState está na Listagem 9.6. Note que esse código não é muito eficiente. Para isso,
provavelmente eu deveria ter usado um StringBuffer.
Testes Limpos
Listagem 9-6
MockControlHardware.java
public String getState() {
String state = "";
state += heater? "H": "h";
state += blower ? "B": "b";
state += cooler ? C : "c":
"h"
"L": "l1";
state += hiTempAlarm? "H":
state += loTempAlarm ?
return state;
}
129
As StringBuffers são um pouco feias. Mesmo no código de produção irei evitá-las se o custo for
pequeno; e você poderia argumentar que o custo do código na Listagem 9.6 é bastante pequeno.
Contudo, esse aplicativo está claramente em um sistema integrado em tempo real, e é mais
provável que os recursos do computador e da memória sejam muito limitados. O ambiente de
teste, entretanto, não costuma ter limitações alguma.
Essa é a natureza do padrão duplo. Há coisa que você talvez jamais faça num ambiente de
produção que esteja perfeitamente bem em um ambiente de teste. Geralmente, isso envolve
questões de eficiência de memória e da CPU. Mas nunca de clareza.
Uma confirmação por teste
Há uma escola de pensamento+ que diz que cada função de teste em um teste JUnit deve ter um e
apenas uma instrução de confirmação (assert). Essa regra pode parecer perversa, mas a vantagem
pode ser vista na Listagem 9.5. Aqueles testes chegam a uma única conclusão que é fácil e rápida
de entender.
Mas e a Listagem 9.2? Parece ilógico que poderíamos de alguma forma facilmente adicionar
a confirmação se a saída está em XML e se ela contém certas substrings. Entretanto, podemos
dividir o teste em dois, cada um com sua própria confirmação, como mostra a Listagem 9.7.
Listagem 9-7
SerializedPageResponderTest.java (Confirmação Única)
public void testGet PageHierarchyAsXml() throws Exception {
givenPages ("PageOne", "PageOne.ChildOne", "PageTwo");
whenRequestIsIssued("roct, "type:pages");
thenResponseShouldBeXML();
public void testGet PageHierarchyHasRightTags() throws Exception
givenPages ("PageOne", "PageOne.ChildOne", "PageTwo");
whenRequestIsIssued("root", "type:pages*);
thenResponseShouldContain(
"<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
i:
130 Capítulo 9: Testes de Unidade
Note que mudei os nomes das funções para usar a convenção comum dado-quando-então. Isso
facilita ainda mais a leitura dos testes. Infelizmente, como pode ver, dividir os testes pode gerar
muito código duplicado.
Podemos usar o padrão Template Method para eliminar a duplicação e colocar as partes
dado/quando na classe base e as partes então em derivadas diferentes. Ou poderíamos criar uma
classe de teste completamente separada e colocar as partes dado e quando na função @Before e
as partes quando em cada função @Test. Mas isso parece muito trabalho para uma questão tão
pequena. No final, prefiro as confirmações múltiplas na Listagem 9.2.
Acho que a regra da confirmação única é uma boa orientação. Geralmente tento criar uma
linguagem de teste para um domínio específico que a use, como na Listagem 9.5. Mas não tenho
receio de colocar mais de uma confirmação em um teste. Acho que a melhor coisa que podemos
dizer é que se deve minimizar o número de confirmações em um teste.
Um único conceito por teste
Talvez a melhor regra seja que desejamos um único conceito em cada função de teste. Não
queremos funções longas que saiam testando várias coisas uma após a outra. A Listagem 9.8
é um exemplo disso. Esse teste deve ser dividido em três independentes, pois ele testa três
coisas distintas. Juntá-los todos na mesma função obriga o leitor compreender o objetivo de cada
função presente e o que ela testa.
Listagem 9-8
Miscellaneous tests for the addMonths() method.
public void testAddMonths(){
SerialDate dl = SerialDate.createInstance (31, 5, 2004);
SerialDate d2 = SerialDate.addMonths(1, d1);
assertEquals(30, d2.getDayOfMonth());
assertEquals(6, d2.getMonth());
assertEquals (2004, d2.getYYYY());
SerialDate d3 = SerialDate.addMonths (2, d1);
assertEquals (31, d3.getDayOfMonth(}):
assertEquals(7, d3.getMonth{));
assertEquals (2004, d3.getYYYY());
SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1)):
assertEquals (30, d4.getDayOfMonth());
assertEquals(7, d4.getMonth());
assertEquals (2004, d4.getYYYY()):
As três funções de teste devem seguir provavelmente assim:
Dado o último dia de um mês com 31 dias (como maio):
7. "Faça a manutenção do código!"
Um único conceito por teste 131
1. Quando você adicionar um mês cujo último dia seja o 30° (como junho), então a data deverá
ser o dia 30 daquele mês, e não a 31.
2. Quando você adicionar dois meses àquela data cujo último dia seja o 31°, então a data deverá
ser o dia 31.
• Dado o último dia de um mês com 30 dias (como junho):
1. Quando você adicionar um mês cujo último dia seja o 31°, então a data deverá ser dia 30 e não 31.
Explicado dessa forma, você pode ver que há uma regra geral oculta nos testes diversos. Ao incrementar
o mês, a data não pode ser maior do que o último dia daquele mês. Isso implica que incrementar o mês
em 28 de fevereiro resultaria em 28 de março. Esse teste está faltando e seria útil criá-lo.
Portanto, não são as confirmações múltiplas em cada seção da Listagem 9.8 que causa o problema.
É o fato de que há mais de um conceito sendo testado. Assim, provavelmente,a melhor regra seja
minimizar o número de confirmações por conceito e testar apenas um conceito por função de teste.
F.I.R.S.T.
Testes limpos seguem outras cinco regras que formam o acrônimo em inglês acima (Fast,
Independent, Repeatable, Self-validating, Timely):
Rapidez os testes devem ser rápidos. Devem executar com rapidez. Quando os testes rodam
devagar, você não desejará executá-los com frequência. E, consequentemente, não encontrará
problemas cedo o bastante para consertá-los facilmente. E você não se sentirá livre para limpar
o código, que acabará se degradando.
Independência os testes não devem depender uns dos outros. Um teste não deve configurar as
condições para o próximo. Você deve ser capaz de executar cada teste de forma independente e
na ordem que desejar. Quando eles dependem uns dos outros, se o primeiro falhar causará um
efeito dominó de falhas, dificultando o diagnóstico e ocultando os defeitos abaixo dele.
Repetitividade deve-se poder repetir os testes em qualquer ambiente. Você deve ser capaz de
efetuar testes no ambiente de produção, no de garantia de qualidade e no seu notebook enquanto
volta para casa de trem sem uma rede disponível. Caso seus testes não possam ser repetidos em
qualquer ambiente, então você sempre terá uma desculpa para o motivo das falhas. E também
perceberá que não consegue rodar os testes fora o ambiente adequado.
Autovalidação os testes devem ter uma saída booleana. Obtenham ou não êxito, você não deve
ler um arquivo de registro para saber o resultado. Você não deve ter de comparar manualmente
dois arquivos texto para ver se os testes foram bem sucedidos. Se os testes não possuírem
autovalidação, então uma falha pode se tornar subjetiva, e executar os testes pode exigir uma
longa validação manual.
8. Materiais de Treinamento da Object Mentor.
132 Capítulo 9: Testes de Unidade
Pontualidade os testes precisam ser escritos em tempo hábil. Devem-se criar os testes de unidade
imediatamente antes do código de produção no qual serão aplicados. Se criá-los depois, o teste
do código de produção poderá ficar mais dificil. Ou talvez você ache que um pouco do código
de produção seja complexo demais para testar. Ou talvez você não crie o código de produção de
maneira que possa ser testado.
Conclusão
Aqui abordamos apenas o início deste tópico. De fato, acho que deveria ter um livro inteiro
sobre Testes limpos. Os testes são tão importantes para a saúde de um projeto quanto o código
de produção. Talvez até mais, pois eles preservam e aumentam a flexibilidade, capacidade de
manutenção e reutilização do código de produção. Portanto, mantenha seus testes sempre limpos.
Trabalhe para torná-los sucintos e expressivos. Invente APIS de teste que funcionem como uma
linguagem específica a um domínio que lhe ajude a criar seus testes.
Se deixar os testes de degradarem, seu código também irá. Mantenha limpos os seus testes.
Bibliografia
[RSpec]: RSpec: Behavior Driven Development for Ruby Programmers,
Aslak Hellesøy, David Chelimsky, Pragmatic Bookshelf, 2008.
[GOF]: Padrões de Projeto, Soluções Reutilizáveis de Software Orientado a Objetos, Gamma
et al., Addison-Wesley, 1996.
FEDERALI
PER
DAS
DAS
KAРYDL
ARL
10
Classes
com Jeff Langr
Até agora, este livro se focou em como escrever bem linhas e blocos de código. Mergulhamos
na composição apropriada para funções e como elas se interrelacionam. Mas apesar de termos
falado bastante sobre a expressividade das instruções do código e as funções que o compõem,
ainda não teremos um código limpo até discutirmos sobre os níveis mais altos da organização do
código. Vamos fala agora sobre classes limpas.
134 Capítulo 10: Classes
Organização das classes
Seguindo uma convenção padrão Java, uma classe deve começar com uma lista de variáveis.
As públicas (public), estáticas (static) e constantes (constants), se existirem, devem
vir primeiro. Depois vêm as variáveis estáticas privadas (private static), seguidas pelas
instâncias privadas. Raramente há uma boa razão para se ter uma variável pública (public).
As funções públicas devem vir após a lista de variáveis. Gostamos de colocar as tarefas
privadas chamadas por uma função pública logo depois desta. Isso segue a regra de cima para
baixo e ajuda o programa a ser lido como um artigo de jornal.
Encapsulamento
Gostaríamos que nossas variáveis e funções fossem privadas, mas não somos radicais.
As vezes, precisamos tornar uma variável ou função protegida (protected) de modo que
possa ser acessada para testes. Para nós, o teste tem prioridade. Se um teste no mesmo pacote
precisa chamar uma função ou acessar uma variável, a tornaremos protegida ou apenas no
escopo do pacote. Entretanto, primeiro buscaremos uma forma de manter a privacidade. Perder
o encapsulamento sempre é o último recurso.
As classes devem ser pequenas!
A primeira regra para classes é que devem ser pequenas. A segunda é que devem ser menores
ainda. Não, não iremos repetir o mesmo texto do capítulo sobre Funções. Mas assim como com as
funções, ser pequena também é a regra principal quando o assunto for criar classes. Assim como
com as funções, nossa questão imediata é "O quão pequena?". Com as funções medimos o tamanho
contando as linhas fisicas. Com as classes é diferente. Contamos as responsabilidades.
A Listagem 10.1 realça uma classe, a SuperDashboard, que expõe cerca de 70 métodos públicos.
A maioria dos desenvolvedores concordaria que ela é um pouco grande demais em tamanho.
Outros diriam que a SuperDashboard é uma "classe de deus".
Listagem 10-1
Responsabilidades em excesso
public class SuperDashboard extends JFrame implements MetaDataUser
public String getCustomizerLanguagePath()
public void setSystemConfigPath(String systemConfigPath)
public String getSystemConfigDocument ()
public void setSystemConfigDocument (String systemConfigDocument)
public boolean getGuruState()
public boolean getNoviceState!)
public boolean getOpenSourceState()
public void showObject (MetaObject object)
public void showProgress(String s)
RDD1.
As classes devem ser pequenas!
Listagem 10-1 (continuação)
Responsabilidades em excesso
public boolean isMetadataDirty()
public void setIsMetadataDirty (boolean isMetadataDirty)
public Component getLastFocusedComponent()
pubiic void setLastFocused (Component. lastFocused)
public void setMouseSelectState (boolean isMouseSelected)
public boolean isMouseSelected ()
public LanguageManager getLanguageManager ()
public Froject getProject ()
public Project getFirstProject ()
public Project getLast Project ()
public String getNewProjectName()
public void setComponentSizes (Dimension dim?
public String getCurrentDir()
public void setCurrentDir (String newDir)
public void updateStatus (int dotPos, int markPos)
public Class[] get DataBaseClasses ()
public MetadataFeeder getMetadataFeeder()
public void addProject (Project project)
public boolean setCurrent Project (Project projecti
public boolean removeProject (Project project)
public MetaProjectHeader getProgramMetadata()
public void resetDashboard ()
public Project loadProject (String fileName, String projectName)
public void setCanSaveMetadata (boolean canSave)
public MetaObject getSelectedObject ()
public void deselectObjects()
public void setProject (Project project)
public void editorAction (String actionName, ActionEvent event)
public void setMode(int mode)
public FileManager getFileManager()
public void setFileManager (FileManager
public ConfigManager getConfigManager() fileManager)
public void setConfigManager (ConfigManager configManager)
public ClassLoader getClassLoader()
public void setClassLoader (ClassLoader classLoader)
public Properties getProps ()
public String getUserHome()
public String getBaseDir()
public int getMajorVersionNumber()
public int getMinorVersionNumber()
public int getBuildNumber()
public MetaObject pasting(
MetaObject target, MetaObject pasted, MetaProject project)
public void processMenuItems (MetaObject metaObject)
public void processMenuSeparators (MetaObject metaObject)
public void processTabPages (Metaobject metaObject)
public void processPlacement (MetaObject object)
public void processCreateLayout (MetaObject object)
public void updateDisplayLayer (MetaObject object, int layerindex)
public void propertyEditedRepaint (Metaobject object)
public void processDeleteObject (MetaObject object)
public boolean getAttachedToDesigner()
public void processProjectChangedState (boolean hasFrojectChanged)
public void processObjectNameChanged (MetaObject object)
public void runProject()
135
136 Capítulo 10: Classes
Listagem 10-1 (continuação)
Responsabilidades em excesso
public void setAçowDragging (boolean allowDragging)
public boolean allowDragging ()
public boolean isCustomizing()
public void setTitle(String title)
public IdeMenuBar getIdeMenuBar ()
public void showHelper (MetaObject metaObject, String propertyName)
//... many non-public methods follow...
Mas e se SuperDashboard possuísse apenas os métodos da Listagem 10.2?
Listagem 10-2
Pequena o suficiente?
public class SuperDashboard extends JFrame implements MetaDataUser
}
public Component getLastFocusedComponent ()
public void setLastFocused (Component lastFocused)
public int getMajorVersionNumber ()
public int getMinorVersionNumber()
public int getBuildNumber ()
Cinco não é muito, é? Neste caso é, pois apesar da pequena quantidade de métodos, a
SuperDashboard possui muitas responsabilidades.
O nome de uma classe deve descrever quais responsabilidades ela faz. Na verdade, selecionar
um nome é a primeira forma de ajudar a determinar o tamanho da classe. Se não derivarmos um
nome conciso para ela, então provavelmente ela ficará grande. Quanto mais ambíguo for o nome
da classe, maiores as chances de ela ficar com muitas responsabilidades. Por exemplo, nomes
de classes que possuam palavras de vários sentidos, como Processador ou Gerenciador ou
Super, geralmente indicam um acúmulo lastimável de responsabilidades.
Devemos também poder escrever com cerca de 25 palavras uma breve descrição da classe,
sem usar as palavras "se", "e", "ou" ou "mas". Como descreveríamos a SuperDashboard?
"A SuperDashboard oferece acesso ao componente que foi o último utilizado e também nos
permite acompanhar os números da versão e da compilação".O primeiro "e" é uma dica de que
a classe possui responsabilidades em excesso.
O Principio da Responsabilidade Única
O Principio da Responsabilidade Única (SRP, sigla em inglês) afirma que uma classe ou
módulo deve ter um, e apenas um, motivo para mudar. Este princípio nos dá uma definição
de responsabilidade e uma orientação para o tamanho da classe. Estas devem ter apenas uma
responsabilidade e um motivo para mudar.
Uma classe pequena como essa, a SuperDashboard, na Listagem 10.2, possui duas razões
para ser alterada.
Primeiro, ela acompanha a informação sobre a versão, que precisa ser atualizada sempre que
surgir uma nova distribuição do software. Segundo, ela gerencia os componentes Swing do Java
2. Pode-se ler muito mais sobre este principio em [PPP].
As classes devem ser pequenas! 137
(é um derivado do JFrame, a representação do Swing de uma janela GUI de alto nível). Sem
dúvida iremos querer atualizar o número da versão se alterarmos qualquer código do Swing, mas
o oposto não é necessariamente verdadeiro: podemos mudar as informações da versão baseandonos nas modificações em outros códigos no sistema.
Tentar identificar as responsabilidades (motivos para alteração) costuma nos ajudar a
reconhecer e criar abstrações melhores em nosso código. Podemos facilmente extrair todos
os três métodos SuperDashboard que lidam com as informações de versão em uma classe
separada chamada Version. (Veja a Listagem 10.3). A classe Version é um construtor que
possui um alto potencial para reutilização em outros aplicativos!
Listagem 10-3
Classe com responsabilidade única
public class Version i
public int getMajorVersionNumber ()
public int getMinorVersionNumber()
public int getBuildNumber()
é
O SRP é um dos conceitos mais importantes no desenvolvimento OO. É também um dos
mais simples para se entender e aprender. Mesmo assim, estranhamente, o SRP geralmente
o princípio mais ignorado na criação de classes. Frequentemente, encontramos classes que faz
muitas coisas. Por quê?
Fazer um software funcionar e torná-lo limpo são duas coisas bem diferentes.
A maioria de nós tem uma mente limitada, por isso, nós tentamos fazer com que nosso código
possua mais do que organização e clareza. Isso é totalmente apropriado. Manter uma separação de
questões é tão importante em nossas atividades de programação como em nossos programas.
O problema é que muitos de nós achamos que já terminamos se o programa funciona.
Esquecemo-nos da outra questão de organização e de clareza. Seguimos para o próximo problema
em vez de voltar e dividir as classes muito cheias em outras com responsabilidades únicas.
Ao mesmo tempo, muitos desenvolvedores temem que um grande número de classes pequenas
e de propósito único dificulte mais o entendimento geral do código. Eles ficam apreensivos em
ter de navegar de classe em classe para descobrir como é realizada uma parte maior da tarefa.
Entretanto, um sistema com muitas classes pequenas não possui tantas partes separadas a
mais como um com classes grandes. Há também bastante a se aprender num sistema com poucas
classes grandes. Portanto, a questão é: você quer suas ferramentas organizadas em caixas de
ferramentas com muitas gavetas pequenas, cada um com objetos bem classificados e rotulados?
Ou poucas gavetas nas quais você coloca tudo?
Ο
이
Todo sistema expansível poderá conter uma grande quantidade de lógica e complexidade.
objetivo principal no gerenciamento de tal complexidade é organizá-la de modo que
desenvolvedor saiba onde buscar o que ele deseja e que precise entender apenas a complexidade
que afeta diretamente um dado momento. Em contrapartida, um sistema com classes maiores
de vários propósitos sempre nos atrasa insistindo que percorramos por diversas coisas que não
precisamos saber no momento.
Reafirmando os pontos anteriores: desejamos que nossos sistemas sejam compostos por muitas
classes pequenas, e não poucas classes grandes. Cada classe pequena encapsula uma única
138 Capítulo 10: Classes
responsabilidade, possui um único motivo para ser alterada e contribui com poucas outras para
obter os comportamentos desejados no sistema.
Coesão
As classes devem ter um pequeno número de instâncias de variáveis. Cada método de uma classe
deve manipular uma ou mais dessas variáveis. De modo geral, quanto mais variáveis um método
manipular, mais coeso o método é para sua classe. Uma classe na qual cada variável é utilizada
por um método é totalmente coesa.
De modo geral, não é aconselhável e nem possível criar tais classes totalmente coesas;
por outro lado, gostaríamos de obter uma alta coesão. Quando conseguimos, os métodos e as
variáveis da classe são co-dependentes e ficam juntas como um todo lógico.
Considere a implementação de uma Stack (pilha) na Listagem 10.4. A classe é bastante
coesa. Dos três métodos, apenas size() não usa ambas as variáveis.
Listagem 10-4
Stack.java- uma classe coesa.
public class Stack {
private int topofStack = 0;
List<Integer> elements = new LinkedList<Integer>();
public int size(){
return topofStack;
public void push(int element) {
topofStack++;
}
elements.add(element);
public int pop() throws PoppedWhenEmpty {
if (topOfStack == 0)
throw new PoppedWhenEmpty();
int element = elements.get(--topofStack);
elements.remove(topofStack);
return element;
A estratégia para manter funções pequenas e listas de parâmetros curtas às vezes pode levar
à proliferação de instâncias de variáveis que são usadas por uma sequência de métodos. Quando
isso ocorre, quase sempre significa que há pelo menos uma outra classe tentando sair da classe
maior na qual ela está. Você sempre deve tentar separar as variáveis e os métodos em duas ou
mais classes de modo que as novas classes sejam mais coesas.
As classes devem ser pequenas! 139
Manutenção de resultados coesos em muitas
classes pequenas
Só o ato de dividir funções grandes em menores causa a proliferação de classes. Imagine uma
função grande com muitas variáveis declaradas. Digamos que você deseje extrair uma pequena
parte dela para uma outra função. Entretanto, o código a ser extraído usa quatro das variáveis
declaradas na função. Você deve passar todas as quatro para a nova função como parâmetros?
Absolutamente não! Se convertêssemos aquelas quatro variáveis em instâncias de variáveis
da classe, então poderíamos extrair o código sem passar qualquer variável. Seria fácil dividir a
função em partes menores.
Infelizmente, isso também significa que nossas classes perderiam coesão, pois acumulariam
mais e mais instâncias de variáveis que existiriam somente para permitir que as poucas funções as
compartilhassem. Mas, espere! Se há poucas funções que desejam compartilhar certas variáveis, isso
não as torna uma cada uma classe? Claro que sim. Quando as classes perdem coesão, divida-as!
Portanto, separar uma função grande em muitas pequenas geralmente nos permite dividir
várias classes também. Isso dá ao nosso programa uma melhor organização e uma estrutura mais
transparente.
Como exemplo do que quero dizer. usemos um exemplo respeitado há anos, extraído do
maravilhoso livro Literate Programming', de Knuth. A Listagem 10.5 mostra uma tradução em
Java do programa PrintPrimes de Knuth. Para ser justo com Knuth, este não é o programa que
ele escreveu, mas o que foi produzido pela sua ferramenta WEB. Uso-o por ser um grande ponto
de partida para dividir uma função grande em muitas funções e classes menores.
Listagem 10-5
PrintPrimes.java
package literatePrimes;
public class PrintPrimes {
public static void main(String[] args( }
final int M = 1000;
final int RR = 50;
fınal int CC = 4;
final int WW = 10;
final int ORDMAX = 30;
1nt P[] = new int [M + 1];
int PAGENUMBER;
int PAGEOFFSET;
int ROWOFFSET:
int C;
3. [Knuth92].
140
Listagem 10-5 (continuação)
PrintPrimes.java
int J;
int K;
boolean JPRIME;
int ORD:
int SQUARE;
int N;
int MULT[] = new int [ORDMAX + 1];
J = 1;
K = 1;
P[1] = 2:
ORD = 2:
SQUARE = 9;
while (K < M) {
do {
J=J+2;
if (J == SQUARE) {
ORD = ORD + 1;
SQUARE = P[ORD] * P[ORD];
MULT [ORD - 1] = J:
}
N = 2;
Capítulo 10: Classes
JPRIME = true:
while (N < ORD && JPRIME) )
while (MULT[N] < J)
MULT[N] = MULT[N] + P[N] + P[N];
if (MULT[N] == J)
JPRIME = false:
N=N+ 1;
} while (!JPRIME);
K= K+ 1;
P[K] = J;
PAGENUMBER = 1;
PAGEOFFSET = 1;
while (PAGEOFFSET <= M)
System.out.println("The First"+ M +
"Prime Numbers-- Page "+ PAGENUMBER);
System.out.println("");
for (ROWOFFSET = PAGEOFFSET; ROWOFFSET < PAGEOFFSET + RR; ROWOFFSET++){
for (C = 0; C< CC;C++)
3
if (ROWOFFSET + C * RR <= M)
System.out.format ("%10d". P[ROWOFFSET +C RR]);
System.out.println("");
System.out.println("\f"};
PAGENUMBER = PAGENUMBER + 1;
PAGEOFFSET = PAGEOFFSET + RR * CСС;
}
As classes devem ser pequenas! 141
Este programa, escrito como uma única função, é uma zona; possui uma estrutura com muitas
endentações, uma abundância de variáveis estranhas e uma estrutura fortemente acoplada.
No mínimo essa grande função deve ser dividida em algumas menores.
Da Listagem 10.6 a 10.8 mostra o resultado da divisão do código na Listagem 10.5 em classes
e funções menores, e seleciona nomes significativos para as classes, funções e variáveis.
Listagem 10-6
PrimePrinter.java (refatorado)
package literatePrimes;
public class PrimePrinter {
public static void main(String[] args) {
final int NUMBER_OF_PRIMES = 1000;
}
int[] primes = PrimeGenerator.generate(NUMBER_OF_PRIMES);
final int ROWS_PER_PAGE = 50;
final int COLUMNS_PER_PAGE = 4;
RowColumnPagePrinter tablePrinter =
new RowColumnPagePrinter (ROWS_PER_PAGE,
tablePrinter.print(primes):
COLUMNS_PER_PAGE,
"The First " + NUMBER OF PRIMES +
Prime Numbers"):
Listagem 10-7
RowColumnPagePrinter.java
package literatePrimes;
import java.1o.PrintStream;
public class RowColumnPagePrinter{
private int rowsPerPage;
private int columnsPerPage;
private int numbersPerPage;
private String pageHeader;
private PrintStream printStream;
public RowColumnPagePrinter (int rowsPerPage,
int columnsPerPage.
String pageHeader) {
this.rowsPerPage = rowsPerPage;
this.columnsPerPage = columnsPerPage;
this.pageHeader = pageHeader;
numbersPerPage = rowsPerPage * columnsPerPage;
printStream = System.out;
142
Listagem 10-7 (continuação)
RowColumnPagePrinter.java
public void print (int data[]) {
int pageNumber = 1;
for (int firstIndexOnPage = 0;
firstIndexOnPage < data.length;
firstindexOnPage += numbersPerPage)
int lastIndexOnPage =
Math.min(firstIndexOnPage + numbersPerPage -1,
data.length 1);
print PageHeader (pageHeader, pageNumber):
printPage(firstIndexOnPage, lastIndexOnPage, data);
printStream.println("\f");
pageNumber++;
}
private void printPage(int firstIndexOnPage,
int lastIndexOnPage,
int[] data) {
int firstIndexOfLastRowOnPage =
firstIndexOnPage + rowsPerPage 1;
for (int firstIndexInRow = firstIndexOnPage;
firstIndexInRow <= firstIndexOfLastRowOnPage;
firstIndexInRow++){
printRow(firstIndexInRow, lastIndexOnPage, data):
printStream.println("");
private void printRow(int firstIndexInRow,
int lastIndexOnPage,
int[] data) {
for (int column = 0; column < columnsPerPage; column++)
int index = firstIndexinRow + column rowsPerPage;
if (index <= lastIndexOnPage)
}
printStream.format ("%10d", data[index]);
private void print PageHeader(String pageHeader,
int pageNumber)
printStream.println (pageHeader +"--- Page "+ pageNumber);
printStream.printin("")
public void setoutput (PrintStream printStream)
this.printStream = printStream;
}
Capítulo 10: Classes
As classes devem ser pequenas!
Listagem 10-8
PrimeGenerator.java
package literatePrimes:
import java.util.ArrayList;
public class PrimeGenerator{
private static int[] primes;
private static ArrayList<Integer> multiplesOfPrimeFactors;
protected static int[) generate(int n) {
primes = new int (r];
multiplesOfPrimeFactors = new ArrayList<Integer>()
set2AsFirstPrimel);
checkOddNumbersForSubsequent Primes();
return primes;
private static void set2ASFirstPrime ()
primes [0] = 2;
multiplesOfPrimeFactors.add (2);
private static void checkoddNumbersForSubsequent Primes()
int primeIndex = 1;
for (int candidate = 3;
primeIndex < primes.length;
candidate += 2) {
if (isPrime(candidate))
primes(primeIndex++] = candidate;
}
{
private static boolean isPrime(int candidate)
if (isLeastRelevantMultipleOfNextLargerPrimeFactor (candidate))
multiplesOfPrimeFactors.add(candidate);
}
return false;
return isNotMultipleOfAnyPreviousPrimeFactor(candidate);
{
private static boolean
isLeastRelevantMultipleOfNextLargerPrimeFactor(int candidate) {
int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()];
int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor;
return candidate == leastRelevantMultiple;
private static boolean
isNotMultipleOfAnyPreviousPrimeFactor(int candidate) {
for iint n = 1; n < multiplesOfPrimeFactors.size(): n++)
if (isMultipleOfNthPrimeFactor (candidate, n))
return false;
{
143
144
Listagem 10-8 (continuação)
PrimeGenerator.java
return true;
Capítulo 10: Classes
private static boolean
isMultipleOfNthPrimeFactor(int candidate, int n) {
return
candidate == smallestOddNthMultipleNotLessThanCandidate(candidate, n);
private static int
smallestOddNthMultipleNotLessThanCandidate(int candidate, int n)
int multiple = multiplesOfPrimeFactors.get (n);
while (multiple < candidate)
multiple += 2 * primes[n];
multiplesOfPrimeFactors.set(n, multiplel;
return multiple;
{
}
A primeira coisa que você deve perceber é que o programa ficou bem maior, indo de uma página
para quase três. Há diversas razões para esse aumento. Primeiro, o programa refatorado usa
nomes de variáveis mais longos e descritivos.
Segundo, ele usa declarações de funções e classes como uma forma de adicionar comentários ao
código. Terceiro, usamos espaços em branco e técnicas de formatação para manter a legibilidade.
Note como o programa foi dividido em três responsabilidades principais. O programa
principal está sozinho na classe PrimePrinter cuja responsabilidade é lidar com o ambiente
de execução. Ela será modificada se o método de chamada também for. Por exemplo, se esse
programa fosse convertido para um serviço SOAP, esta seria a classe afetada.
O RowColumnPagePrinter sabe tudo sobre como formatar uma lista de números em
páginas com uma certa quantidade de linhas e colunas. Se for preciso modificar a formatação da
saída, então essa seria a classe afetada.
A classe PrimeGenerator sabe como gerar uma lista de números primos. Note que ela não
foi feita para ser instanciada como um objeto.A classe é apenas um escopo prático no qual suas
variáveis podem ser declaradas e mantidas ocultas. Se o algoritmo para o cálculo de números
primos mudar, essa classe também irá.
Não a reescrevemos! Não começamos do zero e criamos um programa novamente. De fato,
se olhar os dois programas mais de perto, verá que usam o mesmo algoritmo e lógica para
efetuar as tarefas.
A alteração foi feita criando-se uma coleção de testes que verificou o comportamento preciso
do primeiro programa. Então, foram feitas umas pequenas mudanças, uma de cada vez. Após
cada alteração, executava-se o programa para garantir que o comportamento não havia mudado.
Um pequeno passo após o outro e o primeiro programa foi limpo e transformado no segundo.
Como organizar para alterar
Como organizar para alterar
145
Para a maioria dos sistemas, a mudança é constante. A cada uma, corremos o risco de o sistema
não funcionar mais como o esperado. Em um sistema limpo, organizamos nossas classes de
modo a reduzir os riscos nas alterações.
A classe Sq1 na Listagem 10.9 gera strings no formato SQL adequado dado um metadados
apropriado. É um trabalho contínuo e, como tal, ainda não suporta funcionalidade SQL, como as
instruções update. Quando chegar a hora da classe SQL suportar uma instrução update, teremos
de "abrir" essa classe e fazer as alterações. Qualquer modificação na classe tem a possibilidade
de estragar outro código na classe. É preciso testar tudo novamente.
Listagem 10-9
Classe que precisa ser aberta para alteração
public class Sql {
public Sql(String table, Column[] columns)
public String create()
public String insert (Object[] fields)
public String selectAll()
public String findByKey (String keyColumn, String keyValue)
public String select (Column column, String pattern)
public String select (Criteria criteria)
public String preparedInsert()
private String columnList (Column[] columns)
private String valuesList (Object[] fields, final Column[] columns)
private String selectWithCriteria(String criteria)
private String placeholderList (Column[] columns)
A classe Sql deve ser alterada quando adicionamos um novo tipo de instrução ou quando
mudarmos os detalhes de um único tipo de instrução - por exemplo, se precisarmos modificar
a funcionalidade do select para suportar "sub-selects". Esses dois motivos para alteração
significam que a classe Sq1 viola o SRP.
Podemos ver essa quebra da regra num simples ponto horizontal. O método realçado da SQL
mostra que há métodos privados, como o selectWithCriteria, que parecem se relacionar
apenas às instruções select.
O comportamento do método privado aplicado apenas a um pequeno subconjunto de
uma classe por ser uma heurística útil para visualizar possíveis áreas para aperfeiçoamento.
Entretanto, o indício principal para se tomar uma ação deve ser a alteração do sistema em si.
Se a classe Sq1 for considerada logicamente completa, então não temos de nos preocupar em
separar as responsabilidades. Se não precisamos da funcionalidade update num futuro próximo,
então devemos deixar a Sq1 em paz. Mas assim que tivermos de "abrir" uma classe, devemos
considerar consertar nosso projeto.
E se considerássemos uma solução como a da Listagem 10.10? Cada método de interface
pública definido na sq1 anterior na Listagem 10.9 foi refatorado para sua própria classe
derivada Sql. Note que os métodos privados, como valuesList, vão diretamente para
onde são necessários. O comportamento privado comum foi isolado para um par de classes
utilitárias, Where e ColumnList.
146 Capítulo 10: Classes
Listagem 10-10
Várias classes fechadas
abstract public class Sql {
public Sql(String table, Column[] columns)
abstract public String generate():
public class CreateSql extends Sql {
public CreateSql(String table, Column[] columns)
@Override public String generate()
public class SelectSql extends Sql {
public SelectSql(String table, Cclumn[] columns)
@Override public String generate()
public class InsertSql extends Sql {
public InsertSql(String table, Column[] columns, Object [] fields}
@Override public String generate()
private String valuesList (Object [] fields, final Column[] columns)
public class SelectWithCriteriaSql extends Sql
public SelectWithCriteriaSql(
String table, Column[] columns, Criteria criteria)
@Override public String generate()
public class SelectwithMatchSql extends Sgl
public SelectWithMatchSg1
}
{
String table, Column[] columns, Column column, String pattern)
@Override public String generate(
public class FindByKeySql extends Sql
public FindByKeySql(
String table, Column[] columns, String keyColumn, String keyValue)
@Override public String generate()
public class PreparedInsertSql extends Sql {
public PreparedInsertSql(String table, Column[] columns)
@Override public String generate(){
private String placeholderList (Column[] columns)
}
public class Where {
public Where(String criteria)
public String generate()
public class ColumnList {
public ColumnList (Column[] columns)
public String generate()
Como organizar para alterar 147
O código em cada classe se torna absurdamente simples. O tempo necessário para entendermos
qualquer classe caiu para quase nenhum. O risco de que uma função possa prejudicar outra se
torna ínfima. Do ponto de vista de testes, virou uma tarefa mais fácil testar todos os pontos
lógicos nesta solução, já que as classes estão isoladas umas das outras.
Tão importante quanto é quando chega a hora de adicionarmos as instruções update,
nenhuma das classes existentes precisam ser alteradas! Programamos a lógica para construir
instruções update numa nova subclasse de Sq1 chamada UpdateSql. Nenhum outro código no
sistema sofrerá com essa mudança.
Nossa lógica reestruturada da Sq1 representa o melhor possivel. Ela suporta o SRP e outro
princípio-chave de projeto de classe OO, conhecido como Princípio de Aberto-Fechado OCP4
(sigla em inglês). As classes devem ser abertas para expansão, mas fechadas para alteração.
Nossa classe Sq1 reestruturada está aberta para permitir novas funcionalidades através da criação
de subclasses, mas podemos fazer essa modificação ao mesmo tempo em que mantemos as
outras classes fechadas. Simplesmente colocamos nossa classe Updatesql em seu devido lugar.
Desejamos estruturar nossos sistemas de modo que baguncemos o mínimo possível quando
os atualizarmos. Num sistema ideal, incorporaríamos novos recursos através da expansão do
sistema, e não alterando o código existente.
Como isolar das alterações
As necessidades mudarão, portanto o código também. Aprendemos na introdução à OO que
há classes concretas, que contêm detalhes de implementação (código), e classes abstratas, que
representam apenas conceitos. Uma classe do cliente dependente de detalhes concretos corre
perigo quando tais detalhes são modificados. Podemos oferecer interfaces e classes abstratas
para ajudar a isolar o impacto desses detalhes.
Depender de detalhes concretos gera desafios para nosso sistema de teste. Se estivermos
construindo uma classe Portfolio e ela depender de uma API TokyoStockExchange externa
para derivar o valor do portfolio, nossos casos de testes são afetados pela volatilidade dessa
consulta. É difícil criar um teste quando obtemos uma resposta diferente a cada cinco minutos!
Em vez de criar a Portfolio de modo que ela dependa diretamente de TokyoStockExchange,
podemos criar uma interface StockExchange que declare um único método:
Desenvolvemos TokyoStockExchange para implementar essa interface. Também nos
certificamos se o construtor de Portfolio recebe uma referência a StockExchange como
parâmetro:
public Portfolio {
private StockExchange exchange;
public Portfolio (StockExchange exchange)
this.exchange = exchange;
}
11
}
Agora nosso teste pode criar uma implementação para testes da interface StockExchange
que simula a TokyoStockExchange. Essa implementação fixará o valor para qualquer símbolo
148 Capítulo 10: Classes
que testarmos. Se nosso teste demonstrar a compra de cinco ações da Microsoft para nosso
portfolio, programamos a implementação do teste para sempre retornar U$ 100 dólares por
ação. Nossa implementação de teste da interface StockExchange se reduz a uma simples
tabela de consulta. Podemos, então, criar um teste que espere U$ 500 dólares como o valor
total do portfolio.
public class PortfolioTest {
private FixedStockExchangeStub exchange;
private Portfolio portfolio;
@Before
protected void setUp() throws Exception {
exchange = new FixedStockExchangeStub();
exchange.fix("MSFT", 100);
portfolio = new Portfolio(exchange);
}
@Test
public void GivenFiveMSFTTotalShouldBe500() throws Exception
portfolio.add(5, "MSFT");
Assert.assertEquals(500, portfolio.value());
{
Se o um sistema estiver desacoplado o bastante para ser testado dessa forma, ele também
será mais flexível e terá maior capacidade de reutilização. A falta de acoplamento significa que
os elementos de nosso sistema ficam melhores quando isolados uns dos outros e das alterações,
facilitando o entendimento de cada elemento.
Ao minimizar o acoplamento dessa forma, nossas classes aderem a outro princípio de projeto de
classes conhecido como Princípio da Inversão da Independência,DIPS (sigla em inglês). Basicamente,
o DIP diz que nossas classes devem depender de abstrações, não de detalhes concretos.
Em vez de depender da implementação de detalhes da classe TokyoStockExchange, nossa
classe Portfolio agora é dependente da interface StockExchange, que representa o conceito
abstrato de pedir o preço atual de um símbolo. Essa isola todos os detalhes específicos da
obtenção de tal preço, incluindo sua origem.
Bibliografia
[RDD]: Object Design: Roles, Responsibilities, and Collaborations, Rebecca WirfsBrock et
al., Addison-Wesley, 2002.
[PPP]: Agile Software Development: Principles, Patterns, and Practices, Robert C. Martin,
Prentice Hall, 2002.
[Knuth92]: Literate Programming, Donald E. Knuth, Center for the Study of language and
Information, Leland Stanford Junior University, 1992.
THE BOTTLED CITY OF
KANDOR
11
Sistemas
por Dr. Kevin Dean Wampler
"Complexidade mata. Ela suga a vida dos desenvolvedores, dificulta o
planejamento, a construção e o teste dos produtos".
-Ray Ozzie, CTO, Microsoft Corporation
150 Capítulo 11: Sistemas
Como você construiria uma cidade?
Conseguiria tratar de todos os detalhes sozinho? Provavelmente não. Até mesmo o gerenciamento
de uma cidade é muito para uma pessoa só. Mesmo assim, as cidades funcionam (na maioria das
vezes). Isso porque possuem equipes de pessoas que gerenciam partes específicas da cidade,
sistema de abastecimento de água, de energia, de trânsito, a segurança pública, as normas
de construção, e assim por diante. Algumas dessas pessoas são responsáveis pela visão geral,
enquanto outros se focam nos detalhes.
0
As cidades também funcionam porque progrediram em níveis apropriados de e modularidade
os quais possibilitaram que indivíduos e os "componentes" pudessem trabalhar de forma eficiente,
mesmo sem ter noção da visão geral.
Embora equipes de software geralmente sejam organizadas dessa forma também, os sistemas
nos quais trabalham não costuma ter a mesma divisão de preocupações e níveis de. Um código
limpo nos ajuda a alcançar esses niveis mais baixos de. Neste capítulo, consideremos como manter
o código limpo nos níveis de mais altos, o nível do sistema.
Separe a construção e o uso de um sistema
Primeiramente, considere que construção é um processo diferente de utilização. Na épосa em
que escrevo este livro, há um novo hotel sendo construído que posso ver através da minha janela
em Chicago. Hoje só há pilares de concreto com uma grua e um elevador preso do lado de
fora. Todas as pessoas ocupadas lá usavam capacetes de proteção e roupas de trabalho. Em
mais ou menos um ano, o hotel ficará pronto. A grua e o elevador terão indo embora. O edificio
estará limpo, envolto em paredes com janelas de vidro e um tingimento atraente. As pessoas que
trabalharão e ficarão ali também serão diferentes.
Os sistemas de software devem separar o processo de inicialização - a criação dos objetos
do aplicativo e a "conexão" entre as dependências - da lógica em tempo de execução que
vem após a inicialização.
O processo inicial é uma preocupação da qual qualquer aplicativo deva tratar. E será a primeira
analisada neste capítulo. A separação de preocupações é uma das técnicas de projeto mais
antigas e importantes em nossa profissão.
Infelizmente, a maioria dos aplicativos não faz essa separação. O código do processo
de inicialização é específico e misturado na lógica em tempo de execução. Abaixo está um
exemplo típico:
public Service getService() {
if (service == null)
service = new
para a maioria dos casos?
MyServiceImpl(...); // Padrão bom o suficiente
return servicе;
}
Essa é a expressão INICIALIZAÇÃO/AVALIAÇÃO TARDIA, digna de vários méritos. Não
visualizamos a operação geral da construção a menos que realmente usemos o objeto, e, como
resultado, nosso tempo de inicialização pode ser mais rápido. Também garantimos que nunca
seja retornado null.
Separe a construção e o uso de um sistema 151
Entretanto, agora temos uma dependência codificada permanentemente em MyServiceImpl
e tudo o que seu construtor exige (o que omiti). Não podemos compilar sem resolver essas
dependências, mesmo se nunca usarmos um objeto desse tipo tempo de execução.
Efetuar testes pode ser um problema. Se MyServiceImp1 for um objeto grande, precisamos
garantir que um TEST DOUBLE' ou MOCK OBJECT seja atribuído à área de operação antes
deste método ser chamado no teste de unidade. Como temos lógica da construção misturada ao
processamento normal em tempo de execução, devemos testar todos os caminhos da execução (por
exemplo, o teste nu11 e seu bloco). Ter essas duas responsabilidades significa que o método faz mais
de uma coisa, portanto estamos violando, de certa forma, o Principio da Responsabilidade Única.
Talvez o pior de tudo é que não sabemos se MyServiceImplé o objeto correto em todas as
classes, e foi isso que indiquei no comentário. Por que a classe que possui este método precisa
enxergar o contexto global? Realmente jamais poderemos saber qual o objeto certo usar aqui? É
possível que um tipo seja o certo para todos contextos?
É claro que uma ocorrência de INICIALIZAÇÃO-TARDIA não é um problema sério.
Entretanto, costuma-se ter muitas instâncias de pequenas expressões como essa nos aplicativos.
Devido a isso, a estratégia de configuração global (se houver uma) fica espalhada pelo aplicativo,
com pouca modularidade e, geralmente, duplicação considerável.
Se formos cuidadosos ao construir sistemas bem estruturados e robustos, jamais devemos
deixar que expressões convenientes prejudiquem a modularidade. O processo de inicialização
da construção e atribuição de um objeto não são exceções. Devemos modularizar esse processo
de separadamente da lógica normal em tempo de execução, e nos certificar que tenhamos uma
estratégia global e consistente para resolver nossas dependências principais.
Separação do Main
Uma maneira de separar a construção do uso é simplesmente colocar todos os aspectos dela no
main ou em módulos chamados por ele, e modelar o resto do sistema assumindo que todos os
objetos foram construídos e atribuídos adequadamente (veja a Figura 11.1).
É fácil acompanhar o fluxo de controle. A função main constrói os objetos necessários para
o sistema e, então, os passa ao aplicativo, que simplesmente os usa. Note a direção das setas de
dependência cruzando a barreira entre o main e o aplicativo.
Todas apontam para a mesma direção, para longe do main. Isso significa que o
aplicativo não enxerga o main ou o processo de construção, mas apenas espera que tudo
seja devidamente construído.
Factories
Ο
É claro que de vez em quando precisamos passar o controle para o aplicativo quando um
objeto for criado. Por exemplo, em um sistema de processamento de pedidos, o aplicativo
deve criar instâncias do LineItem e adicionar a um Order. Neste caso, podemos usar
padrão ABSTRACT FACTORY para passar o controle ao aplicativo quando for preciso criar
os objetos LineItem, mas mantenha os detalhes dessa construção separada do código do
aplicativo (veja a Figura 11.2).
1. Mezzaros07
152
2:executa(oc)
main aplicativo
1:constrói
construidor 1.1constrói
<<cria>>
oc: Objeto
Construído
Capítulo 11: Sistemas
Figura 11.1: Separando o main() da construção de objetos
executa (factory) main OrderProcessing
<<cria>>
LineltemFactory Implementation
<<interface>>
LineltemFactory
+ makeLineltem
<<cria>> Lineltem
Figura 11.2: Separação da construção com uma factoryу
Novamente, observe que todas as dependências apontam de main para o aplicativo
OrderProcessing. Isso significa que ele está desacoplado dos detalhes de como criar um
LineItem. Essa capacidade é mantida em LineItemFactoryImplementation, que está no
mesmo lado da linha que o main. E mesmo assim o aplicativo possui controle total quando na
criação de instâncias de LineItem e pode até oferecer parâmetros do construtor específicos
ao aplicativo.
Injeção de dependência
Um mecanismo poderoso para separar a construção do uso é a Injeção de Dependência (DI,
sigla em inglês), a aplicação da Inversão de Controle (IoC, sigla em inglês ao gerenciamento de
dependência³. A IoC move as responsabilidades secundárias de um objeto para outros dedicados
3. Veja, [Fowler], por exemplo.
Desenvolvimento gradual 153
ao propósito que se deseja, dessa forma suportando o Princípio da Responsabilidade Ünica.
Em vez disso, ela deve passar essa responsabilidade para outro mecanismo "dominante", com
isso invertendo o controle. Como essa configuração é uma preocupação global, esse mecanismo
dominante geralmente será ou a rotina "principal" ou um contêiner de tarefa específica.
As consultas ao JNDI são implementações "parciais" da DI, na qual um objeto pede a um
servidor de diretórios um "serviço" com um nome específico.
MyService myService = (MyService) (jndiContext.lookup("NameOfMyService"));
O objeto chamador não controla qual tipo será realmente retornado (contanto que ele
implemente a interface apropriada, é claro), mas ele ainda determina ativamente a dependência.
A Injeção de Dependência Verdadeira vai mais além. A classe não determina diretamente
suas dependências; ela fica completamente passiva e oferece métodos de escrita (setters) ou
parâmetros de construtores (ou ambos) que serão usados para injetar as dependências. Durante
o processo de construção, o contêiner de DI instancia os objetos necessários (geralmente sob
demanda) e usa os parâmetros do construtor ou os métodos de escrita fornecidos para conectar
as dependências.
Quais objetos dependentes são usados realmente são especificados por um arquivo de
configuração ou diretamente programando-se no módulo de construção de tarefa específica.
O framework Spring oferece o melhor e mais conhecido contêiner de DI para Java. Você
define quais objetos conectar um ao outro em um arquivo de configuração, e depois solicita
objetos específicos pelo nome no código Java. Logo veremos um exemplo.
Mas e sobre as virtudes da INICIALIZAÇÃO-TARDIA? Essa expressão, de vez em
quando, ainda é útil com a DI. Primeiro, a maioria dos contêineres de DI não criará objetos
até que sejam necessários. Segundo, muitos desses contêineres oferecem mecanismos para
invocar factories ou construir proxies, que poderiam ser usados para sanar a AVALIAÇÃOTARDIA e otimizações semelhantes.
Desenvolvimento gradual
Vilarejos viram pequenas cidades, que viram cidades grandes. No início as ruas são estreitas e
quase não existem e, com tempo, elas são pavimentadas e, então, alargadas. Pequenos edificios
e terrenos vazios são substituídos por edificações maiores, algumas das quais acabarão virando
arranha-céus.
No começo, não há serviços, como abastecimento de energia, água, esgoto e Internet (oра!).
E só serão adicionados quando aumentar a densidade da população e de edificações.
Mas esse desenvolvimento não está livre de problemas. Quantas vezes, devido a um projeto
de "melhoria" das avenidas você dirigiu por engarrafamentos e se perguntou "Por que não
construíram as ruas largas o bastante desde o início?".
Mas não podia ter sido de outra forma. Como justificar o custo de construção de uma
via expressa de seis faixas passando no meio de uma cidade pequena já antecipando seu
desenvolvimento? Quem desejaria tal avenida passando por sua cidade?
É mito dizer que podemos conseguir um sistema "correto de primeira". Em vez disso, devemos
implementar apenas osfatos de hoje e, então, refatorar e expandir o sistema, implementando novos
154 Capítulo 11: Sistemas
fatos amanhã. Essa é a essência das agilidades iterativa e incremental. O desenvolvimento dirigido a
testes, a refatoração e o código limpo que produzem fazem com que isso tudo funcione em nível de
código. Mas e em nível de sistema? A estrutura do sistema não requer um pré-planejamento? Claro
que sim, ele não pode crescer gradualmente do simples para o complexo, pode?
Se comparados aos sistemas fisicos, os de software são únicos, e suas arquiteturas podem
crescer gradualmente se mantivermos uma separação devida de preocupações.
Como veremos, é a natureza efêmera dos sistemas de software que possibilitam isso.
Consideremos primeiro um contra-exemplo de uma arquitetura que não separa as preocupações
de forma adequada.
As arquiteturas EJB1 e EJB2 originais são um bom exemplo e, devido a isso, geram obstáculos
desnecessários para o crescimento orgânico. Considere uma Entity Bean para uma classe Bank
frequente. Uma entity bean é uma representação, na memória, dos dados relacionais, ou seja, a
linha de uma tabela.
Primeiro, você define uma interface local (no processo) ou remota (separada da JVM), que os
clientes usariam. A Listagem 11.1 mostra uma possível interface local:
Listagem 11-1
Interface EJB2 local para um EJB da classe Bank
}
package com.example.banking:
import java.util.Collections;
import javax.ejb.*;
public interface BankLocal extends java.ejb.EJBLocalobject
String getStreetAddrl() throws EJBException;
String getStreetAddr2() throws EJBException:
String getCity() throws EJBException;
String getState() throws EJBException;
String getZipCode() throws EJBException;
void setStreetAddr1(String streetl) throws EJBException;
void setStreetAddr2(String street2) throws EJBException;
void setCity(String city) throws EJBException;
void setState(String state) throws EJBExceptio;
void setzipCode (String zip) throws EJBException;
Collection getAccounts() throws EJBException;
void setAccounts (Collection accounts) throws EJBException;
void addAccount (AccountDTO account DTO) throws EJBException;
Exibi diversos atributos para o endereço do Bank e uma coleção de contas (account) que há
no banco (bank), cada uma com seus dados manipulados por um EJB de Account separado. A
Listagem 11.2 mostra a classe de implementação correspondente para o bean de Bank.
Desenvolvimento gradual
Listagem 11-2
Implementação da Entity Bean do EJB2 correspondente
package com.example.banking;
import java.util.Collections;
import javax.ejb.*;
public abstract class Bank implements javax.ejb.EntityBean
// Business logic...
public abstract String getStreetAddr1{);
public abstract String getStreetAddr2(1;
public abstract String getCity();
public abstract String getState();
public abstract String getZipCode()B
public abstract void setStreetAddr1 (String street1};
public abstract void setStreetAddr2 (String street2);
public abstract void setCity (String city);
public abstract void setState(String state);
public abstract void setZipCode(String zip);
public abstract Collection getAccounts();
public abstract void setAccounts (Collection accounts);
public void addAccount (Account DTO accountDTO) }
InitialContext context = new InitialContext{):
Account HomeLocal accountHome = context. lookup("AccountHomeLocal");
AccountLocal account = accountHome.create (account DTO);
Collection accounts = getAcccunts();
accounts.addiaccount);
//EJB container logic
public abstract void setId(Integer id);
public abstract Integer getId();
public Integer ejbCreate (Integer id) {... }
public void ejbPostCreate (Integer id) {...)
ctx) {)
155
// The rest had to be implemented but were usually empty:
public void setEntityContext (EntityContext
public void ejbActivate() {
public void unsetEntityContext() {}
public void ejbPassivate() 0
public void ejbLoad() {}
public void ejbStore() {)
public void ejbRemove() {)
Não mostrei a interface LocalHome correspondente - basicamente uma factory usada para
criar objetos - e nem um dos possíveis métodos de localização (consulta, ou queries) que
você pode adicionar. Por fim, você teve de criar um ou mais descritores de implementação
que especifiquem os detalhes do mapeamento de objetos relacionais para um armazenamento
permanente de dados, para a ação de transação desejada, para os limites de segurança, etc.
A lógica de negócio está fortemente acoplada ao "container" do aplicativo EJB2. Você
precisa criar subclasses dos tipos do container e fornecer muitos métodos do tipo lifecycle
exigidos pelo container.
Esse acoplamento ao container pesado dificulta o teste de unidade isolado.
É necessário fazer uma simulação do container, o que é dificil, ou gastar muito tempo
implementando EJBs e testes em um servidor real. Reutilizar externamente e de modo eficiente
a arquitetura EJB2 é impossivel devido ao forte acoplamento.
156 Capítulo 11: Sistemas
Por fim, mesmo a programação orientada a objeto foi prejudicada. Um bean não pode herdar
de outro. Note a lógica para adicionar uma nova conta. É comum nos beans do EJB2 definir
os "objetos de transferência de dados" (DTOs, sigla em inglês) que são basicamente "structs"
(estruturas) sem atividade alguma.
Isso costuma levar a tipos redundantes que possuem praticamente os mesmos dados, e requer
códigos padronizados para copiar dados de um objeto para outro.
Preocupações transversais
A arquitetura EJB2 chega perto de uma divisão real de preocupações em algumas áreas. Por
exemplo, a segurança, a comunicação desejada e alguns dos comportamentos de persistência são
declarados dos descritores de implementação, independentemente do código-fonte.
Note que preocupações como persistência tendem a atravessar os limites naturais dos objetos
de um domínio. Você deseja manter todos os seus objetos através da mesma estratégia, por
exemplo, usando um SGBD versus bancos de dados não-relacionais, seguindo certas convenções
de nomenclatura para tabelas e colunas, usando semânticas transacionais consistentes, etc.
Em princípio, você pode pensar em sua estratégia de persistência de uma forma modular
e encapsulada. Mesmo assim, na prática, é preciso basicamente espalhar por vários objetos
o mesmo código que implementa tal estratégia. Usamos o termo preocupações transversais
para preocupações como essa. Novamente, o framework de persistência e a lógica de domínio
(isolada) podem ser modulares. O problema é a minuciosa interseção desses domínios.
De fato, o modo como a arquitetura EJB trata da persistência, da segurança e das transações
"antecipa" a Programação Orientada a Aspecto (POA)- uma abordagem de propósito geral
para restaurar a modularidade para preocupações transversais.
Na POA, construções modulares chamadas aspectos especificam quais pontos no sistema
devem ter seus comportamentos alterados de uma forma consistente para suportar uma
determinada preocupação. Essa especificação é feita através de um mecanismo sucinto declarativo
ou programático.
Usando a persistência como exemplo, você declararia quais objetos e atributos (ou padrões
do tipo) devem ser mantidos e, então, delegar as tarefas de persistência ao seu framework de
persistência. O framework da POA efetua as alterações de comportamento de modo não-invasivo
no código a ser alterado. Vejamos três aspectos ou mecanismos voltados a aspectos em Java.
Proxies para Java
Os proxies para Java são adequados para situações simples, como empacotar chamadas de
métodos em objetos ou classes individuais. Entretanto, os proxies dinâmicos oferecidos no JDK
só funcionam com interfaces. Para usar proxies em classe, é preciso usar uma biblioteca de
manipulação de Bytecode, como CGLIB, ASM ou Javassist.
A Listagem 11.3 mostra o esqueleto para um Proxy do JDK que ofereça suporte à persistência
para nosso aplicativo Bank, cobrindo apenas os métodos para obter e alterar a lista de contas.
Proxies para Java
Listagem 11-3
Exemplo de proxy do JDK
// Bank.java (suppressing package names...)
import java.utils.*;
// The abstraction of a bank.
public interface Bank{
Collection<Account> getAccounts();
void setAccounts (Collection<Account> accounts);
// BankImpl.java
import java.utils.*;
/ The "Plain Old Java Object" (FOJO) implementing the abstraction.
public class BankImpl implements Bank {
private List<Account> accounts;
public Collection<Account> getAccounts () (
return accounts;
public void setAccounts (Collection<Account> accounts)
this.accounts = new ArrayList<Account>();
for (Account account: accounts) {
this.accounts.add (account);
{
// BankProxyHandler.java
import java.lang.reflect.*;
import java.util.*;
//"InvocationHandler" required by the proxy API.
public class BankProxyHandler implements InvocationHandler
private Bank bank;
public BankHandler (Bank bank) {
this.bank = bank;
}
// Method defined in InvocationHandler
{
public Object invoke (Object proxy, Method method, Object [] args)
throws Throwable {
String methodName = method.getName();
}
if (methodName.equals("getAccounts")) {
bank.setAccounts (getAccountsFromDatabase());
return bank.getAccounts ();
else if (methodName.equals ("setAccounts")) {
bank.setAccounts ((Collection<Account>) args [0]);
setAccountsToDatabase (bank.getAccounts());
return null;
else
157
158 Capítulo 11: Sistemas
Listagem 11-3 (continuação)
Exemplo de proxy do JDK
う
// Lots of details here:
protected Collection<Account> getAccountsFromDatabase() {...}
protected void setAccountsToDatabase(Collection<Account> accounts) {...
!/ Somewhere else...
Bank bank = (Bank) Proxy.newProxyInstance( Bank.class.getClassLoader(),
new Class [] { Bank.class ),
new BankProxyHandler (new BankImpl{))):
Definimos uma interface Bank, que será empacotada pelo proxy, e um Objeto Java Antigo e
Simples (POJO, sigla em inglês), chamado BankImpl, que implementa a lógica de negócio.
(Falaremos depois sobre POJOs).
A API do Proxy requer um objeto InvocationHandler ao qual ela chama para implementar
quaisquer chamadas ao método Bank feita pelo proxy. Nosso BankProxyHandler usa a API
de Reflexão do Java para mapear as chamadas aos métodos genéricos correspondentes em
BankImp1, e assim por diante.
Há bastante código aqui que é relativamente complicado, mesmo para esse caso simples.
Usar uma das bibliotecas de manipulação de bytes é igualmente desafiador. Este "volume" de código e sua complexidade são duas das desvantagens de usar proxies. Eles dificultam a criação de
um código limpo! Ademais, os proxies não oferecem um mecanismo para a especificação de certas
"partes" para execução através de todo o sistema - necessário para uma solução de POA real".
Frameworks de POA puramente Java
Felizmente, há ferramentas que podemtratarautomaticamente da maioria dos proxies padronizados.
Estes são usados internamente em diversos frameworks como, por exemplo, POA com Spring e
com JBoss, para implementar aspectos puramente em Java¹. No Spring, você escreve sua lógica
de negócio como Objeto Java Antigo e Simples. Os POJOs estão simplesmente centrados em
seus domínios. Eles não possuem dependências nas estruturas empresariais (ou qualquer outro
domínio). Dessa forma, em tese, eles são mais simples e fáceis de testar. A simplicidade relativa
facilita a garantia de que você esteja implementado as user stories correspondentes de modo
correto e a manutenção e o desenvolvimento do código em user stories futuras.
Você incorpora a estrutura necessária do aplicativo, incluindo as preocupações transversais,
como persistência, transações, segurança, fazer cache, transferência automática por falha
(failover), etc., usando arquivos de configuração com declarações ou APIs. Em muitos casos,
você realmente especifica os aspectos da biblioteca do Spring ou do JBoss, onde o framework
trata dos mecanismos do uso dos proxies em Java ou de bibliotecas de Bytecode transparentes
ao usuário. Essas declarações controlam o contêiner de injeção de dependência, que instancia os
objetos principais e os conecta sob demanda.
A Listagem 11.4 mostra um fragmento típico de um arquivo de configuração do Spring V2.5,
o app.xml3:
10. Para exemplos mais detalhados do API do Proxy e de seu uso, consulte, por exemplo. [Goetz].
Frameworks de POA puramente Java 159
Listagem 11-4
Arquivo de configuração do Spring 2.X
beans>
<bean id="appDataSource" class="org.apache.commons.dbcp.BasicDataSource destroy-method="close" p:driverClassName="com.mysql.jdbc.Driver p:url="jdbc:mysql://localhost:3306/mydb" p:username="me"/>
<bean id="bankDataAccessObject" class="com.example.banking.persistence.BankDataAccessObject" p:dataSource-ref="appDataSource"/>
<bean id="bank"
class="com.example.banking.model.Bank" p:dataAccessobject-ref="bankDataAccessobject"/
</beans>
Cada "bean" é como uma parte de uma "Boneca Russa", com um objeto domain para um Bank
configurado com um proxy (empacotado) por um objeto de acesso a dados (DAO, sigla em inglês),
que foi configurado com um proxy pela fonte de dados do driver JDBC. (Veja a Figura 11.3).
cliente
AppDataSource
BankDataAcessObject
Bank
Figura 11-3
A "Boneca Russa" do decorators
O cliente acha que está chamando getAccounts () em um objeto Bank, mas na verdade
está se comunicando com a parte mais externa de um conjunto de objetos DECORATOR14
aninhados que estendem o comportamento básico do POJO Bank. Poderiamos adicionar outros
DECORATOR para transações, efetuação de cache, etc.
No aplicativo, são necessárias algumas linhas para solicitar o contêiner da DI para os objetos
no nível mais superior do sistema, como especificado no arquivo XML.
XmlBeanFactory bf =
new XmlBeanFactory(new ClassPathResource("app.xml", getClass()));
Bank bank = (Bank) bf.getBean("bank");
Devido à necessidade de tão poucas linhas do código Java específico para o Spring,o aplicativo
està quase completamente desacoplado do Spring, eliminando todos os problemas de acoplamento
de sistemas como o EJB2.
14. [GOFI
160 Capítulo 11: Sistemas
Embora o XML possa ser detalhado e difícil de ler", a "política" especificada nesses arquivos
de configuração é mais simples do que o proxy complicado e a lógica do aspecto que fica oculta
e é criada automaticamente. Esse tipo de arquitetura é tão urgente que levou frameworks como
o Spring a efetuarem uma reformulação completa do padrão EJB para a versão 3. O EJB3
majoritariamente segue o modelo do Spring de suporte a declarações a preocupações transversais
usando os arquivos de configuração XML e/ou as anotações do Java 5.
A Listagem 11.5 mostra o EJB316com nosso objeto Bank reescrito.
Listagem 11-5
Um EJB do Bank no EBJ3
package com.example.banking.model:
import javax.persistence.*:
import java.util.ArrayList;
import java.util.Collection;
@Entity
@Table iname = "BANKS")
public class Bank implements java.io.Serializable {
@Id @GeneratedValue (strategy=GenerationType.AUTO)
private int id;
@Embeddable // An object "inlined" in Bank's DB row
public class Address {
}
protected String streetAddrl;
protected String streetAddr2;
protected String city;
protected String state;
protected String zipCode;
@Embedded
private Address address;
@OneToMany (cascade = CascadeType.ALL, fetch = FetchType. EAGER,
mappedBy="bank")
private Collection<Account> accounts = new ArrayList<Account>():
public int getId()
return id:
}
public void setId(int id) {
this.id = id;
public void addAccount (Account account)
account.setBank (this);
accounts.add(account);
public Collection<Account> getAccounts()
return accounts:
15. Pode-se simplificar o exemplo através de mecaxplo
{
modoa reduzir 
Aspectos do AspectJ
Listagem 11-5 (continuação)
Um EJB do Bank no EBJ3
public void setAccounts (Collection<Account> accounts)
this.accounts = accounts;
{
161
a
O código está muito mais limpo do que o do EJB2 original. Alguns dos detalhes da entidade
ainda estão lá, contidos nas anotações. Entretanto, como nenhuma daquelas informações está fora
das anotações, o código fica limpo, claro e, portanto, fácil de testar, fazer a manutenção, etc.
Se desejar, você pode mover algumas ou todas as informações nas anotações sobre
persistência para os descritores de implementação XML, deixando um POJO puro. Se os detalhes
de mapeamento da persistência não mudarem frequentemente, muitas equipes podem optar por
manter as anotações, entretanto com muito menos efeitos prejudiciais se comparado ao modo
invasivo do EJB2.
Aspectos do AspectJ
é
a
Finalmente, a ferramenta mais famosa para a separação de preocupações através de aspectos
a linguagem AspectJ", uma extensão do Java que oferece suporte de "primeira-classe"
aspectos como construtores de modularidade. A abordagem puramente Java oferecida pela POA
em Spring e em JBoss são o suficiente para 80-90% dos casos nos quais os aspectos são mais
úteis. Entretanto, o AspectJ proporciona uma série de ferramentas rica e poderosa para separar
preocupações. Sua desvantagem é ter de usar várias ferramentas novas e aprender a estrutura e o
uso das expressões de uma nova linguagem.
Uma "forma de anotação" do AspectJ recentemente lançada, na qual usam-se anotações
do Java 5 para definir aspectos usando um código puramente Java, Ameniza parcialmente essa
questão do uso de novas ferramentas. Ademais, o Framework do Spring possui uma série de
recursos que facilita ainda mais, para uma equipe com experiência limitada em AspectJ, a
inclusão de aspectos baseados em anotações.
Uma discussão completa sobre o AspectJ foge do escopo deste livro. Para isso, consulte
[AspectJ], [Colyer] e [Spring].
Testes na arquitetura do sistema
A capacidade de separar preocupações através de abordagens voltadas a aspectos não pode ser
exagerada. Se puder escrever a lógica de domínio de seu aplicativo usando POJOs, desacoplados
de qualquer preocupações acerca da arquitetura em nível de código, então é possível testar
sua arquitetura. Você pode desenvolvê-la do simples ao sofisticado, se for preciso, através da
adoção de novas tecnologias sob demanda. Não é necessário fazer um BDUF (Big Design Up
Front). De fato, um BDUF é até mesmo prejudicial por inibir a adaptação a mudanças devido à
resistência psicológica de descartar os esforços anteriores e devido à forma pela qual a escolha
da arquitetura influencia as ideias seguintes sobre o design.
Arquitetos de construções têm de fazer um BDUF porque não é prático fazer alterações
radicais na arquitetura para uma estrutura fisica grande após o início da construção".
17. Consulte [AspectJ] e [Colyer]. o inicio da construção.
162 Capítulo 11: Sistemas
Embora o software tenha sua própria mecânica, é economicamente prático fazer alterações
radicais se a estrutura separa de forma eficiente suas preocupações.
Isso significa que podemos iniciar um projeto de Software com uma arquitetura simples,
porém bem desacoplada, fornecendo rapidamente user stories que funcionem e, então,
adicionando mais infra-estrutura conforme o desenvolvemos. Alguns dos maiores sites da Web
alcançaram um grau de disponibilidade e performance muito altos através do uso de cache
sofisticado de dados, segurança, virtualização, e assim por diante, tudo feito de forma eficiente
e flexível porque os projetos com acoplamento mínimo são apropriadamente simples em cada
nível de e de escopo.
É claro que isso não quer dizer que iniciamos um projeto sem algum planejamento. Temos
certas expectativas a respeito do escopo, objetivos e programação gerais para o projeto, assim
como para a estrutura geral do sistema final. Todavia, devemos manter a capacidade de alterações
durante o desenvolvimento no caso de aperfeiçoamentos.
A arquitetura anterior EJB é uma das muitas APIs bem conhecidas que foram desenvolvidas
de modo exagerado e que comprometerama separação de preocupações. Mesmo tais APIs podem
ser destrutivas se realmente não forem necessárias. Uma boa API deve ficar oculta na maioria
das vezes, portanto a equipe expande a maioria de seus esforços criativos centralizados nas
user stories sendo implementadas. Caso contrário, os limites da arquitetura inibirão a entrega
eficiente do melhor serviço ao consumidor.
Para recapitular:
Uma arquitetura de sistema adequada consiste em domínios modularizados de
preocupações, cada um implementado com POJOs - Objetos Java Antigos e Simples, ou
outros. Os diferentes domínios são integrados uns aos outros com ferramentas de Aspectos
ou voltadas para eles pouco invasivas. Pode-se testar essa arquitetura da mesma forma
que se faz com o código.
Otimize a tomada de decisões
Modularidade e separação de preocupações descentralizam o gerenciamento e possibilitam a
tomada de decisões. Em um sistema consideravelmente grande, seja uma cidade ou um projeto
de software, ninguém pode tomar todas as decisões.
Todos sabemos que o melhor é designar responsabilidades às pessoas mais qualificadas.
Geralmente nos esquecemos que também é melhor adiar as decisões até o último momento.
Isso não é ser preguiçoso ou irresponsável, mas permitir-nos tomar decisões quando tivermos as
melhores informações possíveis.
Uma decisão prematura é tomada sem muitas informações adequadas. Teremos muito
menos retorno do consumidor, reflexão sobre o projeto e experiência com nossas escolhas de
implementação se decidirmos muito cedo.
A agilidade oferecida por um sistema POJO com preocupações modularizadas nos permite
uma otimização - decisões na hora certa - baseando-se nas informações mais recentes. Além
de também reduzir complexidade dessas decisões.
20. O termo mecánica de software foi usado primeiramente por [Kolence].
Conclusão 163
Use padrões sabiamente quando eles adicionarem um
valor demonstrativo
É uma coisa maravilhosa assistir à construção de uma infra-estrutura devido ao ritmo com que
as novas estruturas são construídas (mesmo num inverno rigoroso) e aos projetos extraordinários
possíveis com a tecnologia atual. Uma construção é um mercado maduro com partes altamente
otimizadas, métodos e padrões que evoluíram sob pressão por séculos.
Muitas equipes usavam a arquitetura EJB2 porque ela era padrão, mesmo com o advento de
planejamentos mais diretos e leves. Já vi equipes ficarem obcecadas com diversos padrões muito
populares e perderem o foco no quesito de implementação voltado para seus consumidores.
Os padrões facilitam a reutilização de ideias e componentes, recrutam pessoas com
experiência considerável, encapsulam boas ideias e conectam os componentes. Entretanto,
o processo de criação de padrões pode, às vezes, ser muito longo para que o mercado
fique à espera deles, e alguns padrões acabam se desviando das necessidades reais das
pessoas a quem eles pretendem servir.
Sistemas precisam de linguagens específicas
a um domínio
A construção de infra-estruturas, assim como a maioria dos domínios, desenvolveu uma linguagem
rica com vocabulário, expressões e padrões" que expressam informações essenciais de maneira
clara e concisa. Houve recentemente na área de softwares uma retomada do interesse pela criação
de Linguagens Especificas a um Dominio (DSLS, sigla em inglês)2, que são linguagens separadas,
pequenos scripts ou APIs em linguagens padrão que permitem a escrita do código num formato que
possa ser lido como uma prosa redigida por um especialista em domínio.
a
Uma boa DSL minimiza a "distância de comunicação" entre o conceito de um domínio e o
código que o implementa, assim como as práticas flexíveis otimizam a comunicação entre os
membros de uma equipe e a desta com suas partes interessadas. Se estiver implementando
lógica de um domínio na mesma linguagem usada pelo especialista em domínios, haverá menos
risco de erro na tradução do domínio para a implementação.
As Linguagens Específicas a um Domínio permitem todos os níveis de e todos os domínios
no aplicativo a ser expresso como POJOs, desde um nível mais alto até os detalhes de baixo
nível.
Conclusão
a
Os sistemas também devem ser limpos. Uma arquitetura invasiva afeta a agilidade e sobrepuja
lógica do domínio que, quando ofuscada, perde-se qualidade porque os bugs sese escondem
mais facilmente e dificulta a implementação. Se a agilidade for comprometida, a produtividade
também será e se perderão as vantagens do TDD. EM todos os níveis de, o objetivo deve
estar claro. Isso só acontecerá se você criar POJOs e usar mecanismos voltadosa aspectos para
incorporar de modo não invasivo outras preocupações de implementação.
21. O trabalho de [Alexander] exerceu influência especialmente na comunidade de softwares. lo de ua 4PI L
164 Capítulo 11: Sistemas
Esteja você desenvolvendo sistemas ou módulos individuais, jamais se esqueça de usar a coisa
mais simples que funcione.
Bibliografia
[Alexander]: Christopher Alexander, A Timeless Way of Building, Oxford University Press,
New York, 1979.
[AOSD]: Aspect-Oriented Software Development port, http://aosd.net
[ASM]: Página do ASM, http://asm.objectweb.org/
[AspectJ]: http://eclipse.org/aspectj
[CGLIB]: Code Generation Library, http://cglib.sourceforge.net/
[Colyer]: Adrian Colyer, Andy Clement, George Hurley, Mathew Webster, Eclipse AspectJ,
Person Education, Inc., Upper Saddle River, NJ, 2005.
[DSL]: Domain-specific programming language, http://en.wikipedia.org/wiki/Domainspecific_
programming_language
[Fowler]: Inversion of Control Containers and the Dependency Injection pattern, http://
martinfowler.com/articles/injection.html
[Goetz]: Brian Goetz, Java Theory and Practice: Decorating with Dynamic Proxies, http://www.
ibm.com/developerworks/java/library/j-jtp08305.html
[Javassist]: Página do Javassist, http://www.csg.is.titech.ac.jp/~chiba/javassist/
[JBoss]: Página do JBoss, http://jboss.org
[JMock]: JMock-A Lightweight Mock Object Library for Java, http://jmock.org
[Kolence]: Kenneth W. Kolence, Software physics and computer performance measurements,
Proceedings of the ACM annual conference-Volume 2, Boston, Massachusetts, pp. 1024-
1040, 1972.
[Spring]: The Spring Framework, http://www.springframework.org
[Mezzaros07]: XUnit Patterns, Gerard Mezzaros, Addison-Wesley, 2007.
[GOF]: Padrões de Projeto, Soluções Reutilizáveis de Software Orientado a Objetos, Gamma et
al., Addison-Wesley, 1996
12
Emergência
por Jeff Langr
Obtendo clareza através de um processo de emergência
E se houvesse quatro regras simples que você pudesse usar para lhe ajudar na criação de bons
projetos enquanto trabalhasse? E se ao seguir essas regras você obtivesse conhecimentos sobre a
estrutura e o modelo de seu código, facilitando a aplicação de princípios, como o SRP e o DIP?
E se essas quatro regras facilitassem a emergência de bons projetos? Muitos de nós achamos que
as quatro regras do Projeto Simples¹ de Kent Beck sejam de ajuda considerável na criação de um
software bem projetado.
1. [XPE]
166 Capítulo 12: Emergência
De acordo com Kent, um projeto é "simples" se seguir as seguintes regras:
• Efetuar todos os testes;
Sem duplicação de código;
Expressar o propósito do programador
• Minimizar o número de classes e métodos
Essas regras estão em ordem de relevância.
Regra 1 de Projeto Simples: Efetue todos os testes
Primeiro e acima de tudo, um projeto deve gerar um sistema que funcione como o esperado. Um
sistema pode ter um projeto perfeito no papel, mas se não há uma maneira simples de verificar se
ele realmente funciona como o planejado, então o que está escrito é dubitável.
Um sistema que é testado detalhadamente e que passa em todos os testes é um sistema passível
de testes. Isso pode parecer óbvio, mas é importante. Os sistemas que não podem ser testados não
podem ser verificados. Logo, pode-ser dizer que um sistema que não pode ser verificado, jamais
deveria ser implementado.
Felizmente, tornar nossos sistemas passíveis de teste nos direciona a um projeto no qual
nossas classes sejam pequenas e de propósito único. Simplesmente é mais fácil testar classes que
sigam o SRP. Quanto mais testes criarmos, mais seremos direcionados a coisas mais simples de
serem testadas. Portanto, garantir que nosso sistema seja completamente passível de teste nos
ajuda a cria projetos melhores.
O acoplamento forte dificulta a criação de testes. Portanto, similarmente, quanto mais testes
criarmos, usaremos mais princípios como o DIP e ferramentas como a injeção de dependência,
interfaces e de modo a minimizar o acoplamento. Assim, nossos projetos se tornam ainda
melhores.
O interessante é que ao seguir uma regra simples e óbvia a qual afirma que precisamos ter
testes e executá-los, afeta constantemente a integração de nosso sistema aos objetivos principais
da OO de acoplamento fraco e coesão alta. Criar testes leva a projetos melhores.
Regras de 2 a 4 de Projeto Simples: Refatoração
Agora que temos testes, podemos manter nosso código e nossas classes limpas. Para isso,
refatoramos gradualmente o código. Para cada linha nova que adicionarmos, paramos e refletimos
sobre o novo projeto. Acabamos de prejudicá-lo? Caso positivo, nós o limpamos e rodamos
nossos restes para nos certificar de que não danificamos nada. O fato de termos esses testes
elimina o receio de que, ao limparmos o código, podemos danificá-lo.
Durante a fase de refatoração, podemos aplicar qualquer conceito sobre um bom projeto
de software. Podemos aumentar a coesão, diminuir o acoplamento, separar preocupações,
modularizar as preocupações do sistema, reduzir nossas classes e funções, escolher nomes
melhores, e por aí vai. Ademais, também podemos aplicar as três regras finais do projeto simples:
eliminar a duplicação, garantir a expressividade e minimizar o número de classes e métodos.
Sem repetição de código
Sem repetição de código
167
A repetição de código é o inimigo principal para um sistema bem desenvolvido. Ela representa
trabalho, risco e complexidade desnecessária extras. A duplicação se apresenta de várias formas.
Linhas de código que parecem idênticas são, é claro, duplicações.
Linhas de código semelhantes geralmente podem ser modificadas de modo que fiquem mais
parecidas ainda para serem refatoradas mais facilmente. Há outros tipos de duplicação também,
como a de implementação. Por exemplo, podemos ter dois métodos na classe de uma coleção:
int size() {}
boolean isEmpty() {}
Poderíamos ter implementações separadas para cada método. O isEmpty poderia usar um
booleano, enquanto size poderia usar um contador. Ou poderíamos eliminar essa duplicação
colocando isEmpty na declaração de size:
boolean isEmpty() {
return 0 == size();
}
Criar um sistema limpo requer a eliminação de código repetido, mesmo que sejam algumas
linhas. Por exemplo, considere o código abaixo:
public void scaleToOneDimension(
float desiredDimension, float imageDimension)
if (Math.abs(desiredDimension - imageDimension)
errorThreshold)
return;
float scalingFactor = desiredDimension / imageDimension:
scalingFactor = (float) (Math.floor(scalingFactor + 100) * 0.01f);
Renderedop newImage = ImageUtilities.getScaledImage(
image, scalingFactor, scalingFactor);
image.dispose();
System.gc();
image = newImage;
public synchronized void rotate(int degrees) {
Renderedop newImage = ImageUtilities.getRotatedImage(
image, degrees);
}
image.dispose();
System.gc();
image = newImage;
A fim de manter esse código limpo, devemos eliminar a pequena quantidade de duplicação
entre os métodos scaleToOneDimension e rotate:
public void scaleToOneDimension(
float desiredDimension, float imageDimension)
168 Capítulo 12: Emergência
if (Math.abs (desiredDimension imageDimension) <
errorThreshold)
return;
float scalingFactor = desiredDimension / imageDimension;
scalingFactor = (float) (Math.floor (scalingFactor * 100) * 0.01f);
replaceImage (ImageUtilities.getScaledImage(
image, scalingFactor, scalingFactor))
public synchronized void rotate(int degrees) {
replaceImage (ImageUtilities.getRotatedImage (image, degrees)):
private void replaceImage (RenderedOp newImage)
image.dispose();
System.gc();
image = newImage;
}
{
Ao extrairmos a semelhança neste nível baixíssimo, começamos a notar as violações ao SRP.
Dessa forma, podemos mover um método recém-extraído para outra classe, o que aumentaria
sua visibilidade. Outra pessoa na equipe talvez perceba a oportunidade para abstrair mais a frente
novo método e usá-lo em um contexto diferente. Essa "pequena reutilização" pode reduzir
consideravelmente a complexidade do sistema. Entender como reutilizar uma pequena parte do
Ο
código é fundamental para fazer uso da utilização num escopo maior.
O padrão TEMPLATE METHOD² é uma técnica comum para a remoção de duplicação em
alto nível. Por exemplo:
public class VacationPolicy {
public void accrueUSDivisionVacation() {
/! codigo para calcular as ferias baseando-se nas horas
trabalhadas ate a data
!!
// codigo para garantir que as ferias cumpram o tempо
minimo nos EUA
// codigo para aplicar vaction ao registro de folha de
pagamento
public void accrueEUDivisionVacation() {
// codigo para calcular as ferias baseando-se nas horas
trabalhadas ate a data
// codigo para garantir que as ferias cumpram o tempо
minimo nos EUA
pagamento
2. [GOF].// codigo para aplicar vaction ao registro de folha de
Expressividade 169
}
O código ao longo de accrueUSDivisionVacationeaccrueEuropeanDivisionVacation
é praticamente o mesmo, com exceção do cálculo do tempo mínimo legal. Aquele pequeno
algoritmo é alterado baseando-se no cargo do funcionário.
Podemos eliminar essa duplicação óbvia aplicando o padrão Template Method.
abstract public class VacationPolicy {
public void accrueVacation() {
calculateBaseVacationHours();
alterForLegalMinimums();
applyToPayroll();
}
private void calculateBaseVacationHours() { /* ... */
abstract protected void alterForLegalMinimums();
private void applyToPayroll() { /* ... */ };
};
}
public class USVacationPolicy extends VacationPolicy {
@Override protected void alterForLegalMinimums() {
// Logica usada nos EUA
}
}
public class EUVacationPolicy extends VacationPolicy {
@Override protected void alterForLegalMinimums()
// Logica usada na Uniao Europeia
}
}
}
As subclasses preenchem o "buraco" no algoritmo accrue Vacation, fornecendo os únicos bits de
informações que não são repetidos.
Expressividade
A maioria de nós já teve de trabalhar num código intrincado. Muitos de nós mesmos já produzimos
alguns códigos confusos. Escrever códigos que nós entendamos é fácil, pois quando o fazemos,
possuímos um conhecimento profundo do problema que desejamos resolver. Mas outras pessoas
que pegarem esse mesmo código não terão esse mesmo grau de conhecimento.
A maioria dos custos de um projeto de software está na manutenção em longo prazo. A
fim de minimizar os possíveis danos conforme fazemos alterações, é crucial que sejamos
capazes de entender o que o sistema faz. Conforme os sistemas se tornam mais complexos, um
desenvolvedor leva cada vez mais tempo para compreendê-lo, e sempre há uma chance ainda
maior de mal entendidos.
Portanto, o código deve expressar claramente o propósito de seu autor. Quando mais claro o
autor tornar seu código, menos tempo outras pessoas terão de gastar para compreendê-lo. Isso
reduz os defeitos e o custo de manutenção. Você pode se expressar através da escolha de bons
nomes. Queremos ser capazes de ler o nome de uma classe ou função e não ficarmos surpresos
170 Capítulo 12: Emergência
quando descobrirmos o que ela faz. Você também pode se expressar mantendo pequenas suas
classes e funções, que costumam ser fáceis de nomear, criar e entender.
Você também pode se expressar se usar uma nomenclatura padrão. Os Padrões de Projeto,
por exemplo, são amplamente modos de comunicação e expressividade. Ao usar os nomes de
padrões, como COMMAND ou VISITOR, no nome de classes que implementem tais padrões,
você pode descrever de forma sucinta o seu projeto para outros desenvolvedores.
Testes de unidade bem escritos também são expressivos. Por exemplo, um objetivo principal
dos testes é funcionar como um meio de documentação. Uma pessoa que leia nossos testes
deverá ser capaz de obter um rápido entendimento do que se trata uma classe.
Mas a forma mais importante de ser expressivo é tentar. Muito freqüentemente, fazemos
nosso código funcionar e, então, partimos para o problema seguinte, sem considerar o bastante
em facilitar a leitura daquele código para outras pessoas. Lembre-se de que é muito mais provável
que essa outra pessoa seja você.
Portanto, tenha um pouco de orgulho em seu trabalho. Gaste um tempo em cada uma das
suas funções e classes. Escolha nomes melhores, divida funções grandes em menores e, de forma
geral, cuide do que você mesmo criou. Cuidar é um recurso precioso.
Poucas classes e métodos
Podem-se exagerar mesmo nos conceitos mais fundamentais, como a eliminação de duplicação,
expressividade do código e o SRP. Numa tentativa de tornar nossas classes e métodos pequenos,
podemos vir a criar estruturas minúsculas. Portanto, essa regra sugere que também devamos
manter a mínima quantidade de funções e classes.
Muitas classes e métodos, às vezes, são o resultado de um dogmatismo exagerado. Considere,
por exemplo, um padrão de programação que insiste em criar uma interface para cada classe.
Ou desenvolvedores que teimam em sempre separar campos e comportamentos em classes de
dados e classes de comportamentos. Deve-se evitar tal dogmatismo e adotar uma abordagem
mais pragmática.
Nosso objetivo é manter nosso sistema geral pequeno ao mesmo tempo em que também
mantemos nossas classes e funções pequenas. Lembre-se, contudo, de que essa regra é a de
menor prioridade das quatro de Projeto Simples. Portanto, embora seja importante manter baixa a
quantidade de classes e funções, é mais importante ter testes, eliminar a duplicação e se expressar.
Conclusão
Há uma série de práticas simples que possam substituir a experiência? Obviamente que não.
Por outro lado, as práticas descritas neste capítulo e neste livro são uma forma consolidada de
muitas décadas de experiência adquiridas pelos autores. Seguir as regras de projeto simples pode
e realmente incentiva e possibilita desenvolvedores a aderirem a bons princípios e padrões que,
de outra forma, levariam anos para aprender.
Bibliografia
[XPE]: Extreme Programming Explained: Embrace Change, Kent Beck, Addison-Wesley,
1999.
[GOF]: Padrões de Projeto, Soluções Reutilizáveis de Software Orientado a Objetos, Gamma et
al., Addison-Wesley, 1996
13
Concorrência
por Brett L. Schuchert
"Objetos são abstrações de procedimento. Threads são abstrações de agendamento."
- James O. Coplien¹
1. Correspondência privada
172 Capítulo 13: Concorrência
Escrever programas concorrentes limpos é dificil, muito. É muito mais fácil criar um código que
execute uma única thread, assim como um código multithread que pareça bom superficialmente,
mas que esteja defeituoso em um nível mais baixo. Esse código funciona bem até que se use o
sistema excessivamente.
Neste capítulo, discutiremos a necessidade da programação concorrente e das dificultadas
que ela representa. Depois, daremos várias sugestões para lidar com tais dificuldades e escrever
um código concorrente limpo. E, então, fechamos com as questões relacionadas aos códigos
concorrentes de teste.
Concorrência limpa é um assunto complexo, válido um livro só para ele. Nossa estratégia
aqui é apresentar uma visão geral e oferecer um tutorial mais detalhado em Concorrência II na
página 317. Se você estiver apenas curioso sobre concorrência, este capítulo será o suficiente por
enquanto. Se precisar de um conhecimento mais profundo, então leia também o tutorial.
Por que concorrência?
Concorrência é uma estratégia de desacoplamento. Ela nos ajuda a desacoplar o que é executado
de quando é executado. Em aplicativos com apenas uma thread, o que e quando ficam tão
fortemente acoplados que geralmente pode-se determinar o estado do aplicativo inteiro apenas
ao olhar o rastreamento de retorno na pilha.
Desacoplar o que de quando pode melhorar consideravelmente tanto as estruturas quanto a
taxa de transferência dos dados de um aplicativo. De uma perspectiva estruturada, o aplicativo
seria mais como muitos minicomputadores trabalhando juntos do que um único e grande
main(). Isso pode facilitar a compreensão do sistema e oferecer recursos melhores para separar
preocupações.
Considere, por exemplo, o modelo "Servlet" padrão dos aplicativos da Web. Esses sistemas
rodam sob o "guarda-chuva" de um contêiner Web ou EJB que gerencia parcialmente a
concorrência para você. Os servlets são executados de forma assíncrona sempre que chega um
pedido da Web.
O programador do servlet não tem de gerenciar todos os pedidos que chegam. Em princípio,
cada execução de servlet ocorre em seu próprio mundinho e fica desacoplado de todas as
execuções de outros servlets.
É claro que se fosse fácil assim, este capítulo não seria necessário. De fato, o desacoplamento
oferecido pelos contêineres Web está longe de serem perfeitos. Os programadores de servlets
têm se estar bem atentos de modo a garantir que seus programas concorrentes estejam corretos.
Mesmo assim, as vantagens do modelo de servlet são significantes.
Mas a estrutura não é o único motivo para se adotar a concorrência. Alguns sistemas
possuem limites de tempo de resposta e de taxa de transferência de dados que requerem soluções
concorrentes programadas manualmente. Por exemplo, considere um agregador de informações
com uma única thread que obtém os dados de diferentes sites da Web e os agrupa em um resumo
diário. Como esse sistema só possui uma thread, ele consulta um site de cada vez, sempre
terminando em um e seguindo para o próximo. A execução diária precisa ser feita em menos
de 24 horas. Entretanto, conforme mais websites são adicionados, o tempo também aumenta,
até que sejam necessárias mais do que 24 horas para obter todos os dados. Ter uma única thread
implica em muito tempo de espera nos sockets da Web para que a E/S termine.
Mitos e conceitos equivocados 173
Poderíamos melhorar o desempenho usando um algoritmo multithread que consulte mais de
um website por vez.
Ou pense num sistema que trate de um usuário de cada vez e exija apenas um segundo de tempo
por usuário. Esse sistema é o suficiente para poucos usuários, mas conforme o número aumentar,
também crescerá o tempo de resposta. Nenhum usuário quer entrar numa fila atrás de outros 150!
Poderíamos melhorar o tempo de resposta tratando de vários usuários concorrentemente.
Ou, então, imagine um sistema que interprete extensas séries de dados, mas que só ofereça
uma solução completa após processá-las todas. Talvez poderiam processar cada série em um
computador diferente, de modo que muitas séries de dados fossem processadas paralelamente.
Mitos e conceitos equivocados
E
dissemos também há motivos irrefutáveis para se adotar a concorrência. Entretanto, como
anteriormente, usar a concorrência é difícil. Se não você não for muito cauteloso, poderá criar
situações muito prejudiciais.
Considere os mitos e conceitos equivocados comuns abaixo:
• A concorrência sempre melhora o desempenho.
Isso pode ocorrer às vezes, mas só quando houver um tempo de espera muito grande que
possa ser dividido entre múltiplas threads ou processadores. Nenhuma situação é trivial.
• O projeto não muda ao criar programas concorrentes.
De fato, o projeto de um algoritmo concorrente pode ser consideravelmente diferente do
projeto de um sistema de apenas uma thread. O desacoplamento entre o que e quando
costuma ter grande impacto na estrutura do sistema.
• Entender as questões de concorrência não é importante quando se trabalha com uт
contêiner como um da Web ou um EJB.
Na verdade, é melhor saber apenas o que o seu contêiner está fazendo e como protegê-lo
das questões de atualização da concorrência e do deadlock (impasse) descrito mais adiante.
A seguir estão outras frases mais corretas em relação à criação de softwares concorrentes:
• A concorrência gera um certo aumento, tanto no desempenho como na criação de código
adicional.
• Uma concorrência correta é complexa, mesmo para problemas simples.
• Os bugs de concorrência geralmente não se repetem, portanto são frequentemente ignorados
como casos únicos2 em vez dos defeitos que realmente representam.
• A concorrência geralmente requer uma mudança essencial na estratégia do projeto.
Desafios
O que torna a programação concorrente tão difícil? Considere a simples classe seguinte:
public class X {
174 Capítulo 13: Concorrência
private int lastIdUsed;
public int getNextId() {
return ++lastIdUsed;
}
Digamos que criemos uma instância de x, atribuímos 42 ao campo lastIdUsed e, então a
compartilhemos entre duas threads. Agora, suponha que ambas as threads chamem o método
getNextId(). Haverá três resultados possíveis:
• Thread um recebe o valor 43, thread um recebe 44 e lastIdUsed é 44.
• Thread um recebe o valor 44, thread um recebe 43 e lastIdUsed é 44.
• Thread um recebe o valor 43, thread um recebe 43 e lastIdUsed é 43.
O surpreendente terceiro resultado3 ocorre quando ambas as threads se cruzam. Isso acontece
porque há muitos caminhos que elas podem seguir naquela linha de código Java, e alguns dos
caminhos geram resultados incorretos. Há quantos caminhos diferentes? Para poder responder a
essa questão, precisamos entender o que o Just-In-Time Compiler faz com o Bytecode gerado e
o que o modelo de memória do Java considera atômico.
Uma resposta rápida, usando o Bytecode gerado, é que há 12.870 caminhos possíveis de
execução para aquelas duas threads executadas dentro do método getNextId(). Se o tipo de
lastIdUsed mudar de int para 1ong, o número de caminhos possíveis cresce para 2.704.156.
É claro que a maioria desses caminhos gera resultados válidos. O problema é que alguns não.
Princípios para proteção da concorrência
A seguir está uma série de princípios e técnicas para proteger seus sistemas dos problemas de
códigos concorrentes.
Principio da Responsabilidade Única
O SRP5 declara que um dado método/classe/componente deve ter apenas um motivo para ser
alterado. O modelo de concorrência é complexo o suficiente para ser uma razão e ter seu próprio
direito de mudança e, portanto, merece ser separado do resto do código. Infelizmente, é muito
comum que se incluam diretamente os detalhes de implementação de concorrência em outro
código de produção. Abaixo estão alguns pontos a se levar em consideração:
O código voltado para a concorrência possui seu próprio ciclo de desenvolvimento, alteração
e otimização.
• O código voltado para a concorrência possui seus próprios desafios, que são diferentes e mais
dificeis do que o código não voltado para concorrência.
O número de maneiras pelas quais um código voltado para concorrência pode ser escrito de
Solução: limite o escopo dos dados 175
forma errada é desafiador o bastante sem o peso extra do código de aplicação que o cerca.
Recomendação: Mantenha seu código voltado para a concorrência separado do resto do código.
Solução: limite o escopo dos dados
Como vimos, duas threads que modificam o mesmo campo de um objeto compartilhado
podem interferir uma na outra, causando um comportamento inesperado. Uma solução é usar a
palavra reservada synchronized para proteger uma parte crítica do código que use aquele objeto
compartilhado. É importante restringir a quantidade dessas partes. Em quantos mais lugares os
dados compartilhados podem vir a ser alterados, maiores serão as chances de:
• Você se esquecer de proteger um ou mais daqueles lugares - danificando todos os códigos
que modifiquem aqueles dados compartilhados
• Haver duplicação de esforços para garantir que tudo esteja protegido de forma eficiente
(violação do Principio do Não Se Repita7, DRY, sigla em inglês);
• Dificultar mais a determinação da origem das falhas, que já são difíceis de encontrar.
Recomendação: Leve a sério o encapsulamento de dados; limite severamente o acesso a
quaisquer dados que possam ser compartilhados.
Solução: Use cópias dos dados
Essa é uma boa maneira de evitar que os dados compartilhados compartilhem seus dados. Em
alguns casos podem-se fazer cópias dos objetos e tratá-los como somente-leitura. Em outros
casos podem-se fazer cópias dos objetos, colocar os resultados de múltiplas threads naquelas
cópias e, então, unir os resultados numa única thread.
Se houver uma maneira fácil de evitar o compartilhamento de objetos, será muito pouco
provável que o código resultante cause problemas. Talvez você esteja preocupado com o custo de
toda essa criação de objetos adicionais. Vale a pena experimentar para descobrir se isso é de fato um
problema. Entretanto, se usar cópias dos objetos permitir ao código evitar a sincronização, o que se
ganha provavelmente compensará pelas criações adicionais e o aumento da coleta de lixo.
Solução: as threads devem ser as mais independentes
possíveis
Considere escrever seu código com threads de tal modo que cada thread exista em seu próprio
mundo, sem compartilhamento de dados com qualquer outra thread. Cadauma processa um pedido
do cliente, com todos os seus dados necessários provenientes de uma fonte não compartilhada e
armazenada como variáveis locais. Isso faz com que cada uma das threads se comporte como se
fossem a única thread no mundo, sem a necessidade de sincronização.
Por exemplo, as classes que criam subclasses a partir de HttpServlet recebem todas as suas
informações passadas por parâmetros nos métodos doGet e doPost. Isso faz cada Servlet
176 Capítulo 13: Concorrência
se agir como se tivesse sua própria máquina. Contanto que o código no Servlet use apenas
variáveis locais, não há como o Servlet causar problemas de sincronização. É claro que a
maioria dos aplicativos usando Servlets acabará adotando recursos compartilhados, como
conexões de bancos de dados.
Recomendação: Tente dividir os dados em subsistemas independentes que possam ser
manipulados por threads independentes, possivelmente em processadores diferentes.
Conheça sua biblioteca
O Java 5 oferece muitas melhorias para o desenvolvimento concorrente em relação às versões
anteriores. Há várias coisas a se considerar ao criar código com threads em Java 5:
Use as coleções seguras para threads fornecidas.
Use o framework Executor para executar tarefas não relacionadas.
Use soluções non-blocking sempre que possível.
Classes de bibliotecas que não sejam seguras para threads.
Coleções seguras para threads
Quando o Java estava no início, Doug Lea escreveu o livro precursor Concurrent Programming,
com o qual juntamente ele desenvolveu várias coleções seguras para threads, que mais tarde se
tornou parte do JDK no pacote java.util.concurrent. As coleções neste pacote são seguras para
situações multithread e funcionam bem. Na verdade, a implementação de ConcurrentHashMap
roda melhor do que a HashMap em quase todos os casos. Além de permitir leitura e escrita
concorrente simultânea e possuir métodos que suportam operações compostas comuns que, caso
contrário, não seriam seguras para thread. Se o Java 5 for o ambiente de implementação, comece
com a ConcurrentHashMap.
Há diversos outros tipos de classes adicionados para suportar o modelo de concorrência
avançado. Aqui estão alguns exemplos:
ReentrantLock
Semaphore
CountDownLatch
bloqueio que pode ser colocado em um método e liberado em outro.
implementação do semáforo clássico, um bloqueio com um contador.
bloqueio que espera por um número de eventos antes de liberar todas as
threads em espera. Isso permite que todas as threads tenhama mesma
chance de iniciar quase ao mesmo tempo.
Recomendação: Revise as classes disponiveis para você. No caso do Java, familiarize-se com
as classes java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks.
Conheça seus métodos de execução 177
Conheça seus métodos de execução
Há diversas maneiras de dividir o comportamento em um aplicativo concorrente. Para falarmos
sobre eles, precisamos entender algumas definições básicas.
Recursos limitados (Bound Resources)
Conexões de banco de dados e buffers de
leitura/escrita de tamanho fixo são alguns
exemplos.
Exclusão mútua (Mutual Exclusion)
Espera indefinida (Starvation)
Bloqueio infinito (Deadlock)
Livelock
recursos de um tamanho ou número fixo usado
em um ambiente concorrente.
apenas uma thread de cada vez pode acessar
dados ou recursos compartilhados.
uma thread ou um grupo de threads não pode
prosseguir por um tempo excessivamente longo
ou indefinidamente. Por exemplo: sempre
deixar que threads de execução rápida rodem
primeiro pode fazer com que threads que levem
mais tempo tenham de esperar muito caso as de
execução rápida forem infinitas.
duas ou mais threads esperam que a outra
termine. Cada thread possui um recurso que a
outra precisa e nenhuma delas pode terminar
até obter o tal recurso.
threads num entrave, cada uma tentando
fazer seu trabalho, mas se deparando com
outras "no caminho". Devido à repercussão,
as threads continuam tentando progredir, mas
não conseguem por um tempo excessivamente
longo ou indefinido.
Dadas essas definições, agora podemos discutir os modelos de execução usados na programação
concorrente.
Producer-Consumer
Uma ou mais threads producer criam alguma tarefa e a colocam em um buffer ou fila de espera.
Uma ou mais threads consumer pegam a tarefa da fila de espera e a finalizam. A fila de espera
entre as producers e as consumers é um bound resource (recurso limitado). Isso significa que as
producers devem esperar por espaço livre na fila de espera antes de colocar algo nela, e que as
consumers devem esperar até que haja algo na fila de espera para ser recuperado. A coordenação
entre as threads producers e consumers através da fila de espera requer que elas enviem sinais
entre si. As producers escrevem na fila de espera e sinalizam que ela não está mais vazia. As
consumers lêem a partir da fila de espera e sinalizam que ela não está mais cheia. Ambas ficam
na espera pela sinalização para poderem continuar.
178 Capítulo 13: Concorrência
Leitores e escritores10
Quando você tem um recurso compartilhado que serve principalmente como uma fonte de
informações para leitores, mas que de vez em quando é atualizada por escritores, a taxa de
transferência dos dados é um problema. Isso porque ela pode gerar espera indefinida (starvation)
e acúmulo de informações velhas. Permitir atualizações pode afetar a taxa de transferência dos
dados. Coordenar os leitores de modo que não leiam algo que um escritor esteja atualizando, e
vice-versa, é um equilíbrio dificil. Os escritores tendem a bloquear muitos leitores por bastante
tempo, afetando assim a taxa de transferência dos dados.
O desafio é equilibrar as necessidades tanto dos leitores como dos escritores para satisfazer
a operação correta, oferecer uma taxa de transferência de dados razoável e evitar a espera
indefinida. Uma estratégia simples é fazer os escritores esperarem até que não haja mais leitores
e, então, permitir que façam a atualização. Entretanto, se houver leitores constantes, os escritores
ficarão numa espera indefinida. Por outro lado, se houver escritores frequentemente e eles tiverem
prioridade, o impacto será na taxa de transferência de dados. Encontrar esse equilíbrio e evitar as
questões de atualização concorrente é do que trata o problema.
Dining Philosophers (Problema dos Filósofos)11
Imagine alguns filósofos sentados em uma mesa redonda. Coloca-se um garfo à esquerda de cada
um. Há uma grande tigela de espaguete no meio da mesa. Os filósofos passam o tempo pensando,
a menos que estejam com fome. Quando isso acontece, cada um pega seu garfo e come. Um
filósofo não pode comera menos que esteja segurando dois garfos. Se o filósofo à sua direita
ou esquerda já estiver usando um dos garfos que ele precisa, ele deverá esperar até que aquele
filósofo termine de comer e repouse o garfo novamente na mesa.
Quando um filósofo acaba de comer, ele devolve seu grafo à mesa e espera ficar com
fome novamente. Substitua os filósofos por threads e os garfos por recursos. Esse problema é
semelhante a muitos aplicativos corporativos nos quais os processos competem pelos recursos.
A menos que tenha sido meticulosamente desenvolvido, os sistemas que competem dessa forma
podem sofrer deadlock, livelock e queda na taxa de transferência de dados e no desempenho.
A maioria dos problemas de concorrência que você encontrará será uma variação desses três.
Estude esses algoritmos e crie soluções usando-os à sua maneira, de modo que, ao se deparar
com problemas de concorrência, você esteja mais preparado para resolvê-lo.
Recomendação: Aprenda esses algoritmos básicos e entenda suas soluções.
Cuidado com dependências entre métodos
sincronizados
Dependências entre métodos sincronizados causam pequenos bugs no código concorrente.
A linguagem Java possui a palavra reservada synchronized, que protege um único método.
Entretanto, se houver mais de um método sincronizado na mesma classe compartilhada, então
seu sistema pode ser sido escrito incorretamente¹2,
Mantenha pequenas as seções sincronizadas
Recomendação: evite usar mais de um método em um objeto compartilhado.
Haverá vezes em que você deverá usar mais de um método em um objeto compartilhado.
Neste caso, há três formas de deixar o código certo:
179
• Bloqueio voltado para o cliente: faça o cliente bloquear o servidor antes de chamar o primeiro
método e certifique-se de que o bloqueio inclua o código que chama o último método.
• Bloqueio voltado para o servidor: dentro do servidor, crie um método que bloqueie o servidor,
chame todos os métodos e, então, desbloqueie. Faça o cliente chamar o novo método.
⚫ Servidor extra: crie um servidor intermediário que efetue o bloqueio. Esse é um exemplo de
bloqueio voltado para o servidor, no qual o servidor original não pode ser alterado.
Mantenha pequenas as seções sincronizadas
A palavra reservada synchronized adiciona um bloqueio. Todas as seções do código protegidas
pelo mesmo bloqueio garantem que há apenas uma thread em execução para todas elas num
dado momento. Os bloqueios são prejudicíais, pois causam atrasos e adicionam trabalho extra.
Portanto, não queremos amontoar nosso código com instruções synchronized. Por outro lado,
devem-se proteger seções críticas¹³. Sendo assim, desejamos criar nosso código com o menor
número possível de seções críticas.
Alguns programadores ingênuos tentam conseguir isso tornando as seções críticas muito
grandes. Entretanto, estender a sincronização além da seção crítica mínima aumenta os conflitos
e prejudica o desempenho¹4.
Recomendação: mantenha suas seções sincronizadas as menores possiveis.
É difícil criar códigos de desligamento corretos
Criar um sistema que deva ficar para sempre executando é diferente de criar algo que funcione
por um tempo e, então, desligue de maneira adequada.
Ο
Obter um desligamento adequado pode ser dificil. Dentre os problemas comuns estão
deadlock¹5, com threads esperando por um sinal que nunca chega para continuar. Por exemplo,
imagine um sistema com uma thread pai que gera diversas threads filhas e, então, antes de liberar
seus recursos e desligar, espera que todas elas finalizem. E se uma das threads filhas sofrer
deadlock? O pai esperará para sempre e o sistema jamais desligará.
Ou pense num sistema semelhante que tenha sido instruído a desligar. A thread pai diz a todas
as suas filhas para abandonar suas tarefas e finalizar. Mas e se duas das filhas estiverem operando
como um par producer/consumer? Suponha que a thread producer receba o sinal da thread pai e
desligue imediatamente. A consumer talvez estivesse esperando uma mensagem da producer e
bloqueada de modo que não consiga receber o sinal para desligamento.
Ela ficaria presa esperando pela producer e nunca finalizar, evitando que a thread pai
também finalize.
Situações como essa não são tão incomuns assim. Portanto, se você precisar criar um código
concorrente que exija um desligamento apropriado, prepare-se para passar a maior parte de seu
tempo tentando fazer com que o desligamento ocorra com sucesso.
180 Capítulo 13: Concorrência
Recomendação: Pense o quanto antes no desligamento e faça com que ele funcione com êxito.
Vai levar mais tempo do que você espera. Revise os algoritmos existentes, pois isso é mais dificil
do que você imagina.
Teste de código com threads
Considerar que o código está correto, impossível. Testes não garantem que tudo esteja correto.
Entretanto, eles podem minimizar os riscos. Isso tudo é válido para uma solução com uma única
thread. Enquanto houver duas ou mais threads usando o mesmo código e trabalhando com os
mesmos dados compartilhados, as coisas se tornam consideravelmente mais complexas.
Recomendação: Crie testes que consigamexpor osproblemas e, então, execute-osfrequentemente,
com configurações programáticas e configurações e carregamentos de sistema. Se o teste falhar,
rastreie a falha. Não ignora uma falha só porque o teste não a detectou no teste seguinte.
É muito para se assimilar. Abaixo estão algumas recomendações mais detalhadas:
• Trate falhas falsas como questões relacionadas às threads.
Primeiro, faça com que seu código sem thread funcione.
Torne seu código com threads portátil.
Torne seu código com threads ajustável.
Rode com mais threads do que processadores.
Rode em diferentes plataformas.
• Altere seu código para testar e forçar falhas.
Trate falhas falsas como questões relacionadas às threads.
O código que usa threads causa falhas em coisas que "simplesmente não falham". A maioria dos
desenvolvedores não entende como o uso de threads interage com outros códigos (incluindo seus
autores). Os bugs em códigos com threads podem mostrar seus sintomas uma vez a cada mil ou
milhares de execuções.
Tentativas para repetir os erros no sistema podem ser frustrantes. Isso geralmente leva os
desenvolvedores a descartarem as falhas como raios cósmicos, uma pequena falha no hardware ou
outro tipo de "casos isolados". É melhor assumir que não existem casos isolados, os quais quanto mais
forem ignorados, mais o código será construído no topo de uma abordagem possivelmente falha.
Recomendação: Não ignore falhas de sistema como se fossem casos isolados.
Primeiro, faça com que seu código sem thread funcione
Isso pode parecer óbvio, mas não custa nada repetir. Certifique-se de que o código funcione sem
threads. Geralmente, isso significa criar POJOs que são chamados pelas suas threads.
Teste de código com threads 181
Os POJOs não enxergam as threads e, portanto, podem ser testados fora do ambiente com threads.
Quando mais locais no seu sistema você conseguir colocar tais POJOs, melhor.
Recomendação: Não procure bugs não relacionados a threads com os relacionados a elas ao
mesmo tempo. Certifique-se de que seu código funcione sem threads.
Torne seu código com threads portátil
Criar o código que suporte concorrência de modo que possa ser executado em diversas
configurações:
Uma thread, várias threads, variações conforme a execução.
O código com threads interage com algo que possa ser tanto real como artificial.
Execute com objetos artificiais que rodem de forma rápida, lenta e variável.
Configure testes de modo que possam rodam para um certo número de iterações.
Recomendação: Faça de seu código com threads especialmente portátil de modo que possa
executá-lo em várias configurações.
Torne seu código com threads ajustável
Obter o equilíbrio certo entre as threads requer testar e errar. O quanto antes, encontre maneiras
de cronometrar o desempenho de seu sistema sob variadas configurações. Possibilite para que
188 threads possam ser facilmente ajustadas. Considere permitir a alteração enquanto o sistema
estiver em execução.
Considere permitir um auto-ajuste baseando-se na taxa de transferência de dados e no uso do sistema.
Rode com mais threads do que processadores.
Coisas acontecem quando o sistema alterna entre as tarefas. A fim de incentivar a troca (swapping)
de tarefas, execute mais threads do que os processadores ou núcleos presentes. Quanto mais
frequentemente suas tarefas alternarem, mais provavelmente você descobrirá partes do código
que precisam de uma seção crítica ou que causa um deadlock.
Rode em diferentes plataformas
Em meados de 2007, elaboramos um curso sobre programação concorrente. O curso foi
desenvolvido essencialmente sob a plataforma OS X. Apresentamos à turma usando o Windows
XP rodando sob uma máquina virtual (VM, sigla em inglês). Criamos testes para demonstrar que
as condições para falhas ocorriam mais frequentemente num ambiente OS X do que em um XP.
Em todos os casos, sabia-se que o código testado possuía erros. Isso só reforçou o fato de que sistemas
operacionais diferentes têm diferentes políticas de tratamento de threads, cada uma afetando a execução
do código. O código multithread se comporta de maneira diferente em ambientes diversos!6.
Você deve rodar seus testes em cada possivel ambiente de implementação.
182 Capítulo 13: Concorrência
Recomendação: Execute o quanto antes e frequentemente seu código com threads em todas as
plataformas finais.
Altere seu código para testar e forçar falhas
É normal que as falhas se escondam em códigos concorrentes. Testes simples não costumam
expô-las.
Na verdade, elas costumam se ocultar durante o processamento normal e talvez só apareçam uma
vez em algumas horas, ou dias, ou semanas!
a
O motivo que torna os bugs em threads raros, esporádicos e de rara reincidência é que muito
poucos caminhos dos milhares possíveis através de uma seção realmente falham. Portanto,
probabilidade de se tomar um caminho falho é extraordinariamente pequena. Isso dificulta muito
a detecção e a depuração.
Como você poderia aumentar suas chances de capturar tais raras ocorrências? Você pode alterar
seu código e forçá-lo a rodar em diferentes situações através da adição de chamadas a métodos
como Object.wait(), Object.sleep(), Object.yield() eObject.priority().
Cada um deles pode afetar a ordem da execução, aumentando assim as chances de detectar uma
falha. É melhor que o código falhe o quanto antes.
Há duas opções para alteração:
• Manualmente
•Automatizada
Manualmente
Você pode inserir manualmente as chamadas a wait(), sleep(), yield()e priority(). É bom fazer
isso quando estiver testando uma parte capciosa do código.
O exemplo abaixo faz exatamente isso:
public synchronized String nextUrlOrNull() {
if(hasNext()) }
String url = urlGenerator.next();
Thread.yield(); // inserido para testar.
updateHasNext();
return url;
return null;
}
A chamada ao yield() inserida mudará os caminhos de execução tomados pelo código e
possivelmente fará o código falhar onde não havia erro antes. Se isso ocorrer, não foi porque
você adicionou uma chamada ao yield()¹", mas porque seu código já possuía a falha e isso
simplesmente a tornou evidente.
Teste de código com threads
Há muitos problemas com essa abordagem:
• É preciso encontrar manualmente os locais onde fazer isso.
Como saber onde e qual tipo de chamada colocar?
Deixar tal código em um código de produção sem necessidade atrasa o código.
Essa abordagem é um tiro no escuro. Você pode ou não encontrar falhas. De fato, as
probabilidades não estão a seu favor.
183
Precisamos de uma forma de fazer isso durante a fase de testes, e não na de produção. Também
temos de misturar com facilidade as configurações entre as diferentes execuções, o que aumentará
as chances de encontrar erros no todo.
Claramente, se dividirmos nosso sistema em POJOs que não saibam nada sobre as threads e as
classes que controlam o uso daquelas, será mais fácil encontrar os locąis apropriados para alterar
o código. Ademais, poderíamos criar muitas variações de testes que invoquem os POJOs sob
sistemas diferentes de chamadas a sleep, yield, e assim por diante.
Automatizada
Você poderia usar ferramentas como um framework orientado a aspecto, CGLIB ou ASM para
alterar seu código de forma automática. Por exemplo, você poderia usar uma classe com um
único método:
public class ThreadJigglePoint {
public static void jiggle() {
}
}
Você pode adicionar chamadas a ele em vários lugares de seu código:
public synchronized String nextUrlOrNull()
if(hasNext()) {
ThreadJiglePoint.jiggle();
String url = urlGenerator.next();
ThreadJiglePoint.jiggle();
updateHasNext();
ThreadJiglePoint.jiggle();
return url;
}
return null;
}
}
Agora você usa um aspecto simples que selecione aleatoriamente entre fazer nada, dormir ou
ficar passivo.
Ou imagine que a classe ThreadJigglePointtem duas implementações. A primeira implementa
jiggle, não faz nada e é usada na produção. A segunda gera um número aleatório para selecionar
entre dormir, ficar passivo ou apenas prosseguir. Se executar seus testes mil vezes com essa
184 Capítulo 13: Concorrência
aleatoriedade, talvez você revele algumas falhas. Se o teste passar, pelo menos você pode dizer
que teve a devida diligência. Embora um pouco simples, essa poderia ser uma opção razoável em
vez de uma ferramenta mais sofisticada.
Há uma ferramenta chamada ConTest, desenvolvida pela IBM que faz algo semelhante, mas
com um pouco mais de sofisticação.
A questão é testar o código de modo que as threads executem em ordens diferentes em
horas diferentes. A combinação de testes bem escritos e esse processo podem aumentar
consideravelmente as chances de encontrar erros.
Recomendação: Use essas estratégias de testes para desmascarar erros.
Conclusão
É dificil conseguir um código concorrente correto. Um código simples de se seguir pode se
tornar um pesadelo quando múltiplas threads e dados compartilhados entram em jogo. Se você
estiver criando esse tipo de código, é preciso mantê-lo rigorosamente limpo, ou haverá falhas
sutis e não frequentes.
Primeiro e acima de tudo, siga o Princípio da Responsabilidade Unica. Divida seu sistema
em POJOs que separem o código que enxerga threads daquele que as ignora. Certifique-se de
que você está testando apenas seu código que usa threads e nada mais. Isso sugere que ele deva
ser pequeno e centralizado. Tenha em mente as possíveis fontes de problemas com concorrência:
múltiplas threads operando em dados compartilhados ou usando uma fonte de recursos em
comum. Casos de limites, como desligar adequadamente ou terminar a iteração de um loор,
pode ser um risco a mais.
Estude sua biblioteca e conheça os algoritmos essenciais. Entenda como alguns dos recursos
oferecidos por ela dão suporte à solução de problemas semelhantes aos proporcionados
algoritmos essenciais.
Aprenda como encontrar partes do código que devam ser bloqueadas e as bloqueie - faça isso
apenas com as que realmente precisem ser. Evite chamar uma seção bloqueada a partir de outra,
pois isso requer um grande entendimento se algo deve ou não ser compartilhado. Mantenha a
quantidade de objetos compartilhados e o escopo do compartilhamento o mais curto possivel.
Altere os modelos dos objetos com os dados compartilhados para acomodar os clientes em vez
de forçar estes a gerenciar o estado compartilhado.
Problemas surgirão. Os que não aparecem logo geralmente são descartados como casos
isolados. Esses famosos "casos isolados" costumam ocorrer apenas na inicialização ou em
momentos aleatórios. Portanto, é preciso ser capaz de rodar repetidamente e constantemente seu
código com threads em muitas configurações e plataformas. A capacidade de ser testado, que
vem naturalmente com as Três Leis do TDD, implica certo nível de portabilidade, o que oferece
o suporte necessário para executar o código numa gama maior de configurações.
Você pode melhorar consideravelmente suas chances de encontrar erros se tomar seu
tempo para manipular seu código. Isso pode ser feito manualmente ou com alguma ferramenta
automatizada. Invista nisso o quanto antes. É melhor ter executado seu código com threads o
máximo possível antes de colocá-lo na fase de produção.
14
Refinamento Sucessivo
Caso de estudo de um analisador sintático de parâmetro em uma linha de comando
Este capítulo é um caso de estudo sobre como obter um refinamento com êxito. Você verá um módulo
que começará bem, mas não progredirá mais. Então, verá como ele será refatorado e limpo.
188 Capítulo 14: Refinamento Sucessivo
A maioria de nós, de tempos em tempos, tem de analisar a sintaxe dos parâmetros na linha de
comando. Se não tivermos um utilitário adequado, então simplesmente deixamos passar o array
de strings passado à função main. Há vários utilitários bons disponíveis, mas nenhum deles faz
exatamente o que quero. Portanto, decidi criar o meu próprio, que chamarei de Args.
É muito simples usá-lo. Basta criar uma classe Args com os parâmetros de entrada e uma
string de formato, e, então, consultar a instância Args pelos valores dos parâmetros.
Por exemplo, veja o exemplo abaixo:
Listagem 14-1
Uso simples de Args
}
public static void main(String[] args) {
try {
Args arg = new Args("1,p#,d*", args);
boolean logging = arg.getBoolean'l');
int port = arg.getInt('p');
String directory = arg.getString('d'):
executeApplication(logging, port, directory):
} catch (ArgsException e) {
System.out.printf("Argument error: %s\n", e.errorMessage());
Viu a simplicidade? Apenas criamos uma instância da classe Args com dois parâmetros. O
primeiro é a string do formato, ou esquema: "1, p#, d*." Ela declara três parâmetros na linha
de comando. O primeiro, -1, é booleano; o segundo, -p, é um inteiro; e o terceiro, -d, é uma
string. O segundo parâmetro do construtor Args é um array simples passado como parâmetro na
linha de comando para main.
Se o construtor retornar sem lançar uma ArgsException, então a linha de comando da entrada
é analisada e a instância Args fica pronta para ser consultada. Métodos como getBoolean,
getInteger e getString nos permite acessar os valores dos argumentos pelos nomes.
Se houver um problema, seja na string de formato ou nos parâmetros da linha de comando,
será lançada uma ArgsException. Para uma descrição adequada do que deu errado, consulte o
método errorMessage da exceção.
Implementação de Args
A Listagem 14.2 é a implementação da classe Args. Leia-a com bastante atenção. Esforcei-me
bastante no estilo e na estrutura, e espero que valha a pena.
Listagem 14-2
Args.java
package com.objectmentor.utilities.args:
import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;
import java.util.*;
public class Args {
private Map<Character, ArgumentMarshaler> marshalers;
Implementação de Args
Listagem 14-2
Args.java
private Set<Character> argsFound;
private ListIterator<String> currentArgument;
public Args (String schema, String[] args) throws ArgsException
marshalers = new HashMap<Character, ArgumentMarshaler>();
argsFound = new HashSet<Character>();
parseSchema (schema);
parseArgument Strings (Arrays.asList (args));
private void parseSchema (String schema) throws ArgsException
for (String element: schema.split())
t
if (element.length() > 0)
parseSchemaElement (element.trim());
{
private void parseSchemaElement (String element) throws ArgsException
char elementId = element.charAt (0);
String element Tail = element.substring{1);
validateSchemaElementId(elementId);
if (elementTail.length() == 0)
marshalers.put (elementId, new BooleanArgumentMarshaler());
else if (elementTail.equals ("*"))
marshalers.put (elementId, new StringArgumentMarshaler());
else if (elementTail.equals("#"))
marshalers.put (elementId, new IntegerArgumentMarshaler());
else if (elementTail.equals("##"))
marshalers.put (elementId, new DoubleArgumentMarshaler());
else if (elementTail.equals("[*]"))
marshalers.put (elementId, new StringArrayArgument Marshaler());
else
throw new ArgsException (INVALID_ARGUMENT_FORMAT, elementId, elementTail);
private void validateSchemaElementId(char elementId) throws ArgsException {
if (!Character.isLetter (elementid))
throw new ArgsException (INVALID_ARGUMENT_NAME, elementId, null);
private void parseArgumentStrings (List<String> argsList) throws ArgsException
for (currentArgument = argsList.listIterator(); currentArgument.hasNext();)
String argString = currentArgument.next!);
if (argString.startsWith("-")( )
parseArgumentCharacters(argString.substring(1});
} else {
currentArgument.previous();
break;
189
190 Capítulo 14: Refinamento Sucessivo
Listagem 14-2
Args. java
private void parseArgumentCharacters (String argChars) throws ArgsException for (int i = 0; i < argChars.length(); 1++) parseArgumentCharacter (argChars.charAt(i));
private void parseArgumentCharacter (char argChar) throws ArgsException {
ArgumentMarshaler m = marshalers.get (argChar!: if (m == null) {
throw new ArgsException (UNEXPECTED_ARGUMENT, argChar, null); else{
argsFound.add(argChar):
try {
m.set(currentArgument);
} catch (ArgsException ej {
e.setErrorArgumentId(argChar);
1
throw е:
public boolean has (char arg) {
return argsFound.contains(arg):
public int nextArgument () {
return currentArgument.nextIndex();
public boolean get Boolean(char arg) {
return BooleanArgumentMarshaler.getValue(marshalers.get (arg));
public String getString(char arg) {
return StringArgumentMarshaler.getValue (marshalers.get (arg)); }
public int getInt (char arg) {
}
return IntegerArgumentMarshaler.getValue(marshalers.get (arg)):
public double getDouble (char arg) {
return DoubleArgumentMarshaler.getValue (marshalers.get(arg)):
public String[] getStringArray(char arg) {
return StringArrayArgumentMarshaler.getValue (marshalers.get (arg));
Note que você consegue ler este esse código de cima para baixo sem ter de saltar muito para lá e para cá. Uma coisa que você teve de olhar um pouco mais a à frente é a definição de
ArgumentMarshaler, que deixei de fora propositalmente. Após ter lido com atenção esse código, você deve ser capaz de entender o que fazem a interface ArgumentMarshaler e seus derivados.
Irei lhe mostrar alguns deles agora (Listagem 14-3 até 14.6).
Implementação de Args
Listagem 14-3
ArgumentMarshaler.java
public interface ArgumentMarshaler {
}
void set(Iterator<String> currentArgument) throws ArgsException;
Listagem 14-4
ArgumentMarshaler.java
public class BooleanArgumentMarshaler implements ArgumentMarshaler {
private boolean bocleanValue = false;
public void set (Iterator<String> currentArgument) throws ArgsException
booleanValue = true;
public static boolean getValue (ArgumentMarshaler am) {
if (am != null && am instanceof BooleanArgumentMarshaler)
return ((BooleanArgumentMarshaler) am).booleanValue;
else
return false;
Listagem 14-5
StringArgumentMarshaler.java
import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;
public class StringArgumentMarshaler implements ArgumentMarshaler {
private String stringValue = ";
public void set (Iterator<String> currentArgument) throws ArgsException
try
stringValue = currentArgument.next ();
catch (NoSuchElementException e) {
throw new ArgsException (MISSING_STRING);
{
public static String getValue (ArgumentMarshaler am) {
if (am != null && am instanceof StringArgument Marshaler)
return ((StringArgumentMarshaler) am).stringValue;
else
return "";
191
192 Capítulo 14: Refinamento Sucessivo
Listagem 14-6
IntegerArgumentMarshaler.java
import static com.objectmentor.utilities.args.ArgsException. ErrorCode.*;
public class IntegerArgumentMarshaler implements ArgumentMarshaler
private int intValue = 0;
public void set (Iterator<String> currentArgument) throws ArgsException String parameter = null;
try(
parameter = currentArgument.next ();
intValue = Integer.parseInt (parameter);
} catch (NoSuchElementException e) }
throw new ArgsException (MISSING_INTEGER);
throw new ArgsException(INVALID_INTEGER, parameter);
} catch (NumberFormatException e)
}
}
public static int getValue (ArgumentMarshaler am) {
if (am != null && am instanceof IntegerArgumentMarshaler)
return ((IntegerArgumentMarshaler) am).intValue;
else
return 0;
O outro ArgumentMarshaler derivado simplesmente replica esse padrão para arrays tipo doubles
e String, e serve para encher esse capítulo. Deixarei-os para que você pratique neles.
Outra coisa pode estar lhe incomodando: a definição das constantes dos códigos de erro. Elas
estão na classe ArgsException (Listagem 14.7).
Listagem 14-7
ArgsException.java
import static com.objectmentor.utilities.args.ArgsException. ErrorCode.*;
public class IntegerArgumentMarshaler implements ArgumentMarshaler{
private int intValue = 0;
public void set (Iterator<String> currentArgument) throws ArgsException
String parameter = null;
}
try
parameter = currentArgument.next ();
intValue = Integer.parseInt (parameter);
} catch (NoSuchElementException el }
throw new ArgsException (MISSING INTEGER);
} catch (NumberFormatException e) {
throw new ArgsException (INVALID_INTEGER, parameter);
public static int getValue (ArgumentMarshaler am) {
if (am != null && am instanceof IntegerArgumentMarshaler)
return ((IntegerArgumentMarshaler) am).intValue;
else
return 0;
{
Implementação de Args
Listagem 14-7 (continuação)
ArgsException.java
public ArgsException (ErrorCode errorCode,
char errorArgumentId, String errorParameter) {
this.errorCode = errorCode;
this.errorParameter = errorParameter;
this.errorArgumentId = errorArgumentId;
public char getErrorArgumentId() {
return errorArgumentId;
}
public void setErrorArgumentId(char errorArgumentId)
t
this.errorArgumentId = errorArgumentId;
public String getErrorParameter() {
return errorParameter:
public void setErrorParameter (String errorParameter)
this.errorParameter = errorParameter:
1
public ErrorCode getErrorCode() {
return errorCode;
public void setErrorCode (ErrorCode errorCode) (
this.errorCode = errorCode:
}
public String errorMessage () {
switch (errorCode) {
case OK:
return "TILT: Should not get here.";
case UNEXPECTED ARGUMENT:
return String.format ("Argument -%c unexpected.", errorArgumentId):
case MISSING STRING:
return String.format ("Could not find string parameter for -%c.",
errorArgumentId);
case INVALID INTEGER:
return String.format("Argument -%c expects an integer but was '%s'."
errorArgumentId, errorFarameter);
case MISSING_INTEGER:
return String.format ("Could not find integer parameter for -%c."
errorArgumentId);
case INVALID_DOUBLE:
return String.format ("Argument -%c expects a double but was '%s'.",
errorArgumentId, errorParameter);
case MISSING_DOUBLE:
return String.format ("Could not find double parameter for -%c.",
errorArgumentId):
case INVALID_ARGUMENT_NAME:
return String.format ("'%c' is not a valıd argument name.", errorArgumentId):
193
194 Capítulo 14: Refinamento Sucessivo
Listagem 14-7 (continuação)
ArgsException.java
case INVALID_ARGUMENT_FORMAT:
return String.format("'\s' is not a valid argument format.",
errorParameter):
return"";
public enum ErrorCode{
OK, INVALID_ARGUMENT_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
MISSING_STRING,
MISSING_INTEGER, INVALID_INTEGER,
MISSING_DOUBLE, INVALID_DOUBLE)
É impressionante a quantidade de código necessária para esclareceros detalhes deste simples conceito.
Um dos motivos disso é que estamos usando uma linguagem particularmente prolixa. Como Java é
uma linguagem estática, é preciso digitar muitas palavras de modo a satisfazer o sistema de tipos. Em
linguagens como Ruby, Python ou Smalltalk, esse programa fica muito menor¹.
Leia o código novamente. Atente especialmente para os nomes escolhidos, o tamanho das
funções e o formato do código. Se você for um programador experiente, talvez faça uma crítica
aqui e ali e em relação ao estilo ou à estrutura. De modo geral, entretanto, espero que perceba
que este programa está bem escrito e possui uma estrutura limpa.
Por exemplo, deve ficar óbvio como adicionar um novo tipo de parâmetro, como uma data
ou um número complexo, e que essa inserção exige pouco esforço. Em suma, simplesmente
bastaria criar um derivado de ArgumentMarshaler, uma nova função getXXX e uma nova
instrução case na função parseschemaElement. Provelmente haveria também um na nova
ArgsException.ErrorCode e uma nova mensagem de erro.
Como fiz isso?
Permita-me tirar sua dúvida. Eu não criei simplesmente esse programa do início ao fim neste
formato que ele se encontra agora. E, mais importante, não espero que você seja capaz de
escrever programas limpos e elegantes de primeira. Se aprendemos algo ao longo das últimas
décadas, é que programar é mais uma arte do que ciência. Para criar um código limpo, é preciso
criar primeiro um "sujo" e, então limpá-lo.
Isso não deveria sersurpresa para você. Aprendemos essa verdade na escola quando nossos professores
tentavam (em vão) nos fazer escrever rascunhos de nossas redações. O processo, eles diziam, era
criar um rascunho e, depois, um segundo e, então, vários outros até que chegássemos à versão final.
Escrever redações limpas, eles tentavam nos dizer, é uma questão de refinamento constante.
A maioria dos programadores iniciantes (assim como muitos alunos do ensino fundamental)
não segue muito bem esse conselho. Eles acreditam que o objetivo principal é fazer o programa
funcionar e, uma vez conseguido, passam para a tarefa seguinte, deixando o programa "que
funciona" no estado em que estiver. A maioria dos programadores experientes sabe que isso é
suicídio profissional.
Args: o rascunho
Args: o rascunho
A Listagem 14.8 mostra uma versão anterior da classe Args. Ela "funciona" e está uma zona.
Listagem 14-8
Args.java (primeiro rascunho)
import java.text.ParseException;
import java.util.*;
public class Args {
private String schema;
private String[] args;
private boolean valid = true;
private Set<Character> unexpectedArguments = new TreeSet<Character>(0:
private Map<Character, Boolean> booleanArgs =
new HashMap<Character, Boolean>(1;
private Map<Character, String> stringArgs = new HashMap<Character, String>{);
private Map<Character, Integer> intArgs = new HashMap<Character, Integer>();
private Set<Character> argsFound = new HashSet<Character>();
private int currentArgument;
private char errorArgumentId ='0':
private String errorParameter = "TILT";
private ErrorCode errorCode = ErrorCode.OK:
private enum ErrorCode {
OK. MISSING STRING, MISSING_INTEGER, INVALID_INTEGER. UNEXPECTED_ARGUMENT}
public Args (String schema, String[] args) throws ParseException {
this.schema = schema;
this.args = args:
valid = parse();
private boolean parse() throws ParseException {
if (schema.length() == 0 && args.length == 0)
return true;
parseSchema();
try
parseArguments();
catch (ArgsException e) {
return valid;
private boolean parseSchema() throws ParseException
for (String element: schema.split()( }
195
196
Listagem 14-8 (continuação)
Args.java (primeiro rascunho)
if (element.length() > 0)
String trimmedElement = element.trim();
parseSchemaElement (trimmedElement);
}
return true;
Capítulo 14: Refinamento Sucessivo
private void parseSchemaElement (String element) throws ParseException {
char elementId = element.charAt (0);
String elementTail = element.substring(1);
validateSchemaElementId(elementId);
if (isBooleanSchemaElement (elementTail))
parseBooleanSchemaElement (elementId);
else if (isStringSchemaElement (elementTail))
parseStringSchemaElement (elementId);
else if (isIntegerSchemaElement (elementTail))
parseIntegerSchemaElement (elementId);
else {
throw new ParseException(
{
String.format ("Argument: %c has invalid format: %s.",
elementId, elementTail), 0);
private void validateSchemaElementId(char elementId) throws ParseException
if (!Character.isLetter(elementId)) (
throw new ParseException(
"Bad character:" + elementId + "in Args format:" + schema, 0);
3
private void parseBooleanSchemaElement (char elementId!
booleanArgs.put (elementId, false):
private void parseIntegerSchemaElement (char elementId)
intArgs.put (elementId, 0);
private void parseStringSchemaElement (char elementId)
stringArgs.put (elementId, ""
3
{
{
private boolean isStringSchemaElement (String elementTail)
return elementTail.equals("*");
{
private boolean isBooleanSchemaElement (String elementTail)
return elementTail.length(} == 0;
private boolean isIntegerSchemaElement (String elementTail)
return elementTail.equals("#");
{
Args: o rascunho
Listagem 14-8 (continuação)
Args.java (primeiro rascunho)
private boolean parseArguments() throws ArgsException }
for
}
 (currentArgument = 0; currentArgument < args.length; currentArgument++)
}
String arg = args [currentArgument]:
parseArgument (arg);
return true;
private void parseArgument (String arg) throws ArgsException
if (arg.startswith("-"))
parseElements (arg);
private void parseElements (String arg) throws ArgsException.{
for (int i = 1; i < arg.length(); i++)
parseElement (arg.charAt(i));
}
private void parseElement (char argChar) throws ArgsException
if (setArgument (argChar))
argsFound.add(argChar);
else{
unexpectedArguments.add(argChar);
errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
valid = false;
}
}
private boolean setArgument (char argChar) throws ArgsExcepticn
if (isBooleanArg(argChar))
setBooleanArg (argChar, true);
else if (isStringArg(argChar))
setStringArg(argChar);
eise if (isIntArg (argChar))
set IntArg(argChar);
else
return false;
return true;
}
private boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);}
private void setIntArg(char argChar) throws ArgsException
currentArgument++;
String parameter = null;
try (
}
parameter = args [currentArgument];
intArgs.put (argChar, new Integer (parameter));
catch (ArrayIndexOutOfBoundsException e) {
valid = false;
errorArgumentId = argChar;
errorCode = ErrorCode.MISSING_INTEGER;
{
197
198
Listagem 14-8 (continuação)
Args. java (primeiro rascunho)
throw new ArgsException();
} catch (NumberFormatException e) {
valid = false;
errorArgumentId = argChar;
errorParameter = parameter:
errorCode = ErrorCode.INVALID_INTEGER;
throw new ArgsException():
Capítulo 14: Refinamento Sucessivo
private void setStringArg(char argChar) throws ArgsException {
currentArgument++;
try
stringArgs.put (argChar, args [currentArgument]):
} catch (ArrayIndexOutOfBoundsException e) {
valid = false;
errorArgumentId = argChar;
errorCode = ErrorCode.MISSING_STRING;
throw new ArgsException();
private boolean isStringArg(char argChar) {
return stringArgs.containsKey (argChar);
1
3
private void setBooleanArg(char argChar, boolean value)
booleanArgs.put (argChar, value);
private boolean isBooleanArg(char argChar) {
return booleanArgs.containsKey (argChar);
public int cardinality() {
return argsFound.size();
}
public String usage() {
if (schema.length() > 01
return "-[" + schema +"]";
else
return "";
public String errorMessage() throws Exception
switch (errorCode) {
case OК:
throw new Exception("TILT: Should not get here.");
case UNEXPECTED_ARGUMENT:
return unexpectedArgumentMessage();
case MISSING_STRING:
return String.format ("Could not find string parameter for -%c.", errorArgumentId):
Args: o rascunho
Listagem 14-8 (continuação)
Args.java (primeiro rascunho)
case INVALID INTEGER:
return String.format!"Argument -%c expects an integer but was '%s'.".
errorArgumentId, errorParameter);
case MISSING_INTEGER:
return String.format("Could not find integer parameter for -%c.",
errorArgumentId;
return "";
private String unexpectedArgumentMessage() {
StringBuffer message = new StringBuffer ("Argument (s)
for (char c: unexpectedArguments) {
message.append(c);
message.append(" unexpected.");
return message.toString():
}
private boolean falseIfNull (Boolean b) {
return b != null && b;
private int zeroIfNull(Integer i)}
return i == null ?0 : i;
private String blankIfNull(String s) {
return s == null?"*": S;
public String getString(char arg) {
return blankIfNull(stringArgs.get(arg));
}
public int getInt (char arg) {
return zeroIfNull(intArgs.get (arg));
}
public boolean get Boolean(char arg) {
return falseIfNull(booleanArgs.get (arg));
}
public boolean has (char arg) {
return argsFound.containsiarg);
}
public boolean isValid() {
return valid;
private class ArgsException extends Exception {
199
200 Capítulo 14: Refinamento Sucessivo
Espero que sua reação inicial a esse pedaço de código seja "Realmente estou feliz por ele não
tê-lo deixado assim!". Se você se sentir assim, então lembre-se de como as outras pessoas ficarão
ao ler um código que você deixou num formato de "rascunho".
Na verdade, "rascunho" é provavelmente a coisa mais gentil que se possa falar desste código.
Está claro que é um trabalho em progresso. Quantidade de instâncias de variáveis é assustadora.
Strings estranhas, como "TILT", "HashSets" e "TreeSets, e os blocos try...catch...
catch ficam todas amontoadas.
Eu não queria criar um código amontoado. De fato, eu estava tentando manter as coisas
razoavelmente bem organizadas. Você provavelmente pode deduzir isso dos nomes que escolhi
para as funções e as variáveis, e o fato de que mantive uma estrutura bruta. Mas, obviamente,
me afastei do problema.
A bagunça cresceu gradualmente. As versões anteriores não estavam tão bagunçadas assim. Por
exemplo, a Listagem 14.9 mostra uma versão antiga na qual só funcionavam os parâmetros do
tipo booleano.
Listagem 14-9
Args.java (Booleano apenas)
package com.objectmentor.utilities.getopts;
import java.util.;
public class Args{
private String schema;
private String[l args:
private boolean valid;
private Set<Character> unexpectedArguments = new TreeSet<Character>();
private Map<Character, Boolean> booleanArgs =
new HashMap<Character, Boolean>():
private int numberofArguments = 0;
public Args (String schema, String[] args) {
3
this.schema = schema;
this.args = args;:
valid = parsei):
public boolean isValid() {
return valid;
private boolean parse() {
}
if (schema.length() == 0 && args.length == 0
return true;
parseSchema();
parseArguments():
return unexpectedArguments.size() == 0;
private boolean parseSchema() {
for (String element: schema.spliti",")) 1
parseSchemaElement (element);
}
Args: o rascunho
Listagem 14-9 (continuação)
Args.java (Booleano apenas)
return true;
private void parseSchemaElement(String element) {
if (element. length(} == 1) {
}
parseBooleanSchemaElement(element):
private void parseBooleanSchemaElement (String element)
char c = element.charAt (0);
if (Character.isLetter(c)) (
booleanArgs.put(c, false):
}
private boolean parseArguments() {
for (String arg : args)
parseArgument (arg);
return true;
private void parseArgument(String arg) {
if (arg.startsWith("-")
parseElements(arg);
private void parseElements(String arg} {
for (int i = 1; i < arg.length(); i++)
parseElement (arg.charAt(ij);
}
private void parseElement (char argChar)
if (isBoolean(argChar)) {
numberOfArguments++;
setBooleanArg(argChar, true!;
} else
unexpectedArguments.add(argChar);
}
private void setBooleanArg(char argChar, boolean value)
booleanArgs.put (argChar, value);
private boclean isBoolean (char argChar) {
return booleanArgs.containskeylargChar);
public int cardinality() {
return numberofArguments;
public String usage() {
if (schema.length(} > 0)
return "-["+schema+"]";
}
201
202
Listagem 14-9 (continuação)
Args.java (Booleano apenas)
else
return
0
public String errorMessage() {
if (unexpectedArguments.size() > 0) {
}
return unexpectedArgumentMessage!); else
return
Capítulo 14: Refinamento Sucessivo
private String unexpectedArgumentMessage() {
StringBuffer message = new StringBuffer ("Argument(s) -");
for (char c: unexpectedArguments) message.append(c);
message.append(" unexpected.");
return message.toString();
}
public boolean get Boolean(char arg){
return booleanArgs.get (arg!;
Embora você possa encontrar muitas formas de criticar esse código, ele não está tão ruim assim.
Ele está compacto, simples e fácil de entender. Entretanto, dentro dele é fácil identificar as
"sementes" que bagunçarão o código. Está bem claro como ele se tornará uma grande zona.
Note que a bagunça futura possui apenas mais dois tipos de parâmetros do que estes: Stringe
integer. Só essa adição tem um impacto negativo enorme no código. Ele o transformou de algo
que seria razoavelmente passível de manutenção em algo confuso cheio de bugs.
Inseri esses dois tipos de parâmetro de modo gradual. Primeiro, adicionei o parâmetro do tipo
String, que resultou no seguinte:
Listagem 14-10
Args.java (Booleano e String)
package com.objectmentor.utilities.getopts;
import java.text.ParseException;
import java.util.*;
public class Args }
private String schema;
private String[] args;
private boolean valid = true;
private Set<Character> unexpectedArguments = new TreeSet<Character>(); private Map<Character, Boolean> booleanArgs =
new HashMap<Character, Boolean>();
Args: o rascunho
Listagem 14-10 (continuação)
Args.java (Booleano e String)
private Map<Character, String> stringArgs
new HashMap<Character, String>();
=
private Set<Character> argsFound = new HashSet<Character>():
private int currentArgument;
private char errorArgument = '\0';
enum ErrorCode
OK, MISSING_STRING}
private ErrorCode errorCode = ErrorCode.OK;
public Args (String schema, String[] args) throws ParseException {
this.schema = schema;
this.args = args;
valid = parse():
}
private boolean parse() throws ParseException {
if (schema. length() == 0 && args.length == 0)
return true;
parseSchema();
parseArguments()⑆
return valid;
private boolean parseSchema() throws ParseException {
for (String element: schema.split(",0(
if (element.length() > 0) {
String trimmedElement = element.trim();
parseSchemaElement(trimmedElement):
return true;
}
private void parseSchemaElement (String element) throws ParseException
char elementId = element.charAt (0);
String elementTail = element.substring(1);
validateSchemaElementId(elementId);
if (isBooleanSchemaElement(elementTail})
parseBooleanSchemaElement (elementId);
else if (isStringSchemaElement (elementTaili)
parseStringSchemaElement (elementId):
private void validateSchemaElementId(char elementId) throws ParseException {
if (!Character.isLetter(elementId)) {
throw new FarseException
"Bad character:" + elementId + "in Args format:"+ schema, 0):
private void parseStringSchemaElement (char elementId) {
stringArgs.put (elementId, "*);
203
204 Capítulo 14: Refinamento Sucessivo
Listagem 14-10 (continuação)
Args.java (Booleano e String)
private boolean isStringSchemaElement (String elementTail)
return elementTail.equals("*"):
}
private boolean isBooleanSchemaElement (String elementTail)
return elementTail.length() == 0;
private void parseBooleanSchemaElement (char elementId)
booleanArgs.put (elementId, false):
private boolean parseArguments()
fer (currentArgument = 0; currentArgument < args.length; currentArgument++)
}
String arg = args [currentArgument];
parseArgument (arg);
return true;
private void parseArgument (String arg) {
if (arg.startsWith("-"))
parseElements (arg);
private void parseElements (String arg) {
for (int i = 1; i< arg.length(); i++)
parseElement (arg.charAt (i));
private void parseElement (char argChar! {
if (setArgument (argChar))
argsFound.add(argChar);
else
unexpectedArguments.add(argChar);
valid = false;
private boolean setArgument (char argChar) {
boolean set = true;
if (isBoolean(argChar))
setBooleanArg (argChar, true);
else if (isString(argChar))
setStringArg (argChar, "");
else
set = false;
return set;
}
private void setStringArg(char argChar, String s) {
currentArgument++;
try {
Args: o rascunho
Listagem 14-10 (continuação)
Args.java (Booleano e String)
stringArgs.put (argChar, args[currentArgument]);
} catch (ArrayIndexOutOfBoundsException e! {
valid = false;
errorArgument = argChar;
errorCode = ErrorCode.MISSING_STRING;
private boolean isString(char argChar)
return stringArgs.containsKey (argChar);
private void setBooleanArg (char argChar, boolean value)
booleanArgs.put (argChar, value):
}
private boolean isBoolean(char argChar) (
return booleanArgs.containsKey(argChar!;
public int cardinality() (
return argsFound.size();
public String usage(!{
if (schema.length()> 01
return "-[" + schema + ")":
else
return п";
}
{
public String errorMessage( throws Exception {
if (unexpectedArguments.size () > 0) {
return unexpectedArgumentMessage():
}else
switch (errorCode) {
case MISSING_STRING:
return String.format ("Could not find string parameter for -%c.",
errorArgument);
case OК:
throw new Exception("TILT: Should not get here.");
return"":
}
private String unexpectedArgumentMessage() {
StringBuffer message = new StringBuffer("Argument (s)
for (char c: unexpectedArguments)
message.append(c!;
message.append(" unexpected.");
return message.toString():
-");
205
206
Listagem 14-10 (continuação)
Args.java (Booleano e String)
public boolean get Boolean(char arg) {
return falseIfNull (booleanArgs.get (arg));
private boolean falseIfNull (Boolean b) {
return b == null ? false: b;
public String getString (char arg) {
return blankIfNull(stringArgs.get (arg));
}
private String blankIfNull (String s) {
t
return s == null ? "" : s:
public boolean has (char arg) {
return argsFound.contains (arg);
public boolean isValid() {
return valid;
}
}
Capítulo 14: Refinamento Sucessivo
Você pode ver que as coisas começaram a fugir ao controle. Ainda não está horrível, mas a
bagunça certamente está crescendo. É um amontoado, mas ainda não está tão grande assim. Isso
ocorreu com a adição do parâmetro do tipo integer.
Portanto, eu parei
Eu tinha pelo menos mais dois tipos de parâmetros para adicionar, e eu poderia dizer que eles
piorariam as coisas. Se eu forçasse a barra, provavelmente os faria funcionar também, mas
deixaria um rastro de bagunça grande demais para consertar. Se a estrutura deste desse código
algum dia for passível de manutenção, este é o momento para consertá-lo.
Portanto, parei de adicionar novos recursos e comecei a refatorar. Como só adicionei os
parâmetros do tipo string e integer, eu saiba que cada tipo exigia um bloco de código novo
em três locais principais. Primeiro, cada tipo requer uma forma de analisar a sintaxe de seu
elemento de modo a selecionar o HashMap para aquele tipo. Depois, seria preciso passar cada
tipo nas strings da linha de comando e convertê-lo para seu tipo verdadeiro. Por fim, cada tipo
precisaria de um método getXXX de modo que pudesse ser retornado ao chamador já em seu
tipo verdadeiro.
Muitos tipos diferentes, todos com métodos similaresisso parece uma classe para mim. E,
então, surgiu o ArgumentMarshaler.
Incrementalismo
Uma das melhores maneiras de arruinar um programa é fazer modificações excessivas em sua
estrutura visando uma melhoria. Alguns programas jamais se recuperam de tais "melhorias". О
Args: o rascunho 207
problema é que é muito difícil fazer o programa funcionar como antes da "melhoria".
A fim de evitar isso, sigo o conceito do Desenvolvimento dirigido a testes (TDD, sigla em
inglês). Uma das doutrinas centrais dessa abordagem é sempre manter o sistema operante. Em
outras palavras, ao usar o TDD, não posso fazer alterações ao sistema que o danifiquem. Cada
uma deve mantê-lo funcionando como antes.
Para conseguir isso, precisei de uma coleção de testes automatizados que eu pudesse rodar quando
desejasse e que verificasse se o comportamento do sistema continua inalterado. Para a classe
Args, criei uma coleção de testes de unidade e de aceitação enquanto eu bagunçava o código. Os
testes de unidade estão em Java e são gerenciados pelo JUnit. Os de aceitação são como páginas
wiki no FitNesse. Eu poderia rodar esses testes quantas vezes quisesse, e, se passassem, eu ficaria
confiante de que o sistema estava funcionando como eu especificara.
Sendo assim, continuei e fiz muitas alterações minúsculas. Cada uma movia a estrutura do
sistema em direção ao ArgumentMarshaler. E ainda assim, cada mudança mantinha o sistema
funcionando. A primeira que fiz foi adicionar ao esqueleto do ArgumentMarshaller ao final da
pilha amontoada de códigos (Listagem 14.11).
Listing 14-11
ArgumentMarshaller appended to Args.java
private class ArgumentMarshaler {
private boolean bcoleanValue = false;
}
public void setBoolean (boolean value) {
booleanValue = value;
}
public boolean getBoolean() (return booleanValue;}
private class BooleanArgumentMarshaler extends ArgumentMarshaler
private class StringArgumentMarshaler extends ArgumentMarshaler
private class IntegerArgumentMarshaler extends Argument Marshaler
}
Obviamente, isso não danificaria nada. Portanto, fiz a modificação mais simples que pude, uma
que danificaria o mínimo possível. Troquei o HashMap dos parâmetros do tipo booleano para
receber um ArgumentMarshaler.
private Map<Character, ArgumentMarshaler> booleanArgs =
new HashMap<Character, ArgumentMarshaler>();
Isso danificou algumas instruções, que rapidamente consertei.
private void parseBooleanSchemaElement(char elementId) {
booleanArgs.put(elementId, new BooleanArgumentMarshaler());
}
208 Capítulo 14: Refinamento Sucessivo
private void setBooleanArg(char argChar, boolean value) {
booleanArgs.get(argChar).setBoolean(value);
public boolean getBoolean(char arg) {
return falseIfNull(booleanArgs.get(arg).getBoolean());
Note como essas mudanças estão exatamente nas áreas mencionadas anteriormente: o parse, o
set c o get para o tipo do parâmetro. Infelizmente, por menor que tenha sido essa alteração,
alguns testes começaram a falhar. Se olhar com atenção para o getBoolean, verá que se você
o chamar com "y", mas não há houver parâmetro y, booleanArgs.get ('y') retornará null e a
função lançará uma NullPointerException. Usou-se a função falseIfNul1 para evitar que
isso ocorresse, mas, com a mudança que fiz, ela se tornou irrelevante.
O incrementalismo exige que eu conserte isso rapidamente antes de fazer qualquer outra alteração.
De fato, a solução não foi muito difícil. Só tive de mover a verificação por nu11. Não era mais
um booleano null que eu deveria verificar, mas o ArgumentMarshaller.
Primeiro, removi a chamada a falseIfNull na função getBoolean. Ela não fazia mais nada
agora, portanto a eliminei. Os testes ainda falhavam de certa forma, então eu estava certo de que
não havia gerado novos erros.
public boolean getBoolean(char arg) {
return booleanArgs.get(arg).getBoolean();
}
Em seguida, divide dividi a função em duas linhas e coloquei
o ArgumentMarshaller em sua própria variável chamada
argumentMarshaller. Não me preocupara com o tamanho do nome; ele
era redundante e bagunçava a função. Portanto o reduzi para am
public boolean getBoolean(char arg){
Args.ArgumentMarshaler am = booleanArgs.get(arg);
return am.getBoolean();
}
E, então, inseri a lógica de detecção de null.
public boolean getBoolean(char arg) {
Args.ArgumentMarshaler am = booleanArgs.get(arg);
return am != null && am.getBoolean();
}
Parâmetros do tipo string
[N5].
Adicionar parâmetros do tipo String é muito semelhante à adição de parâmetros booleanos.
Eu tive de mudar o HashMap e fazer as funções parse, get e set funcionarem. Não há muitas
surpresas depois, talvez pareça que eu esteja colocando toda a implementação de disponibilização
(marshalling) na classe base ArgumentMarshaller em vez de seus derivados.
private Map<Character, ArgumentMarshaler> stringArgs =
new HashMap<Character, ArgumentMarshaler>();
Parâmetros do tipo string
private void parseStringSchemaElement(char elementId) {
stringArgs.put(elementId, new StringArgumentMarshaler());
}
private void setStringArg(char argChar) throws ArgsException {
currentArgument++;
209
try {
stringArgs.get(argChar).setString(args[currentArgum
ent]);
}
}
t
}
catch (ArrayIndexOutOfBoundsException e)
valid = false;
errorArgumentId = argChar;
errorCode = ErrorCode.MISSING_STRING;
throw new ArgsException();
public String getString(char arg) {
Args.ArgumentMarshaler am = stringArgs.get(arg);
return am == null ? " ": am.getString();
}
private class ArgumentMarshaler {
private boolean booleanValue = false;
private String stringValue;
public void setBoolean(boolean value) {
booleanValue = value;
}
public boolean getBoolean() {
return booleanValue;
}
public void setString(String s) {
stringValue = s;
}
public String getString() {
return stringValue == null ?"": stringValue;
}
}
Novamente, essas alterações foram feitas uma de cada vez e de tal forma que os testes estavam
sempre funcionando. Quando um falhava, eu me certificava de fazê-lo passar com êxito antes de
fazer a próxima mudança.
Mas, a esta altura, você já deve saber o que pretendo. Após eu colocar todo o comportamento doa
disponibilização dentro da classe base ArgumentMarshaler, começarei a passá-lo hierarquia
abaixo para os derivados. Isso me permitirá manter tudo operante enquanto eu modifico
gradualmente a forma deste programa.
210 Capítulo 14: Refinamento Sucessivo
O próximo, e óbvio, passo foi mover a funcionalidade do parâmetro do tipo int para
ArgumentMarshaler. Novamente, não há nada de novo aqui.
private Map<Character, ArgumentMarshaler> intArgs =
new HashMap<Character, ArgumentMarshaler>();
private void parseIntegerSchemaElement(char elementId) {
intArgs.put(elementId, new IntegerArgumentMarshaler());
}
private void setIntArg(char argChar) throws ArgsException
currentArgument++;
String parameter = null;
try {
parameter = args[currentArgument];
intArgs.get(argChar).setInteger(Integer.
parseInt(parameter));
} catch (ArrayIndexOutOfBoundsException e) {
valid = false:
errorArgumentId = argChar;
errorCode = ErrorCode.MISSING_INTEGER;
throw new ArgsException();
} catch (NumberFormatException e) {
valid = false;
errorArgumentId = argChar;
errorParameter = parameter;
errorCode = ErrorCode.INVALID_INTEGER;
throw new ArgsException();
{
}
public int getInt(char arg) {
}
Args.ArgumentMarshaler am = intArgs.get(arg);
return am == null ? 0: am.getInteger();
private class ArgumentMarshaler {
private boolean booleanValue = false;
private String stringValue;
private int integerValue;
public void setBoolean(boolean value)
booleanValue = value;
}
public boolean getBoolean() {
return booleanValue;
}
public void setString(String s) {
stringValue = s;
Parâmetros do tipo string
public String getString() {
return stringValue == null?"": stringValue;
public void setInteger(int i) {
integerValue = i;
}
public int getInteger() {
return integerValue;
}
}
211
Após mover toda a disponibilização para ArgumentMarshaler, comecei a passar a
funcionalidade para os derivados. O primeiro passo foi mover a função setBoolean para
BooleanArgumentMarshaller e me certificar de que fosse chamada corretamente. Portanto, criei
um método set abstrato.
private abstract class ArgumentMarshaler {
protected boolean booleanValue = false;
private String stringValue;
private int integerValue;
public void setBoolean(boolean value) {
booleanValue = value;
public boolean getBoolean(){
return booleanValue;
}
public void setString(String s)}
stringValue = s;
public String getString() {
return stringValue == null ? " : stringValue;
public void setInteger(int i) {
integerValue = i;
{
public int getInteger({
return integerValue;
}
public abstract void set(String s);
Então, implementei o método set em BooleanArgumentMarshaller.
212 Capítulo 14: Refinamento Sucessivo
private class BooleanArgumentMarshaler extends ArgumentMarshaler
public void set(String s) {
}
}
E
booleanValue = true;
}
finalmente, substitui a chamada a setBoolean pela chamada ao set.
private void setBooleanArg(char argChar, boolean value)
booleanArgs.get(argChar).set("true");
{
Os testes ainda passavam. Como essa mudança causou a implementação do set
em BooleanArgumentMarshaler, removi o método setBoolean da classe base
ArgumentMarshaler.
Note que a função set abstrata recebe um parâmetro do tipo String, mas a implementação em
BooleanArgumentMarshaller não o usa. Coloquei um parâmetro lá porque eu sabia que StringArgumentMarshaller e IntegerArgumentMarshaller o usariam.
Depois, eu queria implementar o método get em BooleanArgumentMarshaler. Mas
implementar funções get sempre fica ruim, pois o tipo retornado tem de ser um Object, e neste
caso teria de ser declarado como um booleano.
public boolean getBoolean(char arg)}
Args.ArgumentMarshaler am = booleanArgs.get(arg);
return am != null && (Boolean)am .get();
}
Só para que isso compile, adicionei a função get
ArgumentMarshaler.
private abstract class ArgumentMarshaler {
public Object get() {
return null;
a
3
}
A compilação ocorreu e, obviamente, os testes falharam. Fazê-los funcionarem
novamente era simplesmente uma questão de tornar o get abstrato e implementá-lo em
BooleanAgumentMarshaler.
private abstract class ArgumentMarshaler {
protected boolean booleanValue = false;
public abstract Object get();
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
public void set (String s) {
booleanValue = true;
}
Parâmetros do tipo string
public Object get () {
return booleanValue;
213
Mais uma vez, os testes passaram. Portanto, as implementações de get e set ficam em
BooleanArgumentMarshaler!
Isso me permitiu remover a função getBoolean antiga de ArgumentMarshaler, mover a variável
protegida booleanValue abaixo para BooleanArgumentMarshaler e torná-la privada.
Fiz as mesmas alterações para os tipos String. Implementei set e get e exclui as funções não
mais utilizadas e movi as variáveis.
private void setStringArg(char argChar) throws ArgsException {
currentArgument++;
try {
stringArgs.get(argChar).set(args(currentArgument]);
} catch (ArrayIndexOutOfBoundsException e) {
valid = false;
errorArgumentId = argChar;
errorCode = ErrorCode.MISSING_STRING;
throw new ArgsException();
}
public String getString(char arg){
Args.ArgumentMarshaler am = stringArgs.get(arg);
return am == null? " : (String) am.get();
private abstract class ArgumentMarshaler
private int integerValue;
public void setInteger(int i) {
integerValue = i;
public int getInteger() {
return integerValue;
}
}
}
public abstract void set(String s);
public abstract Object get();
private class BooleanArgumentMarshaler extends ArgumentMarshaler
private boolean booleanValue = false;
public void set(String s) {
booleanValue = true;
}
public Object get() {
return booleanValue;
}
{
214
}
Capítulo 14: Refinamento Sucessivo
private class StringArgumentMarshaler extends ArgumentMarshaler{
private String stringValue = w;
public void set(String s)
}
}
stringValue = s;
public Object get() {
return stringValue;
private class IntegerArgumentMarshaler extends
ArgumentMarshaler {
public void set(String s) {
}
public Object get() {
return null;
}
Por fim, repeti o processo para os inteiros (integer). Só um pouco mais complicado, pois
os inteiros precisam ser analisados sintaticamente, e esse processo pode lançar uma exceção.
Mas o resultado fica melhor, pois toda a ação de NumberFormatException fica escondido em
IntegerArgumentMarshaler.
private boolean isIntArg(char argChar) {return intArgs
containsKey(argChar);)
private void setIntArg(char argChar) throws ArgsException
currentArgument++;
String parameter = null;
try{
parameter = args[currentArgument];
intArgs.get(argChar).set(parameter);
} catch (ArrayIndexOutOfBoundsException e) {
valid = false;
} catch
errorArgumentId = argChar;
errorCode = ErrorCode.MISSING_INTEGER;
throw new ArgsException();
(ArgsException e) {
valid = false;
errorArgumentId = argChar;
errorParameter = parameter;
errorCode = ErrorCode.INVALID_INTEGER;
throw е;
}
}
private void setBooleanArg(char argChar) {
Parâmetros do tipo string
try {
booleanArgs.get(argChar).set("true");
}
}
} catch (ArgsException e) {
public int getInt(char arg) {
Args.ArgumentMarshaler am = intArgs.get(arg);
return am == null ? 0 : (Integer) am .get();
private abstract class ArgumentMarshaler {
public abstract void set(String s) throws ArgsException;
public abstract Object get();
}
private class IntegerArgumentMarshaler extends ArgumentMarshaler
private int intValue = ;
public void set(String s) throws ArgsException
try {
intValue = Integer.parseInt(s);
} catch (NumberFormatException e) {
throw new ArgsException();
}
public Object get() {
return intValue;
}
}
215
É claro que os testes continuavam a passar. Depois, me livre dos três maps diferentes no início do
algoritmo. Isso generalizou muito mais o sistema todo. Entretanto, não consegui me livrar dele
apenas excluindo-os, pois isso danificaria o sistema.
Em vez disso, adicionei um novo Map a ArgumentMarshaler e, então, um a um, mudei os
métodos e o usei este novo Map no lugar dos três originais.
public class Args {
private Map<Character, ArgumentMarshaler> booleanArgs =
new HashMap<Character, ArgumentMarshaler>();
private Map<Character, ArgumentMarshaler> stringArgs =
new HashMap<Character, ArgumentMarshaler>();
private Map<Character, ArgumentMarshaler> intArgs =
new HashMap<Character, ArgumentMarshaler>();
private Map<Character, ArgumentMarshaler> marshalers =
new HashMap<Character, ArgumentMarshaler>()
private void parseBooleanSchemaElement(char elementId) {
ArgumentMarshaler m = new BooleanArgumentMarshaler();
booleanArgs.put(elementId, m);
marshalers.put(elementId, m);
216 Capítulo 14: Refinamento Sucessivo
}
private void parseIntegerSchemaElement(char elementId) {
ArgumentMarshaler m = new IntegerArgumentMarshaler()7
intArgs.put(elementId, m);
marshalers.put(elementId, m);
}
private void parseStringSchemaElement(char elementId) {
ArgumentMarshaler m = new StringArgumentMarshaler));
stringArgs.put(elementId, m);
marshalers.put(elementId, m);
}
É claro que todos os testes ainda passaram. Em seguida, modifiquei o isBooleanArg disso:
private boolean isBooleanArg(char argChar)
return booleanArgs.containsKey(argChar);
}
para isso:
}
private boolean isBooleanArg(char argChar) {
ArgumentMarshaler m = marshalers.get(argChar);
return m instanceof BooleanArgumentMarshaler;
}
Os testes ainda passaram. Portanto, fiz a mesma mudança em isIntArg e isStringArg.
private boolean isIntArg(char argChar) {
ArgumentMarshaler m = marshalers.get(argChar);
return m instanceof IntegerArgumentMarshaler;
}
private boolean isStringArg(char argChar) {
ArgumentMarshaler m = marshalers.get(argChar);
return m instanceof StringArgumentMarshaler;
Os testes ainda passaram. Portanto, eliminei todas as chamadas repetidas a marshalers.get:
private boolean setArgument (char argChar) throws ArgsException {
ArgumentMarshaler m = marshalers.get(argChar);
if (isBooleanArg(m))
setBooleanArg(argChar);
else if (isStringArg(m))
setStringArg(argChar);
else if (isIntArg(m))
setIntArg(argChar):
else
return false;
return true;
Parâmetros do tipo string
private boolean isIntArg(ArgumentMarshaler m) {
return m instanceof IntegerArgumentMarshaler;
private boolean isStringArg(ArgumentMarshaler m) {
return m instanceof StringArgumentMarshaler;
private boolean isBooleanArg(ArgumentMarshaler m) {
return m instanceof BooleanArgumentMarshaler;
}
Isso não fez nada de mais para os três métodos isxxxArg. Portanto, eu os encurtei:
private boolean setArgument (char argChar) throws ArgsException
ArgumentMarshaler m = marshalers.get(argChar);
if (m instanceof BooleanArgumentMarshaler)
setBooleanArg(argChar);
else if (m instanceof StringArgumentMarshaler)
setStringArg(argChar);
else if (m instanceof IntegerArgumentMarshaler)
setIntArg(argChar);
else
return false;
return true;
}
217
Depois, comecei a usar os map do marshalers nas funções set, danificando o uso dos outros
três maps. Comecei com os booleanos.
{
private boolean setArgument (char argChar) throws ArgsException
ArgumentMarshaler m = marshalers.get(argChar);
if (m instanceof BooleanArgumentMarshaler)
setBooleanArg (m);
else if (m instanceof StringArgumentMarshaler)
setStringArg(argChar);
else if (m instanceof IntegerArgumentMarshaler)
setIntArg(argChar);
else
return false;
return true;
private void setBooleanArg(ArgumentMarshaler m) {
try {
m.set("true")⑆ // was: booleanArgs.get(argChar).
set("true");
} catch (ArgsException e) {
}
218 Capítulo 14: Refinamento Sucessivo
Os testes continuam passando, portanto, fiz o mesmo para strings e inteiros. Isso me permitiu
integrar parte do código de gerenciamento de exceção à função setArgument.
private boolean setArgument (char argChar) throws ArgsException
ArgumentMarshaler m = marshalers.get(argChar);
try {
if (m instanceof BooleanArgumentMarshaler)
setBooleanArg(m);
else if (m instanceof StringArgumentMarshaler)
setStringArg(m);
else if (m instanceof IntegerArgumentMarshaler)
setIntArg(m);
}
}
else
return false:
}
}
catch (ArgsException e){
valid = false;
errorArgumentId = argChar;
throw e;
return true;
private void setIntArg (ArgumentMarshaler m) throws ArgsException {
currentArgument++;
String parameter = null;
try {
parameter = args[currentArgument];
m.set(parameter);
} catch (ArrayIndexOutofBoundsException e) {
errorCode = ErrorCode.MISSING_INTEGER;
throw new ArgsException();
} catch (ArgsException e) {
errorParameter = parameter:
errorCode = ErrorCode.INVALID_INTEGER;
throw е;
}
}
private void setStringArg(ArgumentMarshaler m) throws ArgsException
{
currentArgument++;
try {
}
m.set(args[currentArgument]);
} catch (ArrayIndexOutOfBoundsException e) {
errorCode = ErrorCode.MISSING_STRING;
throw new ArgsException();
Quase consegui remover os três maps antigos. Primeiro, precisei alterar a função get Boolean disso:
public boolean getBoolean(char arg) {
Parâmetros do tipo string
para isso:
Args.ArgumentMarshaler am = booleanArgs.get(arg);
return am != null && (Boolean) am.get();
public boolean getBoolean(char arg) {
Args.ArgumentMarshaler am = marshalers.get(arg);
boolean b = false;
try {
b = am != nul1 && (Boolean) am.get();
} catch (ClassCastException e)}
b = false;
}
return b;
219
a
Você deve ter se surpreendido com essa última alteração. Por que decidi usar de repente
ClassCastException? O motivo é que tenho uma série de testes de unidade e uma série
separada de testes de aceitação escritos no FitNesse. Acabou que os testes do FitNesse garantiram
que, se você chamasse a getBoolean em um parâmetro não booleano, você recebia falso. Mas
os testes de unidade não.
Até este momento, eu só havia rodado os testes de unidade².
Essa última alteração me permitiu remover outro uso do map booleano:
private void parseBooleanSchemaElement(char elementId)
ArgumentMarshaler m = new BooleanArgumentMarshaler();
booleanArgs.put(elementid, m);
marshalers.put(elementId, m);
E agora podemos excluir o map booleano.
public class Args {
{
private Map<Character, ArgumentMarshaler> booleanArgs=
new HashMap<Character, ArgumentMarshaler>()т
private Map<Character, ArgumentMarshaler> stringArgs
new HashMap<Character, ArgumentMarshaler>();
private Map<Character, ArgumentMarshaler> intArgs =
new HashMap<Character, ArgumentMarshaler>();
private Map<Character, ArgumentMarshaler> marshalers
new HashMap<Character, ArgumentMarshaler>();
=
=
Em seguida, migrei os parâmetros do tipo String e Integer da mesma maneira e fiz uma pequena
limpeza nos booleanos.
private void parseBooleanSchemaElement(char elementId) {
marshalers.put(elementId, new BooleanArgumentMarshaler());
}
private void parseIntegerSchemaElement(char elementId) }
arde, adicinovo teste de unidade que invoca todos os testes do FitNesse.
220 Capítulo 14: Refinamento Sucessivo
marshalers.put(elementId, new IntegerArgumentMarshaler()); }
private void parseStringSchemaElement(char elementId) {
marshalers.put(elementId, new StringArgumentMarshaler());
}
public String getString(char arg) {
Args.ArgumentMarshaler am = marshalers.get(arg);
try {
return am == nul1? (String) am.get();
} catch (ClassCastException e) {
return w;
}
public int getInt(char arg) {
Args.ArgumentMarshaler am = marshalers.get(arg);
try {
return am == null ? 0 : (Integer) am.get();
} catch (Exception e) {
return 0;
}
public class Args {
private Map<Character, ArgumentMarshaler> stringArgs =
new HashMap<Character, ArgumentMarshaler>();
private Map<Character, ArgumentMarshaler> intArgs
new HashMap<Character, ArgumentMarshaler>()
private Map<Character, ArgumentMarshaler> marshalers
new HashMap<Character, ArgumentMarshaler>();
Em seguida, encurtei os métodos parse porque eles não fazem mais muita coisa.
private void parseSchemaElement(String element) throws
ParseException {
char elementId = element.charAt(0);
String elementTail = element.substring(1);
validateSchemaElementId(elementId);
if (isBooleanSchemaElement(elementTail))
=
marshalers.put(elementId, new BooleanArgumentMarshaler());
else if (isStringSchemaElement(elementTail))
marshalers.put(elementId, new StringArgumentMarshaler());
else if (isIntegerSchemaElement(elementTail)) {
marshalers.put(elementId, new IntegerArgumentMarshaler()); } else {
throw new ParseException(String.format(
"Parâmetro: c possui formato inválido: %s.", elementId,
elementTail), 0);
}
Tudo bem, agora vejamos o todo novamente. A Listagem 14.12 mostra a forma atual da classe Args.
Parâmetros do tipo string
Listagem 14-12
Args.java (Após primeira refatoração)
package com.objectmentor.utilities.getopts;
import java.text.ParseException;
import java.util.*;
public class Args }
private String schema:
private String[! args;
private boolean valid = true;
private Set<Character> unexpectedArguments = new TreeSet<Character>();
private Map<Character, ArgumentMarshaler> marshalers =
new HashMap<Character, ArgumentMarshaler>();
private Set<Character> argsFound = new HashSet<Character>();
private int currentArgument;
private char errorArgumentId =0';
private String errorParameter = "TILT";
private ErrorCode errorCode = ErrorCode.OK;
private enum ErrorCode{
OK, MISSING_STRING, MISSING INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}
public Args (String schema, String[] args) throws ParseException {
this.schema = schema;
this.args = args;
valid = parse();
private boolean parse() throws ParseException
if (schema.length() == 0 && args.length == 0)
return true;
parseSchema();
try {
{
}
parseArguments(:
catch (ArgsException e) {
3
return valid;
}
private boolean parseSchema() throws ParseException {
for (String element : schema.split(",")) {
if (element.length() > 0)
String trimmedElement = element.trim();
parseSchemaElement (trimmedElement);
return true;
private void parseSchemaElementiString element) throws FarseException
char elementId = element.charAt (0):
String elementTail = element.substring(1); validateSchemaElementId(elementId);
if (isBooleanSchemaElement (elementTail))
marshalers.put (elementId, new BooleanArgumentMarshaler()):
else if (isStringSchemaElement (element Tail})
marshalers.put(elementId, new StringArgumentMarshaler());
221
222 Capítulo 14: Refinamento Sucessivo
Listagem 14-12 (continuação)
Args.java (Após primeira refatoração)
}
else if (isIntegerSchemaElement (elementTail})
marshalers.put (elementId, new IntegerArgumentMarshaler());
} else {
throw new ParseException(String.format (
"Argument: %c has invalid format: %s.", elementId, elementTail), 0);
private void validateSchemaElementId(char elementId) throws ParseException
if (!Character.isLetter(elementId)) {
throw new ParseException(
"Bad character:" + elementId + "in Args format:"+ schema, 0);
t
private boolean 1sStringSchemaElement (String elementTail}
return elementTail.equals("*)
}
private boolean isBooleanSchemaElement (String elementTail) {
return elementTail.length() == 0;
private boolean isIntegerSchemaElementiString elementTail)
return elementTail.equals("#");
private boolean parseArguments() throws ArgsException {
for (currentArgument=0; currentArgument<args.length; currentArgument++) String arg = args [currentArgument];
parseArgument(arg);
return true;
}
private void parseArgument (String arg) throws ArgsException {
if (arg.startsWith("-"))
parseElements (arg);
private void parseElements (String arg) throws ArgsException
for (int i = 1; 1 < arg.length(); 1++)
}
parseElement (arg.charAt(i));
}
private void parseElement (char argChar) throws ArgsException {
if (setArgument (argChar))
argsFound.add(argChar);
else {
unexpectedArguments.add(argChar);
errorCode = ErrorCode. UNEXPECTED_ARGUMENT;
valid = false:
}
Parâmetros do tipo string
Listagem 14-12 (continuação)
Args.java (Após primeira refatoração)
private boolean setArgument (char argChar) throws ArgsException
ArgumentMarshaler m = marshalers.get(argChar);
try{
if (m instanceof BooleanArgumentMarshaler)
set BooleanArg(m);
else if (m instanceof StringArgumentMarshaler)
setStringArg(m);
else if (m instanceof IntegerArgumentMarshaler(
setIntArg(m);
else
return false;
catch (ArgsException e) {
valid = false;
errorArgumentId = argChar;
throw e:
return true;
private void setIntArg(ArgumentMarshaler m) throws ArgsException
currentArgument++;
String parameter = null;
try
parameter = args [currentArgument]:
m.set (parameter):
catch (ArrayIndexOutOfBoundsException e)
errorCode = ErrorCode.MISSING_INTEGER;
throw new ArgsException();
} catch (ArgsException e) {
errorParameter = parameter;
errorCode = ErrorCode. INVALID_INTEGER;
throw e:
}
private void setStringArg(ArgumentMarshaler m) throws ArgsException
currentArgument++;
}
try
3
m.set(args[currentArgument]);
catch (ArrayIndexOutOfBoundsException e) {
errorCode = ErrorCode.MISSING_STRING;
throw new ArgsException():
private void setBooleanArg(ArgumentMarshaler m
try {
m.set("true");
} catch (ArgsException e) {
}
public int cardinality() {
return argsFound.size();
{
223
224
Listagem 14-12 (continuação)
Args.java (Após primeira refatoração)
public String usage() {
if (schema.length() > 0)
return "-[" + schema + "]";
else
return "";
}
Capítulo 14: Refinamento Sucessivo
public String errorMessage() throws Exception
switch (errorCode) {
case OK:
throw new Exception("TILT: Should not get here.");
case UNXPECTED_ARGUMENT:
return unexpectedArgumentMessage(:
case MISSING_STRING:
return String.format ("Could not find string parameter for -%c.", errorArgumentId):
case INVALID_INTEGER:
return String.format("Argument -%c expects an integer but was '%s'.",
errorArgumentId, errorParameter);
case MISSING_INTEGER:
return String.format("Could not find integer parameter for -&c.",
errorArgumentId);
return "
}
private String unexpectedArgumentMessage() {
StringBuffer message = new StringBuffer("Argument(s) -");
for (char c: unexpectedArguments) }
message.append(c);
message.append(" unexpecred.");
return message.toString();
public boolean getBoolean(char arg) {
Args.ArgumentMarshaler am = marshalers.get(arg);
boolean b = false:
try{
b = am != null && (Boolean) am.get();
) catch (ClassCastException e) {
b = false;
return b:
public String getString(char arg)
Args.ArgumentMarshaler am = marshalers.get(arg);
try{
}
return am == null? "" : iString) am.get ();
catch (ClassCastException e) {
return P
Parâmetros do tipo string
Listagem 14-12 (continuação)
Args.java (Após primeira refatoração)
public int getInt (char arg) {
Args.ArgumentMarshaler am = marshalers.get (arg);
try {
return am == null1 ? 0 : (Integer) am.get():
} catch (Exception e) {
return 0;
}
}
public boolean has (char arg! {
return argsFound.contains(arg);
public boolean isValid() {
return valid;
private class ArgsException extends Exception {
private abstract class Argument Marshaler {
public abstract void set (String s) throws ArgsException:
public abstract Object get();
private class BooleanArgumentMarshaler extends ArgumentMarshaler
private boolean booleanValue = false;
public void set (String s) {
booleanvalue = true;
public Object get)) }
return booleanValue;
}
private class StringArgumentMarshaler extends ArgumentMarshaler
private String stringValue = "";
public void set (String s) {
stringValue = s;
}
public Object get() {
return stringValue;
}
}
private class IntegerArgumentMarshaler extends ArgumentMarshaler
private int intValue = 0;
public void set (String s) throws ArgsException {
try{
intValue = Integer.parseint(s);
}
}
{
225
226
Listagem 14-12 (continuação)
Args.java (Após primeira refatoração)
}
} catch (NumberFormatException e!{
throw new ArgsException();
}
}
public Object get () {
return intValue;
Capítulo 14: Refinamento Sucessivo
Depois de todo esse trabalho, isso é um pouco frustrante. A estrutura ficou um pouco melhor,
mas ainda temos todas aquelas variáveis no início; Ainda há uma estrutura case de tipos em
setArgument; e todas aquelas funções set estão horríveis. Sem contar com todos os tratamentos
de erros. Ainda temos muito trabalho pela frente.
Eu realmente gostaria de me livrar daquele case de tipos em setArgument [G23]. Eu preferia
ter nele apenas uma única chamada, a ArgumentMarshaler.set. Isso significa que preciso
empurrar setIntArg, setStringArg e setBooleanArg hierarquia abaixo para os derivados
de ArgumentMarshaler apropriados. Mas há um problema.
Se observar setIntArg de perto, notará que ele usa duas instâncias de variáveis: args e
currentArg. Para mover setIntArg para baixo até BooleanArgumentMarshaler, terei de
passer passar ambas as variáveis como parâmetros da função. Isso suja o código [F1]. Prefiro
passar um parâmetro em vez de dois. Felizzlimente, há uma solução simples. Podemos converter
o array args em uma lista e passar um Iterator abaixo para as funções set. Levei dez passos no
exemplo a seguir para passar todos os testes após cada passo. Mas só lhe mostrarei o resultado.
Você deve ser capaz de descobrir o que era a maioria desses pequenos passos.
public class Args {
private String schema;
private Stringi] args;
private boolean valid = true;
private Set<Character> unexpectedArguments = new
TreeSet<Character>();
private Map<Character, ArgumentMarshaler> marshalers
new HashMap<Character, ArgumentMarshaler>();
=
private Set<Character> argsFound = new HashSet<Character>();
private Iterator<String> currentArgument;
private char errorArgumentId = \0;
private String errorParameter = "TILT";
private ErrorCode errorCode = ErrorCode.OK;
private List<String> argsList;
private enum ErrorCode {
OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER,
UNEXPECTED_ARGUMENT}
{
public Args(String schema, String[] args) throws ParseException
this.schema = schema;
argsList = Arrays.asList(args);
Parâmetros do tipo string
valid = parse();
}
private boolean parse() throws ParseException {
if (schema.length() == 0 && argsList.size() == 0)
return true;
parseSchema();
try {
parseArguments();
} catch (ArgsException e) {
}
return valid:
private boolean parseArguments() throws ArgsException
for (currentArgument = argsList.iterator();
currentArgument.hasNext();) {
String arg = currentArgument.next();
parseArgument(arg);
return true;
}
227
private void setIntArg(ArgumentMarshaler m) throws ArgsException
String parameter = null;
try {
parameter = currentArgument.next();
m.set(parameter);
} catch (NoSuchElementException e) }
errorCode = ErrorCode.MISSING_INTEGER;
throw new ArgsException();
} catch (ArgsException e) {
errorParameter = parameter;
errorCode = ErrorCode.INVALID_INTEGER;
throw е;
}
private void setStringArg(ArgumentMarshaler m) throws
ArgsException {
try{
m.set(currentArgument.next());
} catch (NoSuchElementException e)
{
errorCode = ErrorCode.MISSING_STRING;
throw new ArgsException();
}
}
Essas foram simples modificações nas quais todos os testes passaram. Agora podemos começar a
mover as funções set para os derivados apropriados. Primeiro, preciso fazer a seguinte alteração
em setArgument:
228 Capítulo 14: Refinamento Sucessivo
private boolean setArgument(char argChar) throws ArgsException
ArgumentMarshaler m = marshalers.get(argChar);
if (m == null1)
return false;
try {
}
if (m instanceof BooleanArgumentMarshaler)
setBooleanArg (m);
else if (m instanceof StringArgumentMarshaler)
setStringArg(m);
else if (m instanceof IntegerArgumentMarshaler)
setIntArg(m);
else
return false;
}
}
catch (ArgsException e) {
valid = false:
errorArgumentId = argChar;
throw e;
return true;
{
Essa mudança é importante porque queremos eliminar completamente a cadeia i f-else.
Logo, precisamos retirar a condição de erro lá de dentro.
Agora podemos começar a mover as funções set. A setBooleanArg é trivial, então
trabalharemos nela primeiro. Nosso objetivo é alterá-la simplesmente para repassar para
BooleanArgumentMarshaler.
private boolean setArgument (char argChar) throws ArgsException
ArgumentMarshaler m = marshalers.get(argChar);
if (m == null)
return false;
try {
}
if (m instanceof BooleanArgumentMarshaler)
setBooleanArg(m, currentArgument);
else if (m instanceof StringArgumentMarshaler)
setStringArg(m);
else if (m instanceof IntegerArgumentMarshaler)
setIntArg(m);
} catch (ArgsException e) {
valid = false;
errorArgumentId = argChar;
throw e;
}
return true;
private void setBooleanArg(ArgumentMarshaler m,
Iterator<String> currentArgument)
throws ArgsException {
try f
m.set("true");
catch (ArgsException e) {
+
Parâmetros do tipo string 229
Não acabamos de incluir aquele tratamento de exceção? É muito comum na refatoração inserir
e remover as coisas novamente. A pequeneza dos passos e a necessidade de manter os testes
funcionando significa que você move bastante as coisas. Refatorar é como resolver o cubo de
Rubik. Há muitos passos pequenos necessários para alcançar um objetivo maior. Cada passo
possibilita o próximo.
Por que passamos aquele iterator quando setBooleanArg certamente não precisa dele?
Porque setIntArg e setStringArg precisarão! E porque queremos implementar todas
essas três funções através de um método abstrato em ArgumentMarshaller e passá-lo para
setBooleanArg. Dessa forma, setBooleanArg agora não serve para nada. Se houvesse uma
função set em ArgumentMarshaler, poderíamos chamá-la diretamente. Portanto, é hora de
criá-la! O primeiro passo é adicionar o novo método abstrato a ArgumentMarshaler.
private abstract class ArgumentMarshaler {
public abstract void set(Iterator<String> currentArgument)
throws ArgsException;
public abstract void set(String s) throws ArgsException;
public abstract Object get();
É claro que isso separa todos os derivados. Portanto, vemos implementar o novo método em cada um.
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
private boolean booleanValue = false;
public void set(Iterator<String> currentArgument) throws ArgsException {
booleanValue = true;
}
public void set (String s) {
booleanvalue = true,
public Object get() {
return booleanValue;
}
private class StringArgumentMarshaler extends ArgumentMarshaler
private String stringValue = w;
public void set(Iterator<String> currentArgument) throws
ArgsException {
public void set(String s) {
stringValue = s;
public Object get() {
return stringValue;
}
{
230 Capítulo 14: Refinamento Sucessivo
}
private class IntegerArgumentMarshaler extends ArgumentMarshaler {
private int intValue = 0;
public void set(Iterator<String> currentArgument) throws
ArgsException {
public void set(String s) throws ArgsException
try {
intValue = Integer.parseInt(s);
} catch (NumberFormatException e) {
throw new ArgsException();
{
}
}
public Object get() {
return intValue;
}
E, agora, podemos eliminar setBooleanArg!
private boolean setArgument(char argChar) throws ArgsException {
ArgumentMarshaler m = marshalers.get(argChar);
if (m == null)
return false:
try {
if (m instanceof BooleanArgumentMarshaler)
m.set (currentArgument);
else if (m instanceof StringArgumentMarshaler)
setStringArg(m);
else if (m instanceof IntegerArgumentMarshaler)
setIntArg(m);
} catch (ArgsException e) {
valid = false;
errorArgumentId = argChar;
throw е;
}
return true;
Todos os testes passam e a função set é implementada para BooleanArgumentMarshaler!
Agora podemos fazer o mesmo para Strings e Integers.
private boolean setArgument(char argChar) throws ArgsException {
ArgumentMarshaler m = marshalers.get(argChar);
if (m == null)
return false;
try {
if (m instanceof BooleanArgumentMarshaler)
Parâmetros do tipo string
m.set(currentArgument);
else if (m instanceof StringArgumentMarshaler)
m.set(currentArgument);
else if (m instanceof IntegerArgumentMarshaler)
m.set(currentArgument);
} catch (ArgsException e) {
valid = false:
errorArgumentId = argChar;
throw е;
}
return true;
}
private class StringArgumentMarshaler extends ArgumentMarshaler
private String stringValue = ""
public void set(Iterator<String> currentArgument) throws
ArgsException {
try {
stringValue = currentArgument.next();
} catch (NoSuchElementException e) {
errorCode = ErrorCode.MISSING_STRING;
throw new ArgsException();
}
}
public void set(String s) {
}
public Object get() {
return stringValue;
}
}
private class IntegerArgumentMarshaler extends ArgumentMarshaler
private int intValue = 0;
public void set(Iterator<String> currentArgument) throws
ArgsException {
String parameter = null;
try {
}
}
parameter = currentArgument.next();
set (parameter);
catch (NoSuchElementException e) {
errorCode = ErrorCode.MISSING_INTEGER;
throw new ArgsException();
} catch (ArgsException e) {
errorParameter = parameter;
errorCode = ErrorCode.INVALID_INTEGER;
throw e;
public void set(String s) throws ArgsException }
{
231
{
232
}
3
}
Capítulo 14: Refinamento Sucessivo
try {
intValue = Integer.parseInt(s);
} catch (NumberFormatException e) {
throw new ArgsException();
public Object get() {
return intValue;
E, agora o coup de grace: pode-se remover o caso do tipo! Touché!
private boolean setArgument(char argChar) throws ArgsException {
ArgumentMarshaler m = marshalers.get(argChar);
if (m == null)
return false;
try {
m.set(currentArgument);
return true;
} catch (ArgsException e) {
valid = false;
errorArgumentId = argChar;
throw е;
}
}
Agora podemos nos livrar de algumas funções inúteis em IntegerArgumentMarshaler e
limpá-la um pouco.
private class IntegerArgumentMarshaler extends ArgumentMarshaler
private int intValue = 0
public void set(Iterator<String> currentArgument) throws
{
ArgsException {
String parameter = null;
try {
parameter = currentArgument.next();
intValue = Integer.parseInt (parameter);
} catch (NoSuchElementException e) {
errorCode = ErrorCode.MISSING_INTEGER;
throw new ArgsException();
} catch (NumberFormatException e) {
errorParameter = parameter;
errorCode = ErrorCode.INVALID_INTEGER;
throw new ArgsException();
public Object get() {
return intValue;
}
}
Parâmetros do tipo string
Também podemos transformar ArgumentMarshaler em uma interface.
233
private interface ArgumentMarshaler {
void set (Iterator<String> currentArgument) throws ArgsException;
Object get();
Portanto, agora vejamos como fica fácil adicionar um novo tipo de
parâmetro a à nossa estrutura. São necessárias poucas mudanças,
elas devem ser isoladas. Primeiro, adicionamos um novo teste de
caso para verificar se o parâmetro double funciona corretamente.
e
public void testSimpleDoublePresent() throws Exception {
}
Args args = new Args("x##", new String[] {"-x","42.3"});
assertTrue(args.isValid(0);
assertEquals(1, args.cardinality());
assertTrue(args.has('x'));
assertEquals (42.3, args.getDouble('x'), .001);
Agora, limpamos o código de análise da sintaxe e adicionamos o ## para detectar o parâmetro
do tipo double.
private void parseSchemaElement(String element) throws ParseException {
char elementId = element.charAt(0):
String elementTail = element.substring(1);
}
validateSchemaElementId(elementId);
if (elementTail.length() == 0)
marshalers.put(elementId, new BooleanArgument Marshaler());
else if (elementTail.equals("*"}) marshalers.put(elementId, new StringArgumentMarshaler());
else if (elementTail.equals("#))
marshalers.put(elementId, new IntegerArgumentMarshaler());
else if (elementTail.equals("##"))
else
marshalers.put(elementId, new DoubleArgumentMarshaler());
throw new ParseException(String.format(
"Parâmetro: %c possui formato inválido: %s.", elementId, elementTail), 0);
Em seguida, criamos a classe DoubleArgumentMarshaler.
private class DoubleArgumentMarshaler implements ArgumentMarshaler
private double doubleValue = 0;
public void set(Iterator<String> currentArgument)
ArgsException
{
throwS
{
String parameter = null;
try {
} catch
parameter = currentArgument.next();
doubleValue = Double.parseDouble(parameter);
(NoSuchElementException e) {
errorCode = ErrorCode.MISSING_DOUBLE;
throw new ArgsException();
} catch (NumberFormatException e)
errorParameter = parameter;
{
234
}
}
}
Capítulo 14: Refinamento Sucessivo
errorCode = ErrorCode.INVALID DOUBLE;
throw new ArgsException();
public Object get() {
return doubleValue;
Isso nos força a adicionar um novo ErrorCode.
private enum ErrorCode {
OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED
ARGUMENT,
MISSING DOUBLE, INVALID_DOUBLE)
E precisamos de uma função getDouble.
public double getDouble(char arg) {
Args.ArgumentMarshaler am = marshalers.get(arg);
try {
return am == null ? 0: (Double) am.get();
} catch (Exception e)}
return 0.0;
}
E todos os testes passaram! Não houve problemas. Portanto, agora vamos nos certificar de que todo
o processamento de erros funcione corretamente. No próximo caso de teste, um erro é declarado se
uma string cujo valor não corresponda ao tipo esperado é passada em um parâmetro ##.
public void testInvalidDouble() throws Exception {
Args args = new Args("x##", new String[] {"-x","Forty two"));
assertFalse(args.isValid());
assertEquals(0, args.cardinality());
assertFalse(args.has('x'));
assertEquals(0, args.getInt('x'));
assertEquals("Parâmetro -x espera um double mas recebeu 'Quarentae
Dois'.",
---
args.errorMessage());
public String errorMessage() throws Exception {
switch (errorCode) {
case OК:
throw new Exception("TILT: Não deve entrar aqui.");
case UNEXPECTED_ARGUMENT:
return unexpectedArgumentMessage();
case MISSING_STRING:
return String.format("Não foi possível encontrar um
parâmetro string para -с.",
errorArgumentId);
Parâmetros do tipo string 235
mas recebeu
case INVALID INTEGER:
return String.format("Parâmetro -%c espera um integer
s'.", errorArgumentId, errorParameter);
case MISSING_INTEGER:
return String.format("Não foi possível encontrar um
parâmetro integer para -%c.",
errorArgumentId);
case INVALID DOUBLE:
return String.format("Parâmetro -%c espera um double mas
recebeu %s'."
errorArgumentId, errorParameter);
case MISSING DOUBLE:
return String.format("Não foi possível encontrar um parâmetro
double para -%c.", errorArgumentId);
}
}
return "";
O teste passa com êxito. O próximo garante que detectemos devidamente um parâmetro double
que está faltando.
public void testMissingDouble() throws Exception {
Args args = new Args("x##", new String[]{"-x"});
assertFalse(args.isValid());
assertEquals(0, args.cardinality());
assertFalse(args.has('x'));
assertEquals(0.0, args.getDouble('x'), 0.01);
assertEquals("Não foi possível encontrar um parâmetro double para -x.",
args.errorMessage());
}
O teste passa normalmente. Fizemos isso apenas por questão de finalização.
O código de exceção está horrível e não pertence à classe Args. Também estamos lançando a
ParseException, que não cabe a nós. Portanto, vamos unir todas as exceções em uma única
classe, ArgsException, e colocá-la em seu próprio módulo.
public class ArgsException extends Exception {
private char errorArgumentId = \0';
private String errorParameter = "TILT";
private ErrorCode errorCode = ErrorCode.OK;
public ArgsException() }}
public ArgsException(String message) {super(message);}
public enum ErrorCode {
OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER,
UNEXPECTED_ARGUMENT,
MISSING_DOUBLE, INVALID_DOUBLE)
}
236 Capítulo 14: Refinamento Sucessivo
public class Args {
OK;
private char errorArgumentId = \0;
private String errorParameter = "TILT";
private ArgsException.ErrorCode errorCode = ArgsException.ErrorCode.
private List<String> argsList;
public Args(String schema, String[] args) throws ArgsException
this.schema = schema;
argsList = Arrays.asList(args); valid = parse();
private boolean parse() throws ArgsException {
if (schema.length() == 0 && argsList.size() ==
return true;
parseSchema();
parseArguments();
try {
} catch (ArgsException e) {
}
return valid;
}
0)
}
private boolean parseSchema() throws ArgsException
}
{
private void parseSchemaElement(String element) throws ArgsException
else
throw new ArgsException(
String.format("Parâmetro: %c possui formato
%s.",
elementId,elementTail));
private void validateSchemaElementId(char
ArgsException }
if (!Character.isLetter(elementId))
throw new ArgsException(
formato d Args:"+ schema);
}
inválido:
elementId) throws
"Caractere errado:" + elementId + "no
private void parseElement(char argChar) throws ArgsException
if (setArgument(argChar)) argsFound.add(argChar);
else
unexpectedArguments.add(argChar);
errorCode = ArgsException.ErrorCode.UNEXPECTED
ARGUMENT;
valid = false;
}
Parâmetros do tipo string 237
}
private class StringArgumentMarshaler implements ArgumentMarshaler
private String stringValue = "
public void set(Iterator<String> currentArgument) throws
ArgsException {
try {
stringValue = currentArgument.next();
catch (NoSuchElementException e) {
errorCode = ArgsException.ErrorCode.MISSING
STRING;
}
throw new ArgsException();
public Object get() {
return stringValue;
}
}
{
private class IntegerArgumentMarshaler implements ArgumentMarshaler
private int intValue = 0;
public void set(Iterator<String> currentArgument) throws
ArgsException {
String parameter = null:
try {
parameter = currentArgument.next();
intValue = Integer.parseInt(parameter);
INTEGER;
catch (NoSuchElementException e) {
errorCode = ArgsException.ErrorCode.MISSING_
throw new ArgsException();
} catch (NumberFormatException e) {
errorParameter = parameter;
errorCode = ArgsException.ErrorCode.INVALID_
INTEGER;
throw new ArgsException();
}
}
public Object get() {
return intValue;
}
}
private class DoubleArgumentMarshaler implements ArgumentMarshaler
private double doubleValue = 0;
public void set(Iterator<String> currentArgument) throws
ArgsException }
String parameter = null;
try {
parameter = currentArgument.next();
238 Capítulo 14: Refinamento Sucessivo
DOUBLЕ;
}
doubleValue = Double.parseDouble(parameter);
catch (NoSuchElementException e) {
errorCode = ArgsException.ErrorCode.MISSING_
throw new ArgsException();
j catch (NumberFormatException e) {
errorParameter = parameter;
errorCode = ArgsException.ErrorCode.INVALID
DOUBLE;
}
throw new ArgsException():
public Object get() {
return doubleValue;
}
}
}
Isso é bom. Agora Args lança apenas a exceção ArgsException que, ao ser movida para seu
próprio módulo, agora podemos retirar de Args os variados códigos de suporte a erros e colocar
naquele módulo. Isso oferece um local óbvio e natural para colocar todo aquele código e ainda
nos ajuda a limpar o módulo Args.
Portanto, agora separamos completamente os códigos de exceção e de erro do módulo Args.
(Veja da Listagem 14.13 à 14.16). Conseguimos isso apenas com pequenos 30 passos, fazendo
com que os testes rodem entre cada um.
Listagem 14-13
ArgsTest.java
package com.objectmentor.utilities.args;
import junit.framework.TestCase;
public class ArgsTest extends TestCase {
public void testCreateWithNoSchemaOrArguments() throws Exception
Args args = new Args("", new String[0]);
}
assertEquals (0, args.cardinality());
{
public void testWithNoSchemaButWithOneArgument() throws Exception {
try{
new Args("", new String[] {"-x"});
fail():
} catch (ArgsException e) {
assertEquals (ArgsException. ErrorCode.UNEXPECTED_ARGUMENT,
e.getErrorCode()):
assertEqualsi'x', e.getErrorArgumentId());
public void testwithNoSchemaButWithMultipleArguments() throws Exception
try {
new Args("", new String[]{"-x", "-y"});
fail():
Parâmetros do tipo string
Listagem 14-13 (continuação)
ArgsTest.java
} catch (ArgsException e) {
assertEquals (ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
e.getErrorCode());
assertEquals('x', e.getErrorArgumentId());
}
public void testNonLetterSchema() throws Exception
try {
new Args("*", new String(]{});
}
fail("Args constructor should have thrown exception");
) catch (ArgsException e) {
assertEquals (ArgsException. ErrorCode. INVALID_ARGUMENT_NAME,
e.getErrorCode()):
assertEquals('*', e.getErrorArgumentId{});
public void testInvalidArgumentFormat() throws Exception
try{
}
new Args("f-", new String[1{});
fail("Args constructor should have throws exception");
catch (ArgsException e) {
{
assertEquals (ArgsException.ErrorCode. INVALID_FORMAT, e.getErrorCode());
assertEquals('f', e.getErrorArgumentId());
public void testSimpleBooleanPresent() throws Exception {
}
Args args = new Args("x", new String[] {"-x"});
assertEquals (1, args.cardinality()):
assertEquals(true, args.getBoolean('x'));
public void testSimpleStringPresent() throws Exception {
Args args = new Args("x*", new String[]{"-x". "param"}); assertEquals(1, args.cardinality());
assertTrue (args.has('x'));
assertEquals("param", args.getString('x'));
public void testMissingStringArgument() throws Exception
try
new Args ("x*", new String[]{"-x"});
fail();
catch (ArgsException e) {
assertEquals (ArgsException.ErrorCode.MISSING_STRING, e.getErrorCode());
assertEquals('x', e.getErrorArgumentId());
public void testSpacesInFormat() throws Exception {
Args args = new Args("x, y", new String[]{"-xy"}); assertEquals(2, args.cardinality());
239
240 Capítulo 14: Refinamento Sucessivo
Listagem 14-13 (continuação)
ArgsTest.java
assertTrue (args.has('x'));
assertTrue(args.has('y'));
public void testSimpleIntPresent () throws Exception {
Args args = new Args("x#", new String[] {"-x", "42"));
assertEquals(1, args.cardinality(});
assertTrue(args.has('x'));
assertEquals (42, args.getInt('x'));
3
public void testInvalidInteger() throws Exception {
try
}
new Args("x#", new String[]{"-x", "Forty two"});
fail();
} catch (ArgsException e){
assertEquals (ArgsException.ErrorCode. INVALID_INTEGER, e.getErrorCode()); assertEquals('x', e.getErrorArgumentId());
assertEqualsi"Forty two". e.getErrorParameter());
public void testMissingInteger!) throws Exception
try {
new Args("x#", new String[]{"-x"});
fail();
) catch (ArgsException e) {
assertEquals (ArgsException.ErrorCode.MISSING_INTEGER, e.getErrorCode());
assertEquals('x', e.getErrorArgumentId());
}
}
}
public void testSimpleDoublePresent() throws Exception {
Args args = new Args("x##", new String[]{*-x", "42.3"));
assertEquals (1, args.cardinality());
assertTrue(args.has('x'));
assertEquals (42.3, args.getDouble('x'),.001);
public void testInvalidDouble() throws Exception {
try{
new Args("x##", new String[]{"-x", "Forty two"});
fail();
catch (ArgsException e) {
assertEquals (ArgsException.ErrorCode.INVALID_DOUBLE, e.getErrorCode();
assertEquals('x', e.getErrorArgumentId());
assertEquals("Forty two", e.getErrorParameter());
}
}
public void testMissingDoublei) throws Exception {
try {
new Args("x##", new String[]{"-x"});
Parâmetros do tipo string
Listagem 14-13 (continuação)
ArgsTest.java
new Args("x##", new String[]{"-x", "Forty two"}!;
fail();
catch (ArgsException e) {
assertEquals (ArgsException.ErrorCode.INVALID_DOUBLE, e.getErrorCode (!);
assertEquals('x', e.getErrorArgumentId());
assertEquals("Forty two", e.getErrorParameter();
public void testMissingDouble{} throws Exception {
try {
new Args("x##", new String[]{"-x"});
fail();
} catch (ArgsException e)
assertEquals (ArgsException. ErrorCode.MISSING_DOUBLE, e.getErrorCode()};
assertEquals('x', e.getErrorArgumentId());
Listagem 14-14
ArgsExceptionTest.java
public class ArgsExceptionTest extends TestCase {
public void testUnexpectedMessage() throws Exception
ArgsException e =
}
{
new ArgsException (ArgsException. ErrorCode.UNEXPECTED_ARGUMENT,
'x', null);
assertEquals ("Argument -x unexpected.", e.errorMessage());
public void testMissingStringMessage() throws Exception
ArgsException e = new ArgsException (ArgsException.ErrorCode.MISSING STRING,
'x', null);
assertEquals ("Could not find string parameter for -x.", e.errorMessagei));
public void testInvalidIntegerMessage() throws Exception
ArgsException e =
new ArgsException (ArgsException.ErrorCode.INVALID_INTEGER,
'x', "Forty two*);
assertEquals("Argument -x expects an integer but was 'Forty two'.",
e.errorMessage());
public void testMissingIntegerMessage() throws Exception {
ArgsException e =
new ArgsException (ArgsException.ErrorCode.MISSING_INTEGER, 'x', null);
assertEquals ("Could not find integer parameter for -x.", e.errorMessage());
public void testinvalidDoubleMessage(} throws Exception {
ArgsException e = new ArgsException (ArgsException.ErrorCode.INVALID_DOUBLE,
241
242 Capítulo 14: Refinamento Sucessivo
Listagem 14-14 (continuação)
ArgsExceptionTest.java
'x', "Forty two");
assertEquals("Argument -x expects a double but was 'Forty two'.".
e.errorMessage ());
public void testMissingDoubleMessagei) throws Exception {
ArgsException e = new ArgsException (ArgsException.ErrorCode.MISSING_DOUBLE,
'x', null);
assertEqualsi"Could not find double parameter for -x.", e.errorMessage());
Listagem 14-15
ArgsException.java
public class ArgsException extends Exception {
private char errorArgumentId = '\0';
private String errorParameter = "TILT";
private ErrorCode errorCode = ErrorCode.OK;
public ArgsException() {}
public ArgsException(String message) (super(message);)
public ArgsException (ErrorCode errorCode) {
this.errorCode = errorCode;
public ArgsException (ErrorCode errorCode, String errorParameter)
this.errorCode = errorCode;
this.errorParameter = errorParameter;
}
public ArgsException (ErrorCode errorCode, char errorArgumentId,
String errorParameter) {
this.errorCode = errorCode;
this.errorParameter = errorParameter;
this.errorArgument Id = errorArgumentId;
public char getErrorArgumentId() {
return errorArgumentId:
}
public void setErrorArgumentId(char errorArgumentId)
this.errorArgumentId = errorArgumentId;
}
Parâmetros do tipo string
Listagem 14-15 (continuação)
ArgsException.java
public void setErrorArgumentId(char errorArgumentId)
this.errorArgumentId = errorArgumentId;
}
public String getErrorParameter() {
return errorParameter;
}
public void setErrorParameter(String errorParameter) {
this.errorParameter = errorParameter;
}
public ErrorCode getErrorCode() {
return errorCode;
public void setErrorCode (ErrorCode errorCode) {
this.errorCode = errorCode;
public String errorMessagei) throws Exception
switch lerrorCode) {
case OK:
throw new Exception("TILT: Should not get here.");
case UNEXPECTED_ARGUMENT:
return String.format ("Argument-&c unexpected.", errorArgumentId);
case MISSING STRING:
return String.format ("Could not find string parameter for -%c.",
errorArgumentId):
case INVALID INTEGER:
return String.format ("Argument -%c expects an integer but was '%s'.",
errorArgumentId, errorParameter);
case MISSING_INTEGER:
return String.format ("Could not find integer parameter for -%c.",
errorArgumentId);
case INVALID DOUBLE:
return String.format("Argument -%c expects a double but was '%s"."
errorArgumentId, errorParameter);
case MISSING DOUBLE:
return String.format ("Could not find double parameter for -%c.".
errorArgumentId):
}
return ""
}
public enum ErrorCode {
OK, INVALID_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
MISSING_STRING,
MISSING_INTEGER, INVALID_INTEGER,
MISSING_DOUBLE, INVALID_DOUBLE)
243
244
Listagem 14-16
Args.java
public class Args {
private String schema;
private Map<Character, ArgumentMarshaler> marshalers =
new HashMap<Character, ArgumentMarshaler>();
private Set<Character> argsFound = new HashSet<Character>();
private Iterator<String> currentArgument;
private List<String> argsList;
public Args (String schema, String[] args) throws ArgsException
this.schema = schema;
argsList = Arrays.asList (args);
parse();
private void parse() throws ArgsException {
parseSchema{);
parseArguments ();
private boolean parseSchema() throws ArgsException
for (String element: schema.split(","i)
if (element.length() > 0) {
parseSchemaElement (element.trim());
{
}
return true;
}
private void parseSchemaElement (String element) throws ArgsException
char elementId = element.charAt (0);
String elementTail = element.substring(1};
validateSchemaElementId (elementId);
if (elementTail.length() == 0) marshalers.put(elementId, new BooleanArgumentMarshaler());
else if (elementTail.equals ("*"))
marshalers.put(elementId, new StringArgumentMarshaler());
else if (elementTail.equals("#"))
marshalers.put(elementId, new IntegerArgumentMarshaler(!);
else if (elementTail.equals ("##"))
marshalers.put (elementId, new DoubleArgumentMarshaler());
else
throw new ArgsException(ArgsException.ErrorCode.INVALID_FORMAT,
elementId, elementTail);
{
private void validateSchemaElementId(char elementId) throws ArgsException
if (!Character.isLetter(elementId)} {
throw new ArgsException(ArgsException. ErrorCode. INVALID_ARGUMENT_NAME,
elementId, null);
}
}
Parâmetros do tipo string
Listagem 14-16 (continuação)
Args.java
private void parseArguments() throws ArgsException
for (currentArgument = argsList.iterator{): currentArgument.hasNext();) {
String arg = currentArgument.next();
parseArgument (arg);
}
private void parseArgument(String arg) throws ArgsException
if (arg.startsWith("-")
parseElements (arg):
}
}
private void parseElements (String arg) throws ArgsException
for (int i = 1; i < arg.length(); i++!
parseElement (arg.charAt (i));
private void parseElement (char argChar) throws ArgsException
if (setArgument (argChar))
argsFound.add(argChar):
else {
}
{
throw new ArgsException(ArgsException. ErrorCode. UNEXPECTED_ARGUMENT,
argChar, null);
private boolean setArgument (char argChar) throws ArgsException
ArgumentMarshaler m = marshalers.get (argChar);
if (m == null)
return false;
try {
m.set(currentArgument);
return true;
} catch (ArgsException e) {
e.setErrorArgumentId(argChar);
throw e;
245
A maioria das mudanças da classe Args foiforam exclusões. Muito do código foi apenas
removido de Args e colocado em ArgsException. Otimo. Também movemos todos os
ArgumentMarshaller para seus próprios arquivos. Melhor ainda.
Muitos dos bons projetos de software se resumem ao particionamento criar locais apropriados
para colocar diferentes tipos de código. Essa separação de preocupações torna o código muito
mais simples para se manter e compreender.
De interesse especial temos o método errorMessage de ArgsException. Obviamente, é
uma violação ao SRP colocar a formatação da mensagem de erro em Args. Este deve apenas
processar os parâmetros, e não o formato de tais mensagens. Entretanto, realmente faz sentido
colocar o código da formatação das mensagens de erro em ArgsException?
Francamente, é uma obrigação. Os usuários não gostam de ter que de criar eles mesmos as
mensagens de erro fornecidas por ArgsException. Mas a conveniência de ter mensagens de
erro prontas e já preparadas para você não é insignificante.
246
A esta altura já deve estar claro que estamos perto da solução final que surgiu no início deste
capítulo. Deixarei como exercício para você as últimas modificações.
Conclusão
Isso não basta para que um código funcione. Um código que funcione, geralmente possui
bastantes erros. Os programadores que se satisfazem só de em verem um código funcionando
não estão se comportando de maneira profissional. Talvez temam que não tenham tempo para
melhorara estrutura e o modelo de seus códigos, mas eu discordo. Nada tem um efeito mais
intenso e degradante em longo termo sobre um projeto de desenvolvimento do que um código
ruim. É possível refazer cronogramas e redefinir requisitos ruins.
Podem-se consertar as dinâmicas ruins de uma equipe. Mas um código ruim apodrece e degrada,
tornando-se um peso que se leva a equipe consigo. Não me canso de ver equipes caírem num
passo lentíssimo devido à pressa inicial que os levou a criar uma massa maligna de código que
acabou selando seus destinos.
É claro que se pode-se limpar um código ruim. Mas isso sai caro. Conforme o código degrada, os
módulos se perpetuam uns para os outros, criando muitas dependências ocultas e intrincadas.
Encontrar e remover dependências antigas é uma tarefa árdua e longa. Por outro lado, manter
o código limpo é relativamente fácil. Se você fizer uma bagunça em um módulo pela manhã, é
mais fácil limpá-lo pela tarde. Melhor ainda, se fez a zona a cinco minutos atrás, é muito mais
fácil limpá-la agora mesmo.
Sendo assim, a solução é constantemente manter seu código o mais limpo e simples possível.
Jamais deixe que ele comece a se degradar.
1. Recentemente reescrevi este modulo em Ruby e ele ficou com 1/7 do tamanho e com uma
estrutura levemente melhor.
2. A fim de evitar surpresas desse tipo mais tarde, adicionei um novo teste de unidade que invoca
todos os testes do FitNesse.